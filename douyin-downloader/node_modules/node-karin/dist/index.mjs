import fs24 from 'fs';
import path from 'path';
import require$$2 from 'os';
import require$$22 from 'crypto';
import { fileURLToPath } from 'url';
import fs5, { promises, existsSync as existsSync$1 } from 'node:fs';
import YAML, { isMap, isSeq, isPair } from 'yaml';
import { spawn, execSync, exec as exec$2 } from 'node:child_process';
import path4, { join } from 'node:path';
import chokidar from 'chokidar';
import axios8, { AxiosError } from 'axios';
import util5, { promisify } from 'node:util';
import { pipeline, Readable } from 'node:stream';
import lodash3 from 'lodash';
import { URL as URL$1, pathToFileURL, fileURLToPath as fileURLToPath$1 } from 'node:url';
import { createRequire } from 'module';
import crypto, { randomUUID, createHmac } from 'node:crypto';
import { EventEmitter } from 'node:events';
import WebSocket, { WebSocket as WebSocket$1, WebSocketServer } from 'ws';
import require$$02 from 'buffer';
import require$$32 from 'stream';
import require$$5 from 'util';
import os, { homedir } from 'node:os';
import { isPromise } from 'util/types';
import { exec as exec$1, spawn as spawn$1 } from 'child_process';
import { lookup } from 'dns/promises';
import { createServer as createServer$1 } from 'node:net';
import sqlite3 from 'sqlite3';
import template from 'art-template';
import schedule from 'node-schedule';
import moment from 'moment';
import { createClient } from 'redis';
import chalk2 from 'chalk';
import log4js from 'log4js';
import express2, { Router } from 'express';
import { createServer } from 'node:http';
import { createBrotliDecompress } from 'node:zlib';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function requireMain() {
  if (hasRequiredMain) return main$1.exports;
  hasRequiredMain = 1;
  const fs37 = fs24;
  const path36 = path;
  const os5 = require$$2;
  const crypto9 = require$$22;
  const packageJson = require$$4;
  const version2 = packageJson.version;
  const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse2(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault2(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0; i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message2) {
    console.log(`[dotenv@${version2}][WARN] ${message2}`);
  }
  function _debug(message2) {
    console.log(`[dotenv@${version2}][DEBUG] ${message2}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs37.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path36.resolve(process.cwd(), ".env.vault");
    }
    if (fs37.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path36.join(os5.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault2(options) {
    const debug3 = Boolean(options && options.debug);
    if (debug3) {
      _debug("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv2(options) {
    const dotenvPath = path36.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug3 = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug3) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path210 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs37.readFileSync(path210, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug3) {
          _debug(`Failed to load ${path210} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config3(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt2(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto9.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  }
  function populate2(processEnv, parsed, options = {}) {
    const debug3 = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug3) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  const DotenvModule = {
    configDotenv: configDotenv2,
    _configVault: _configVault2,
    _parseVault: _parseVault2,
    config: config3,
    decrypt: decrypt2,
    parse: parse2,
    populate: populate2
  };
  main$1.exports.configDotenv = DotenvModule.configDotenv;
  main$1.exports._configVault = DotenvModule._configVault;
  main$1.exports._parseVault = DotenvModule._parseVault;
  main$1.exports.config = DotenvModule.config;
  main$1.exports.decrypt = DotenvModule.decrypt;
  main$1.exports.parse = DotenvModule.parse;
  main$1.exports.populate = DotenvModule.populate;
  main$1.exports = DotenvModule;
  return main$1.exports;
}
var main$1, version, require$$4, hasRequiredMain, mainExports, main, dotenv;
var init_main_D88Wwqn3 = __esm({
  "../../node_modules/.pnpm/@karinjs+dotenv@1.1.2/node_modules/@karinjs/dotenv/dist/main-D88Wwqn3.js"() {
    main$1 = { exports: {} };
    version = "16.5.0";
    require$$4 = {
      version
    };
    mainExports = requireMain();
    main = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
    dotenv = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: main
    }, [mainExports]);
  }
});

// ../../node_modules/.pnpm/@karinjs+dotenv@1.1.2/node_modules/@karinjs/dotenv/dist/index.js
var _configVault, _parseVault;
var init_dist = __esm({
  "../../node_modules/.pnpm/@karinjs+dotenv@1.1.2/node_modules/@karinjs/dotenv/dist/index.js"() {
    init_main_D88Wwqn3();
    ({
      _configVault: (
        // @ts-ignore
        _configVault
      ),
      _parseVault
    } = dotenv);
    mainExports.config;
    mainExports.configDotenv;
    mainExports.decrypt;
    mainExports.parse;
    mainExports.populate;
  }
});

// ../../node_modules/.pnpm/@karinjs+dotenv@1.1.2/node_modules/@karinjs/dotenv/index.js
var app, dotenv_default;
var init_dotenv = __esm({
  "../../node_modules/.pnpm/@karinjs+dotenv@1.1.2/node_modules/@karinjs/dotenv/index.js"() {
    init_dist();
    init_dist();
    app = dotenv.default;
    dotenv_default = app;
  }
});
var filename, karinPathRoot, karinPathMain, karinPathPlugins, isPackaged, karinPathDefaultConfig, karinPathDefaultView, karinPathComment, karinPathBase, karinPathConfig, karinPathData, karinPathTemp, karinPathResource, karinPathDb, karinPathTaskDb, karinPathRedisSqlite3, karinPathKv, karinPathLogs, karinPathHtml, karinPathPm2Config, karinPathConsole, karinPathSandboxData, karinPathSandboxTemp, karinDir, karinMain, pluginDir, isPkg, defaultConfigPath, defaultViewPath, commentPath, basePath, configPath, dataPath, tempPath, resourcePath, dbPath, redisSqlite3Path, kvPath, logsPath, htmlPath, pm2Path, consolePath, sandboxDataPath, sandboxTempPath, root_default;
var init_root = __esm({
  "src/root.ts"() {
    filename = fileURLToPath(import.meta.url);
    karinPathRoot = Object.freeze(path.join(filename, "../..").replace(/\\/g, "/"));
    karinPathMain = Object.freeze(path.join(karinPathRoot, "dist", "index.js"));
    karinPathPlugins = Object.freeze(path.join(process.cwd(), "plugins"));
    isPackaged = Object.freeze(filename.includes("node_modules"));
    karinPathDefaultConfig = Object.freeze(path.join(karinPathRoot, "default", "config"));
    karinPathDefaultView = Object.freeze(path.join(karinPathRoot, "default", "view"));
    karinPathComment = Object.freeze(path.join(karinPathRoot, "default", "comment"));
    karinPathBase = Object.freeze(path.join(process.cwd(), "@karinjs"));
    karinPathConfig = Object.freeze(path.join(karinPathBase, "config"));
    karinPathData = Object.freeze(path.join(karinPathBase, "data"));
    karinPathTemp = Object.freeze(path.join(karinPathBase, "temp"));
    karinPathResource = Object.freeze(path.join(karinPathBase, "resource"));
    karinPathDb = Object.freeze(path.join(karinPathData, "db"));
    karinPathTaskDb = Object.freeze(path.join(karinPathDb, "task"));
    karinPathRedisSqlite3 = Object.freeze(path.join(karinPathDb, "redis-sqlite3"));
    karinPathKv = Object.freeze(path.join(karinPathDb, "kv"));
    karinPathLogs = Object.freeze(path.join(karinPathBase, "logs"));
    karinPathHtml = Object.freeze(path.join(karinPathTemp, "html"));
    karinPathPm2Config = Object.freeze(path.join(karinPathConfig, "pm2.yaml"));
    karinPathConsole = Object.freeze(path.join(karinPathTemp, "console"));
    karinPathSandboxData = Object.freeze(path.join(karinPathData, "sandbox"));
    karinPathSandboxTemp = Object.freeze(path.join(karinPathTemp, "sandbox"));
    karinDir = karinPathRoot;
    karinMain = karinPathMain;
    pluginDir = karinPathPlugins;
    isPkg = isPackaged;
    defaultConfigPath = karinPathDefaultConfig;
    defaultViewPath = karinPathDefaultView;
    commentPath = karinPathComment;
    basePath = karinPathBase;
    configPath = karinPathConfig;
    dataPath = karinPathData;
    tempPath = karinPathTemp;
    resourcePath = karinPathResource;
    dbPath = karinPathDb;
    redisSqlite3Path = karinPathRedisSqlite3;
    kvPath = karinPathKv;
    logsPath = karinPathLogs;
    htmlPath = karinPathHtml;
    pm2Path = karinPathPm2Config;
    consolePath = karinPathConsole;
    sandboxDataPath = karinPathSandboxData;
    sandboxTempPath = karinPathSandboxTemp;
    root_default = {
      // 新常量
      karinPathRoot,
      karinPathMain,
      karinPathPlugins,
      isPackaged,
      karinPathDefaultConfig,
      karinPathDefaultView,
      karinPathComment,
      karinPathBase,
      karinPathConfig,
      karinPathData,
      karinPathTemp,
      karinPathResource,
      karinPathDb,
      karinPathRedisSqlite3,
      karinPathKv,
      karinPathLogs,
      karinPathHtml,
      karinPathPm2Config,
      karinPathConsole,
      karinPathSandboxData,
      karinPathSandboxTemp,
      karinPathTaskDb,
      // 旧常量，保持兼容性
      karinDir,
      karinMain,
      pluginDir,
      isPkg,
      defaultConfigPath,
      defaultViewPath,
      commentPath,
      basePath,
      configPath,
      dataPath,
      tempPath,
      resourcePath,
      dbPath,
      redisSqlite3Path,
      kvPath,
      logsPath,
      htmlPath,
      pm2Path,
      consolePath,
      sandboxDataPath,
      sandboxTempPath
    };
  }
});
var IS_PNPM10, isWin, isDev, isTsx, isTs, isPnpm10, isWorkspace, setProcessEnv, setVersion, setRuntime, getModuleType;
var init_env = __esm({
  "src/env/env/index.ts"() {
    IS_PNPM10 = null;
    isWin = () => process.platform === "win32";
    isDev = () => process.env.NODE_ENV === "development";
    isTsx = () => process.env.RUNTIME === "tsx";
    isTs = () => isTsx();
    isPnpm10 = () => {
      try {
        if (IS_PNPM10 === null) {
          const version2 = execSync("pnpm -v").toString().trim();
          const majorVersion = parseInt(version2.split(".")[0], 10);
          IS_PNPM10 = !isNaN(majorVersion) && majorVersion >= 10;
        }
        return IS_PNPM10;
      } catch {
        IS_PNPM10 = false;
        return false;
      }
    };
    isWorkspace = () => {
      const workspace = fs5.existsSync(`${process.cwd()}/pnpm-workspace.yaml`);
      if (!workspace) return false;
      const data = YAML.parse(fs5.readFileSync(`${process.cwd()}/pnpm-workspace.yaml`, "utf-8"));
      return Array.isArray(data.packages) && data.packages.length > 0;
    };
    setProcessEnv = (key, value) => {
      process.env[key] = value + "";
      return value;
    };
    setVersion = (version2) => setProcessEnv("KARIN_VERSION", version2);
    setRuntime = (runtime) => setProcessEnv("RUNTIME", runtime);
    getModuleType = () => {
      if (isTs()) {
        return [".ts", ".js", ".cts", ".mts", ".mjs", ".cjs"];
      }
      return [".js", ".cjs", ".mjs"];
    };
  }
});

// src/env/key/redis.ts
var REDIS_PLUGIN_LIST_CACHE_KEY, REDIS_DEPENDENCIES_LIST_CACHE_KEY, REDIS_PLUGIN_MARKET_LIST_CACHE_KEY, REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY, REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY_FRONTEND, REDIS_DEPENDENCIES_LIST_CACHE_EXPIRE, REDIS_PLUGIN_MARKET_LIST_CACHE_EXPIRE, REDIS_PLUGIN_LIST_CACHE_EXPIRE, REDIS_LOCAL_PLUGIN_LIST_CACHE_EXPIRE_FRONTEND;
var init_redis = __esm({
  "src/env/key/redis.ts"() {
    REDIS_PLUGIN_LIST_CACHE_KEY = "karin:market:plugin:list";
    REDIS_DEPENDENCIES_LIST_CACHE_KEY = "karin:dependencies:list";
    REDIS_PLUGIN_MARKET_LIST_CACHE_KEY = "karin:market:plugin:list:v2";
    REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY = "karin:local:plugin:list";
    REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY_FRONTEND = "karin:local:plugin:list:frontend";
    REDIS_DEPENDENCIES_LIST_CACHE_EXPIRE = 24 * 60 * 60;
    REDIS_PLUGIN_MARKET_LIST_CACHE_EXPIRE = 24 * 60 * 60;
    REDIS_PLUGIN_LIST_CACHE_EXPIRE = 24 * 60 * 60;
    REDIS_LOCAL_PLUGIN_LIST_CACHE_EXPIRE_FRONTEND = 24 * 60 * 60;
  }
});

// src/env/key/event.ts
var ONLINE;
var init_event = __esm({
  "src/env/key/event.ts"() {
    ONLINE = "online";
  }
});

// src/env/key/index.ts
var init_key = __esm({
  "src/env/key/index.ts"() {
    init_redis();
    init_event();
  }
});

// src/env/index.ts
var init_env2 = __esm({
  "src/env/index.ts"() {
    init_env();
    init_key();
  }
});
var cache, clearRequireFile, clearRequire, requireFile, requireFileSync, fileReady, fileCache, touchRequireFile, parseContent;
var init_require = __esm({
  "src/utils/fs/require.ts"() {
    cache = /* @__PURE__ */ new Map();
    clearRequireFile = (filePath) => {
      const absPath2 = path4.resolve(filePath).replace(/\\/g, "/");
      return cache.has(absPath2) && cache.delete(absPath2);
    };
    clearRequire = () => cache.clear();
    requireFile = async (filePath, options = {}) => {
      const now = Date.now();
      const absPath2 = path4.resolve(filePath).replace(/\\/g, "/");
      const { encoding = "utf-8", force = false, ex = 300, size = 0, parser: parser2, type, readCache } = options;
      const data = fileReady(absPath2, now, force, ex, readCache);
      if (data !== false) return data;
      const content = await fs5.promises.readFile(absPath2, encoding);
      return fileCache(content, absPath2, ex, now, size, encoding, parser2, type);
    };
    requireFileSync = (filePath, options = {}) => {
      const now = Date.now();
      const absPath2 = path4.resolve(filePath).replace(/\\/g, "/");
      const { encoding = "utf-8", force = false, ex = 300, size = 0, parser: parser2, type, readCache } = options;
      const data = fileReady(absPath2, now, force, ex, readCache);
      if (data !== false) return data;
      const content = fs5.readFileSync(absPath2, encoding);
      return fileCache(content, absPath2, ex, now, size, encoding, parser2, type);
    };
    fileReady = (absPath2, now, force, ex, readCache) => {
      if (!force) {
        const cached = cache.get(absPath2);
        if (cached) {
          if (cached.expiry === 0 || cached.expiry > now) {
            if (ex <= 0) return cached.data;
            touchRequireFile(absPath2, ex);
            return cached.data;
          } else {
            cache.delete(absPath2);
          }
        }
        if (readCache) return void 0;
      }
      return false;
    };
    fileCache = (content, absPath2, ex, now, size, encoding, parser2, type) => {
      if (size > 0 && Buffer.byteLength(content, encoding) > size) {
        return parseContent(absPath2, content, parser2, type);
      }
      const data = parseContent(absPath2, content, parser2, type);
      const expiry = ex === 0 ? 0 : now + ex * 1e3;
      cache.set(absPath2, { data, expiry });
      return data;
    };
    touchRequireFile = async (filePath, ex) => {
      const entry = cache.get(filePath);
      if (entry) {
        entry.expiry = Date.now() + ex * 1e3;
        cache.set(filePath, entry);
      }
    };
    parseContent = (absPath2, content, parser2, type) => {
      if (parser2) return parser2(content);
      if (type) {
        if (type === "json") return JSON.parse(content);
        if (type === "yaml" || type === "yml") return YAML.parse(content);
      }
      if (absPath2.endsWith(".json")) return JSON.parse(content);
      if (absPath2.endsWith(".yaml") || absPath2.endsWith(".yml")) return YAML.parse(content);
      return content;
    };
    setInterval(() => {
      const now = Date.now();
      for (const [key, entry] of cache.entries()) {
        if (entry.expiry === 0) continue;
        if (entry.expiry <= now) cache.delete(key);
      }
    }, 6e4);
  }
});

// src/utils/config/pkg.ts
var pkg;
var init_pkg = __esm({
  "src/utils/config/pkg.ts"() {
    init_root();
    init_require();
    pkg = () => requireFileSync(`${karinDir}/package.json`);
  }
});

// src/utils/config/default.ts
var defaultConfig;
var init_default = __esm({
  "src/utils/config/default.ts"() {
    defaultConfig = Object.freeze({
      adapter: {
        console: {
          isLocal: true,
          token: "",
          host: ""
        },
        onebot: {
          ws_server: {
            enable: true,
            timeout: 120
          },
          ws_client: [
            {
              enable: false,
              url: "ws://127.0.0.1:7778",
              token: ""
            }
          ],
          http_server: [
            {
              enable: false,
              self_id: "default",
              url: "http://127.0.0.1:6099",
              token: "",
              api_token: "",
              post_token: ""
            }
          ]
        }
      },
      config: {
        master: [
          "console"
        ],
        admin: [],
        user: {
          enable_list: [],
          disable_list: []
        },
        friend: {
          enable: true,
          enable_list: [],
          disable_list: [],
          log_enable_list: [],
          log_disable_list: []
        },
        group: {
          enable: true,
          enable_list: [],
          disable_list: [],
          log_enable_list: [],
          log_disable_list: []
        },
        directs: {
          enable: true,
          enable_list: [],
          disable_list: [],
          log_enable_list: [],
          log_disable_list: []
        },
        guilds: {
          enable: true,
          enable_list: [],
          disable_list: [],
          log_enable_list: [],
          log_disable_list: []
        },
        channels: {
          enable: true,
          enable_list: [],
          disable_list: [],
          log_enable_list: [],
          log_disable_list: []
        }
      },
      groups: [
        {
          key: "default",
          inherit: true,
          cd: 0,
          userCD: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: [],
          member_enable: [],
          member_disable: []
        },
        {
          key: "global",
          inherit: true,
          cd: 0,
          userCD: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: [],
          member_enable: [],
          member_disable: []
        },
        {
          key: "Bot:selfId",
          inherit: true,
          cd: 0,
          userCD: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: [],
          member_enable: [],
          member_disable: []
        },
        {
          key: "Bot:selfId:groupId",
          inherit: true,
          cd: 0,
          userCD: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: [],
          member_enable: [],
          member_disable: []
        },
        {
          key: "Bot:selfId:guildId",
          inherit: true,
          cd: 0,
          userCD: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: [],
          member_enable: [],
          member_disable: []
        },
        {
          key: "Bot:selfId:guildId:channelId",
          inherit: true,
          cd: 0,
          userCD: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: [],
          member_enable: [],
          member_disable: []
        }
      ],
      pm2: {
        lines: 1e3,
        apps: [
          {
            name: "karin",
            script: "index.js",
            autorestart: true,
            max_restarts: 60,
            max_memory_restart: "1G",
            restart_delay: 2e3,
            merge_logs: true,
            error_file: "./@karinjs/logs/pm2_error.log",
            out_file: "./@karinjs/logs/pm2_out.log"
          }
        ]
      },
      privates: [
        {
          key: "default",
          inherit: true,
          cd: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: []
        },
        {
          key: "global",
          inherit: true,
          cd: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: []
        },
        {
          key: "Bot:selfId",
          inherit: true,
          cd: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: []
        },
        {
          key: "Bot:selfId:userId",
          inherit: true,
          cd: 0,
          mode: 0,
          alias: [],
          enable: [],
          disable: []
        }
      ],
      redis: {
        url: "redis://127.0.0.1:6379",
        username: "",
        password: "",
        database: 0
      },
      render: {
        ws_server: {
          enable: true
        },
        ws_client: [
          {
            enable: false,
            url: "ws://127.0.0.1:7005",
            token: "123456",
            isSnapka: false,
            reconnectTime: 5e3,
            heartbeatTime: 3e4
          }
        ],
        http_server: [
          {
            enable: false,
            url: "http://127.0.0.1:7005",
            token: "123456",
            isSnapka: false
          }
        ]
      }
    });
  }
});
var cache2, watch, watchAndMerge, Watch, Watcher;
var init_watch = __esm({
  "src/utils/fs/watch.ts"() {
    init_require();
    cache2 = /* @__PURE__ */ new Map();
    watch = (file2, fnc2, options) => {
      const isWatch = cache2.get(file2);
      if (isWatch) {
        isWatch.close();
        cache2.delete(file2);
      }
      const watcher2 = chokidar.watch(file2);
      cache2.set(file2, watcher2);
      watcher2.on("change", async () => {
        logger.info(`[watch][change] ${path4.relative(process.cwd(), file2).replace(/\\/g, "/")}`);
        const oldData = requireFileSync(file2, { ...options, readCache: true });
        clearRequireFile(file2);
        const newData = requireFileSync(file2, { ...options, force: true });
        typeof fnc2 === "function" && fnc2(oldData, newData);
      });
      watcher2.on("unlink", () => {
        logger.info(`[watch][unlink] ${path4.relative(process.cwd(), file2).replace(/\\/g, "/")}`);
        clearRequireFile(file2);
      });
      watcher2.once("close", () => {
        cache2.delete(file2);
        clearRequireFile(file2);
      });
      return new Watch(file2, watcher2, options);
    };
    watchAndMerge = (dynamicFile, defaultCFile, fnc2) => {
      const watcher2 = watch(dynamicFile, fnc2);
      return new Watcher(dynamicFile, defaultCFile, watcher2.watcher, watcher2.options);
    };
    Watch = class {
      watcher;
      file;
      options;
      constructor(file2, watcher2, options) {
        this.watcher = watcher2;
        this.file = file2;
        this.options = options;
      }
      /**
       * @description 获取配置数据
       */
      get value() {
        return requireFileSync(this.file, this.options);
      }
      /**
       * @description 关闭监听器并清理全部缓存
       */
      close() {
        clearRequireFile(this.file);
        return this.watcher.close();
      }
    };
    Watcher = class {
      watcher;
      dynamicFile;
      defaultCFile;
      options;
      constructor(dynamicFile, defaultCfgFile, watcher2, options) {
        this.watcher = watcher2;
        this.dynamicFile = dynamicFile;
        this.defaultCFile = defaultCfgFile;
        this.options = options;
      }
      /**
       * @description 获取配置数据
       */
      get value() {
        const dynamicData = requireFileSync(this.dynamicFile, this.options);
        const defaultData = requireFileSync(this.defaultCFile, this.options);
        if (typeof defaultData === "object" && typeof dynamicData === "object") {
          return { ...defaultData, ...dynamicData };
        }
        if (Array.isArray(defaultData) && Array.isArray(dynamicData)) {
          return [...defaultData, ...dynamicData];
        }
        return dynamicData;
      }
      /**
       * @description 关闭监听器并清理全部缓存
       */
      close() {
        clearRequireFile(this.defaultCFile);
        return this.watcher.close();
      }
    };
  }
});
var exists, isDir, isFile, mkdir, existToMkdir;
var init_fsPromises = __esm({
  "src/utils/fs/fsPromises.ts"() {
    exists = async (file2) => {
      try {
        await fs5.promises.access(file2, fs5.constants.F_OK);
        return true;
      } catch {
        return false;
      }
    };
    isDir = async (file2) => {
      try {
        const stat = await fs5.promises.stat(file2);
        return stat.isDirectory();
      } catch {
        return false;
      }
    };
    isFile = async (file2) => {
      try {
        const stat = await fs5.promises.stat(file2);
        return stat.isFile();
      } catch {
        return false;
      }
    };
    mkdir = async (dirname) => {
      try {
        await fs5.promises.mkdir(dirname, { recursive: true });
        return true;
      } catch {
        return false;
      }
    };
    existToMkdir = async (file2) => {
      try {
        if (!await exists(file2)) await mkdir(file2);
        return true;
      } catch {
        return false;
      }
    };
  }
});
var existsSync, isDirSync, isFileSync, mkdirSync, existToMkdirSync, rmSync;
var init_fsSync = __esm({
  "src/utils/fs/fsSync.ts"() {
    existsSync = (file2) => {
      return fs5.existsSync(file2);
    };
    isDirSync = (file2) => {
      try {
        return fs5.statSync(file2).isDirectory();
      } catch {
        return false;
      }
    };
    isFileSync = (file2) => {
      try {
        return fs5.statSync(file2).isFile();
      } catch {
        return false;
      }
    };
    mkdirSync = (dirname) => {
      try {
        fs5.mkdirSync(dirname, { recursive: true });
        return true;
      } catch {
        return false;
      }
    };
    existToMkdirSync = (file2) => {
      try {
        if (!fs5.existsSync(file2)) mkdirSync(file2);
        return true;
      } catch {
        return false;
      }
    };
    rmSync = fs5.rmSync;
  }
});
var streamPipeline, sep, downloadFile, downFile, absPath, createPluginDir, getFiles, copyFilesSync, copyFiles, copyConfigSync, copyConfig, getAllFilesSync, getAllFiles;
var init_file = __esm({
  "src/utils/fs/file.ts"() {
    init_root();
    streamPipeline = promisify(pipeline);
    sep = path4.sep === "/" ? /^file:\/\// : /^file:[/]{2,3}/;
    downloadFile = async (fileUrl, savePath, options = {}) => {
      try {
        await fs5.promises.mkdir(path4.dirname(savePath), { recursive: true });
        const response = await axios8.get(fileUrl, { ...options, responseType: "stream" });
        await streamPipeline(response.data, fs5.createWriteStream(savePath));
        if (options.returnBoolean) {
          return true;
        }
        return { success: true, data: response.data };
      } catch (error) {
        if (options.returnBoolean) {
          return false;
        }
        return { success: false, data: error };
      }
    };
    downFile = async (fileUrl, savePath, param = {}) => {
      return downloadFile(fileUrl, savePath, { ...param, returnBoolean: true });
    };
    absPath = (file2, absPath2 = true, prefix = false) => {
      file2 = file2.replace(/\\/g, "/");
      if (file2.startsWith("file://")) file2 = file2.replace(sep, "");
      file2 = path4.normalize(file2);
      if (absPath2) file2 = path4.resolve(file2);
      if (prefix) file2 = "file://" + file2;
      return file2.replace(/\\/g, "/");
    };
    createPluginDir = async (name, files) => {
      if (!Array.isArray(files)) files = ["config", "data", "resources"];
      if (files.length === 0) return;
      const isOrgPkg = name.startsWith("@") && name.includes("/");
      let pluginPath = isOrgPkg ? path4.join(karinPathBase, name.replace("/", "-")) : path4.join(karinPathBase, name);
      if (isOrgPkg && !fs5.existsSync(pluginPath)) {
        const [orgName, pkgName] = name.split("/");
        pluginPath = path4.join(karinPathBase, orgName, pkgName);
      }
      await Promise.all(files.map((file2) => {
        const filePath = path4.join(pluginPath, file2);
        if (!fs5.existsSync(filePath)) return fs5.promises.mkdir(filePath, { recursive: true });
        return Promise.resolve();
      }));
    };
    getFiles = (filePath, suffixs = []) => {
      if (!fs5.existsSync(filePath)) {
        throw new Error(`\u8DEF\u5F84\u4E0D\u5B58\u5728: ${filePath}`);
      }
      let files = fs5.readdirSync(filePath, { withFileTypes: true }).filter((file2) => file2.isFile()).map((file2) => file2.name);
      if (suffixs.length) {
        const normalizedSuffixs = suffixs.map((suffix) => suffix.startsWith(".") ? suffix : `.${suffix}`);
        files = files.filter((file2) => {
          const suffix = path4.extname(file2);
          return suffix && normalizedSuffixs.includes(suffix);
        });
      }
      return files;
    };
    copyFilesSync = (files, defaulPath, userPath) => {
      files.forEach((file2) => {
        const defaulFile = path4.join(defaulPath, file2);
        const userFile = path4.join(userPath, file2);
        if (!fs5.existsSync(userFile)) {
          fs5.copyFileSync(defaulFile, userFile);
        }
      });
    };
    copyFiles = async (files, defaulPath, userPath) => {
      await Promise.all(files.map(async (file2) => {
        const defaulFile = path4.join(defaulPath, file2);
        const userFile = path4.join(userPath, file2);
        if (!fs5.existsSync(userFile)) {
          await fs5.promises.copyFile(defaulFile, userFile);
        }
      }));
    };
    copyConfigSync = (defaulPath, userPath, suffixs = [], isThrow = false) => {
      try {
        const files = getFiles(defaulPath, suffixs);
        fs5.mkdirSync(userPath, { recursive: true });
        fs5.mkdirSync(defaulPath, { recursive: true });
        copyFilesSync(files, defaulPath, userPath);
        return true;
      } catch (error) {
        if (isThrow) throw error;
        return false;
      }
    };
    copyConfig = async (defaulPath, userPath, suffixs = [], isThrow = false) => {
      try {
        const files = getFiles(defaulPath, suffixs);
        await Promise.all([
          fs5.promises.mkdir(userPath, { recursive: true }),
          fs5.promises.mkdir(defaulPath, { recursive: true })
        ]);
        await copyFiles(files, defaulPath, userPath);
        return true;
      } catch (error) {
        if (isThrow) throw error;
        return false;
      }
    };
    getAllFilesSync = (dir, options = {}) => {
      const { suffixs = [], exclude = [], returnType = "rel" } = options;
      const result = [];
      const readDirRecursive = (currentDir, prefix = "") => {
        const files = fs5.readdirSync(currentDir, { withFileTypes: true });
        for (const file2 of files) {
          const relativePath = path4.join(prefix, file2.name);
          const fullPath = path4.join(currentDir, file2.name);
          if (file2.isDirectory()) {
            readDirRecursive(fullPath, relativePath);
          } else if (file2.isFile()) {
            const suffix = path4.extname(file2.name);
            if (suffixs.length > 0) {
              const normalizedSuffixs = suffixs.map((s) => s.startsWith(".") ? s : `.${s}`);
              if (normalizedSuffixs.includes(suffix)) {
                result.push(returnType === "abs" ? fullPath : relativePath);
              }
            } else if (exclude.length > 0) {
              const normalizedExclude = exclude.map((s) => s.startsWith(".") ? s : `.${s}`);
              if (!normalizedExclude.includes(suffix)) {
                result.push(returnType === "abs" ? fullPath : relativePath);
              }
            } else {
              result.push(returnType === "abs" ? fullPath : relativePath);
            }
          }
        }
      };
      if (!fs5.existsSync(dir)) {
        throw new Error(`\u8DEF\u5F84\u4E0D\u5B58\u5728: ${dir}`);
      }
      readDirRecursive(dir);
      return result;
    };
    getAllFiles = async (dir, options = {}) => {
      const { suffixs = [], exclude = [], returnType = "rel" } = options;
      const result = [];
      const readDirRecursive = async (currentDir, prefix = "") => {
        const files = await fs5.promises.readdir(currentDir, { withFileTypes: true });
        await Promise.all(files.map(async (file2) => {
          const relativePath = path4.join(prefix, file2.name);
          const fullPath = path4.join(currentDir, file2.name);
          if (file2.isDirectory()) {
            await readDirRecursive(fullPath, relativePath);
          } else if (file2.isFile()) {
            const suffix = path4.extname(file2.name);
            if (suffixs.length > 0) {
              const normalizedSuffixs = suffixs.map((s) => s.startsWith(".") ? s : `.${s}`);
              if (normalizedSuffixs.includes(suffix)) {
                result.push(returnType === "abs" ? fullPath : relativePath);
              }
            } else if (exclude.length > 0) {
              const normalizedExclude = exclude.map((s) => s.startsWith(".") ? s : `.${s}`);
              if (!normalizedExclude.includes(suffix)) {
                result.push(returnType === "abs" ? fullPath : relativePath);
              }
            } else {
              result.push(returnType === "abs" ? fullPath : relativePath);
            }
          }
        }));
      };
      if (!fs5.existsSync(dir)) {
        throw new Error(`\u8DEF\u5F84\u4E0D\u5B58\u5728: ${dir}`);
      }
      await readDirRecursive(dir);
      return result;
    };
  }
});
var base64, buffer, stream, readFile, randomStr;
var init_data = __esm({
  "src/utils/fs/data.ts"() {
    init_file();
    base64 = async (data, options = { http: false }) => {
      if (typeof data !== "string") {
        if (Buffer.isBuffer(data)) return data.toString("base64");
        if (data instanceof Uint8Array) return Buffer.from(data).toString("base64");
        if (data instanceof Readable) return (await stream(data)).toString("base64");
        return data;
      }
      if (data.startsWith("base64://")) return data.replace("base64://", "");
      if (data.startsWith("http")) {
        if (options.http) return data;
        const response = await axios8.get(data, { responseType: "stream" });
        const buffer2 = await stream(response.data);
        return buffer2.toString("base64");
      }
      const files = data.replace(sep, "");
      if (fs5.existsSync(files)) return (await fs5.promises.readFile(files)).toString("base64");
      return Buffer.from(data, "base64").toString("base64");
    };
    buffer = async (data, options) => {
      if (typeof data !== "string") {
        if (Buffer.isBuffer(data)) return data;
        if (data instanceof Uint8Array) return Buffer.from(data);
        if (data instanceof Readable) return await stream(data);
        return data;
      }
      if (data.startsWith("base64://")) {
        return Buffer.from(data.replace("base64://", ""), "base64");
      }
      if (data.startsWith("http")) {
        if (options?.http) return data;
        const response = await axios8.get(data, { responseType: "arraybuffer" });
        return Buffer.from(response.data, "binary");
      }
      const files = data.replace(sep, "");
      if (fs5.existsSync(files)) return fs5.readFileSync(files);
      return Buffer.from(data);
    };
    stream = (stream2) => new Promise((resolve, reject) => {
      const chunks = [];
      stream2.on("data", (chunk) => chunks.push(chunk));
      stream2.on("end", () => resolve(Buffer.concat(chunks)));
      stream2.on("error", (error) => reject(error));
    });
    readFile = async (path36) => {
      try {
        const data = await fs5.promises.readFile(path36);
        return data;
      } catch (error) {
        logger.error(error);
        return null;
      }
    };
    randomStr = (length = 8) => {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join("");
    };
  }
});
var readJsonSync, writeJsonSync, readJson, writeJson, json;
var init_json = __esm({
  "src/utils/fs/json.ts"() {
    readJsonSync = (path36, isThrow = false) => {
      try {
        const data = fs5.readFileSync(path36, "utf8");
        return JSON.parse(data);
      } catch (error) {
        if (isThrow) throw error;
        return null;
      }
    };
    writeJsonSync = (path36, data, isThrow = false) => {
      try {
        fs5.writeFileSync(path36, JSON.stringify(data, null, 2));
        return true;
      } catch (error) {
        if (isThrow) throw error;
        return false;
      }
    };
    readJson = async (path36, isThrow = false) => {
      try {
        const data = await fs5.promises.readFile(path36, "utf8");
        return JSON.parse(data);
      } catch (error) {
        if (isThrow) throw error;
        return null;
      }
    };
    writeJson = async (path36, data, isThrow = false) => {
      try {
        await fs5.promises.writeFile(path36, JSON.stringify(data, null, 2));
        return true;
      } catch (error) {
        if (isThrow) throw error;
        return false;
      }
    };
    json = {
      /** 同步读取 */
      readSync: readJsonSync,
      /** 同步写入 */
      writeSync: writeJsonSync,
      /** 异步读取 */
      read: readJson,
      /** 异步写入 */
      write: writeJson
    };
  }
});
var filesByExt, splitPath, getRelPath, urlToPath, isSubPath, formatPath, isPathEqual;
var init_path = __esm({
  "src/utils/fs/path.ts"() {
    init_file();
    filesByExt = (filePath, ext, returnType = "name") => {
      if (!fs5.existsSync(filePath) || !fs5.statSync(filePath).isDirectory()) return [];
      const files = fs5.readdirSync(filePath, { withFileTypes: true });
      const list2 = [];
      if (!Array.isArray(ext)) ext = [ext];
      const allFiles = (dir, entry) => {
        if (entry.isDirectory()) {
          const subFiles = filesByExt(path4.join(dir, entry.name), ext, returnType);
          list2.push(...subFiles);
        } else if (ext.includes(path4.extname(entry.name))) {
          if (returnType === "name") {
            list2.push(entry.name);
          } else if (returnType === "rel") {
            const file2 = path4.resolve(dir, entry.name);
            list2.push(path4.relative(process.cwd(), file2));
          } else if (returnType === "abs") {
            list2.push(formatPath(path4.resolve(dir, entry.name)));
          }
        }
      };
      files.forEach((entry) => allFiles(filePath, entry));
      return list2;
    };
    splitPath = (filePath) => {
      const dirname = path4.dirname(filePath).replace(sep, "");
      const basename = path4.basename(filePath);
      return { dirname, basename };
    };
    getRelPath = (filePath) => filePath.replace(/\\+/g, "/").replace(/\.+\/+|\/+$/g, "");
    urlToPath = (url) => {
      const filePath = fileURLToPath$1(url);
      const rel = path4.relative(path4.dirname(filePath), process.cwd());
      const upLevelsCount = rel.split(path4.sep).length;
      return lodash3.repeat("../", upLevelsCount);
    };
    isSubPath = (root, target, isAbs = true) => {
      if (isAbs) {
        root = path4.resolve(root);
        target = path4.resolve(target);
      }
      const relative = path4.relative(root, target);
      return relative && !relative.startsWith("..") && !path4.isAbsolute(relative);
    };
    formatPath = (filePath) => {
      return path4.resolve(filePath).replace(/\\/g, "/");
    };
    isPathEqual = (path1, path210) => {
      if (path1 === path210) return true;
      path1 = formatPath(path1);
      path210 = formatPath(path210);
      if (path1 === path210) return true;
      if (process.platform === "win32") {
        return path1.toLowerCase() === path210.toLowerCase();
      }
      return false;
    };
  }
});

// src/plugin/system/cache.ts
var cache3;
var init_cache = __esm({
  "src/plugin/system/cache.ts"() {
    cache3 = {
      index: {},
      accept: [],
      command: [],
      task: [],
      button: [],
      handler: {},
      missing: /* @__PURE__ */ new Map(),
      watcher: /* @__PURE__ */ new Map(),
      count: {
        accept: 0,
        command: 0,
        task: 0,
        button: 0,
        handler: {
          key: 0,
          fnc: 0
        }
      },
      static: []
    };
  }
});
var pkgRoot, getPluginInfo, isPlugin;
var init_pkg2 = __esm({
  "src/utils/fs/pkg.ts"() {
    init_cache();
    init_require();
    pkgRoot = (name, rootPath) => {
      let dir;
      if (import.meta.url) {
        const require2 = createRequire(rootPath || import.meta.url);
        dir = require2.resolve(name);
      } else {
        __require.resolve(name);
        dir = __require.resolve(name);
      }
      try {
        if (existsSync$1(path4.join(dir, "package.json"))) {
          return path4.resolve(dir);
        }
        while (true) {
          dir = path4.dirname(dir);
          if (existsSync$1(path4.join(dir, "package.json"))) {
            return path4.resolve(dir);
          }
          if (dir === path4.dirname(dir)) {
            throw new Error(`[common] \u672A\u627E\u5230\u5305${name}\u7684\u6839\u76EE\u5F55`);
          }
        }
      } finally {
        delete __require.cache[__require.resolve(name)];
      }
    };
    getPluginInfo = (name) => {
      const list2 = Object.values(cache3.index);
      const plugin = list2.find((item) => item.name === name);
      if (!plugin) return null;
      const info = {
        get pkg() {
          if (!plugin.pkgPath) return null;
          return requireFileSync(plugin.pkgPath);
        }
      };
      return Object.assign(plugin, info);
    };
    isPlugin = (name) => {
      return !!getPluginInfo(name);
    };
  }
});

// src/utils/fs/static.ts
var isPublic;
var init_static = __esm({
  "src/utils/fs/static.ts"() {
    init_path();
    init_cache();
    isPublic = (filePath) => {
      try {
        for (const item of cache3.static) {
          if (isSubPath(item, filePath)) {
            return true;
          }
        }
        return false;
      } catch (error) {
        logger.error(error);
        return false;
      }
    };
  }
});
var YamlEditor, read, write, save, comment, applyComments, yaml3;
var init_yaml = __esm({
  "src/utils/fs/yaml.ts"() {
    YamlEditor = class {
      filePath;
      doc;
      document;
      constructor(file2) {
        this.filePath = file2;
        const data = YAML.parseDocument(fs5.existsSync(file2) ? fs5.readFileSync(file2, "utf8") : file2);
        this.doc = data;
        this.document = data;
      }
      /**
       * 获取指定路径的值
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       */
      get(path36) {
        try {
          if (!path36) return this.document.toJSON();
          return lodash3.get(this.document.toJSON(), path36);
        } catch (error) {
          logger.error(`[YamlEditor] \u83B7\u53D6\u6570\u636E\u65F6\u51FA\u9519\uFF1A${error}`);
          return null;
        }
      }
      /**
       * 设置指定路径的值
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param value - 要设置的值 允许的类型：`string`, `boolean`, `number`, `object`, `array`
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      set(path36, value, isSplit = true) {
        try {
          const _path = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
          this.document.setIn(_path, value);
          return true;
        } catch (error) {
          logger.error(`[YamlEditor] \u8BBE\u7F6E\u6570\u636E\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 向指定路径添加新值
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param value - 要添加的值
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      add(path36, value, isSplit = true) {
        try {
          const _path = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
          this.document.addIn(_path, value);
          logger.debug(`[YamlEditor] \u5DF2\u5728 ${path36} \u6DFB\u52A0\u65B0\u7684\u503C`);
          return true;
        } catch (error) {
          logger.error(`[YamlEditor] \u6DFB\u52A0\u6570\u636E\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 删除指定路径
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       * @returns 是否删除成功
       */
      del(path36, isSplit = true) {
        try {
          const _path = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
          this.document.deleteIn(_path);
          return true;
        } catch (error) {
          logger.error(`[YamlEditor] \u5220\u9664\u6570\u636E\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 向指定路径的数组添加新值，可以选择添加到数组的开始或结束
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param value - 要添加的值
       * @param prepend - 如果为 true，则添加到数组的开头，否则添加到末尾
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      append(path36, value, prepend = false, isSplit = true) {
        try {
          const _path = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
          let current = this.document.getIn(_path);
          if (!current) {
            current = new YAML.YAMLSeq();
            this.document.setIn(_path, current);
          } else if (!(current instanceof YAML.YAMLSeq)) {
            logger.error("[YamlEditor] \u6307\u5B9A\u7684\u8DEF\u5F84\u4E0D\u662F\u6570\u7EC4");
            return false;
          } else {
            prepend ? current.items.unshift(value) : current.add(value);
          }
          logger.debug(`[YamlEditor] \u5DF2\u5411 ${path36} \u6570\u7EC4${prepend ? "\u5F00\u5934" : "\u672B\u5C3E"}\u6DFB\u52A0\u65B0\u5143\u7D20\uFF1A${value}`);
          return true;
        } catch (error) {
          logger.error(`[YamlEditor] \u5411\u6570\u7EC4\u6DFB\u52A0\u5143\u7D20\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 向指定路径的数组删除值
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param value - 要删除的值
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      remove(path36, value, isSplit = true) {
        try {
          const _path = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
          const current = this.document.getIn(_path);
          if (!current) {
            logger.error("[YamlEditor] \u6307\u5B9A\u7684\u8DEF\u5F84\u4E0D\u5B58\u5728");
            return false;
          }
          if (!(current instanceof YAML.YAMLSeq)) {
            logger.error("[YamlEditor] \u6307\u5B9A\u7684\u8DEF\u5F84\u4E0D\u662F\u6570\u7EC4");
            return false;
          }
          const index6 = current.items.findIndex((item) => lodash3.isEqual(item.toJSON(), value));
          if (index6 < 0) {
            logger.error("[YamlEditor] \u672A\u627E\u5230\u8981\u5220\u9664\u7684\u503C");
            return false;
          }
          current.items.splice(index6, 1);
          logger.debug(`[YamlEditor] \u5DF2\u4ECE ${path36} \u6570\u7EC4\u5220\u9664\u5143\u7D20\uFF1A${value}`);
          return true;
        } catch (error) {
          logger.error(`[YamlEditor] \u4ECE\u6570\u7EC4\u5220\u9664\u5143\u7D20\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 检查指定路径的键是否存在
       * @param path - 路径，用点号分隔
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      has(path36, isSplit = true) {
        try {
          const _path = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
          return this.document.hasIn(_path);
        } catch (error) {
          logger.error(`[YamlEditor] \u68C0\u67E5\u8DEF\u5F84\u662F\u5426\u5B58\u5728\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 查询指定路径中是否包含指定的值
       * @param path - 路径，用点号分隔
       * @param value - 要查询的值
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      hasval(path36, value, isSplit = true) {
        try {
          const _path = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
          const current = this.document.getIn(_path);
          if (!current) return false;
          if (current instanceof YAML.YAMLSeq) {
            return current.items.some((item) => lodash3.isEqual(item.toJSON(), value));
          } else if (current instanceof YAML.YAMLMap) {
            return Array.from(current.values()).some((v) => lodash3.isEqual(v.toJSON(), value));
          } else {
            return lodash3.isEqual(current, value);
          }
        } catch (error) {
          logger.error(`[YamlEditor] \u68C0\u67E5\u8DEF\u5F84 ${path36} \u662F\u5426\u5305\u542B\u503C\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 查询指定路径中是否包含指定的值
       * @param path - 路径，用点号分隔
       * @param value - 要查询的值
       * @deprecated 请使用 `hasval` 代替
       */
      hasVal(path36, value) {
        return this.hasval(path36, value);
      }
      /**
       * 向根节点新增元素，如果根节点不是数组，则将其转换为数组再新增元素
       * @param value - 要新增的元素
       */
      pusharr(value) {
        try {
          if (!(this.document.contents instanceof YAML.YAMLSeq)) {
            this.document.contents = new YAML.YAMLSeq();
            logger.debug("[YamlEditor] \u6839\u8282\u70B9\u5DF2\u8F6C\u6362\u4E3A\u6570\u7EC4");
          }
          this.document.contents.add(value);
          logger.debug("[YamlEditor] \u5DF2\u5411\u6839\u8282\u70B9\u6570\u7EC4\u65B0\u589E\u5143\u7D20\uFF1A", value);
          return true;
        } catch (error) {
          logger.error(`[YamlEditor] \u5411\u6839\u8282\u70B9\u6570\u7EC4\u65B0\u589E\u5143\u7D20\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 根据索引从根节点数组删除元素
       * @param index - 要删除元素的索引
       */
      delarr(index6) {
        try {
          if (!(this.document.contents instanceof YAML.YAMLSeq)) {
            throw new Error("[YamlEditor] \u6839\u8282\u70B9\u4E0D\u662F\u6570\u7EC4");
          }
          if (index6 < 0 || index6 >= this.document.contents.items.length) {
            throw new Error("[YamlEditor] \u7D22\u5F15\u8D85\u51FA\u8303\u56F4");
          }
          this.document.contents.items.splice(index6, 1);
          logger.debug("[YamlEditor] \u5DF2\u6839\u636E\u7D22\u5F15\u4ECE\u6839\u8282\u70B9\u6570\u7EC4\u5220\u9664\u5143\u7D20\uFF0C\u7D22\u5F15\uFF1A", index6);
          return true;
        } catch (error) {
          logger.error(`[YamlEditor] \u6839\u636E\u7D22\u5F15\u5220\u9664\u6839\u8282\u70B9\u6570\u7EC4\u5143\u7D20\u65F6\u51FA\u9519\uFF1A${error}`);
          return false;
        }
      }
      /**
       * 获取指定路径的pair对象
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      getpair(path36, isSplit = true) {
        if (!path36) throw new Error("path is required");
        const keys = typeof path36 === "string" ? isSplit ? path36.split(".") : [path36] : path36;
        let pair = this.document.contents;
        keys.forEach((key) => {
          if (isMap(pair)) {
            pair = pair.items.find((item) => item.key.value === key);
          } else if (isSeq(pair)) {
            pair = pair.items.find((item) => item.value === key);
          } else if (isPair(pair)) {
            pair = pair.value.items.find((item) => item.key.value === key);
          }
        });
        return pair;
      }
      /**
       * 设置指定键的注释
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param comment - 要设置的注释
       * @param prepend - 如果为 true，则添加注释到开头，否则添加到同一行的末尾
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      comment(path36, comment2, prepend = true, isSplit = true) {
        if (!path36) throw new Error("[YamlEditor] path \u4E0D\u80FD\u4E3A\u7A7A");
        const pair = this.getpair(path36, isSplit);
        if (!pair) throw new Error(`[YamlEditor] \u672A\u627E\u5230\u8282\u70B9 ${path36}`);
        comment2 = ` ${comment2}`;
        if (prepend) {
          pair.key.commentBefore = comment2;
        } else {
          pair.key.comment = comment2;
        }
      }
      /**
       * 删除指定键的注释
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param type - 要删除的注释类型，`before` 为注释前，`after` 为注释后，`all` 为全部
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      uncomment(path36, type = "all", isSplit = true) {
        if (!path36) throw new Error("[YamlEditor] path \u4E0D\u80FD\u4E3A\u7A7A");
        const pair = this.getpair(path36, isSplit);
        if (!pair) throw new Error(`[YamlEditor] \u672A\u627E\u5230\u8282\u70B9 ${path36}`);
        if (type === "all") {
          delete pair.key.comment;
          delete pair.key.commentBefore;
        } else if (type === "before") {
          delete pair.key.commentBefore;
        } else if (type === "after") {
          delete pair.key.comment;
        }
      }
      /**
       * 检查注释是否存在
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param type - 要检查的注释类型，`before` 为注释前，`after` 为注释后
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      hascomment(path36, type, isSplit = true) {
        if (!path36) throw new Error("[YamlEditor] path \u4E0D\u80FD\u4E3A\u7A7A");
        const pair = this.getpair(path36, isSplit);
        if (!pair) throw new Error(`[YamlEditor] \u672A\u627E\u5230\u8282\u70B9 ${path36}`);
        if (type === "before") {
          return !!pair.key.commentBefore;
        } else if (type === "after") {
          return !!pair.key.comment;
        }
        return false;
      }
      /**
       * 获取指定键的注释
       * @param path - 路径，多个路径使用`.`连接，例如：`a.b.c`
       * @param isSplit - 是否使用分割路径路径，默认为 `true`
       */
      getcomment(path36, isSplit = true) {
        if (!path36) throw new Error("[YamlEditor] path \u4E0D\u80FD\u4E3A\u7A7A");
        const pair = this.getpair(path36, isSplit);
        if (!pair) throw new Error(`[YamlEditor] \u672A\u627E\u5230\u8282\u70B9 ${path36}`);
        return pair.key.commentBefore || pair.key.comment;
      }
      /**
       * 保存文件
       * 保存失败会抛出异常
       */
      save() {
        fs5.writeFileSync(this.filePath, this.document.toString());
        logger.debug("[YamlEditor] \u6587\u4EF6\u5DF2\u4FDD\u5B58");
      }
    };
    read = (path36) => {
      const data = YAML.parse(fs5.readFileSync(path36, "utf-8"));
      read.save = (options) => {
        try {
          save(path36, data, typeof options === "string" ? JSON.parse(options) : options);
          return true;
        } catch (error) {
          logger.error("[YamlEditor] \u4FDD\u5B58\u6587\u4EF6\u65F6\u51FA\u9519");
          logger.error(error);
          return false;
        }
      };
      return data;
    };
    write = (path36, value) => {
      try {
        fs5.writeFileSync(path36, YAML.stringify(value));
        return true;
      } catch {
        return false;
      }
    };
    save = (path36, value, options) => {
      if (!options) {
        fs5.writeFileSync(path36, YAML.stringify(value));
        return;
      }
      const editor = new YamlEditor(YAML.stringify(value));
      const comment2 = typeof options === "string" ? JSON.parse(fs5.readFileSync(options, "utf8")) : options;
      applyComments(editor, comment2);
      fs5.writeFileSync(path36, editor.document.toString());
    };
    comment = (filePath, commentConfig) => {
      const editor = new YamlEditor(filePath);
      const comment2 = typeof commentConfig === "string" ? JSON.parse(fs5.readFileSync(commentConfig, "utf8")) : commentConfig;
      applyComments(editor, comment2);
      editor.save();
    };
    applyComments = (editor, comments) => {
      for (const key of Object.keys(comments)) {
        try {
          const value = comments[key];
          const comment2 = typeof value === "string" ? value : value.comment;
          const prepend = typeof value === "string" ? true : typeof value === "object" && value.type === "top";
          editor.comment(key, comment2, prepend);
        } catch (error) {
          logger.error(`[YamlEditor] \u6DFB\u52A0\u6CE8\u91CA\u65F6\u51FA\u9519\uFF0C\u5DF2\u8DF3\u8FC7\uFF1A${error.stack || error.message || error}`);
        }
      }
    };
    yaml3 = Object.assign(YAML, {
      /** 读取并解析 YAML 文件 */
      read,
      /** 保存数据并写入注释 */
      save,
      /** 为指定文件写入注释 */
      comment,
      /** 批量添加注释 */
      applyComments
    });
  }
});
var fnStore, lockMethod, unlockMethod, lockProp, lock;
var init_lock = __esm({
  "src/utils/system/lock.ts"() {
    fnStore = /* @__PURE__ */ new Map();
    lockMethod = (obj, key, msg = `\u65B9\u6CD5 ${String(key)} \u5DF2\u88AB\u9501\u5B9A`) => {
      if (typeof obj[key] !== "function") {
        throw new Error(`\u5C5E\u6027 ${String(key)} \u4E0D\u662F\u4E00\u4E2A\u51FD\u6570`);
      }
      const storeKey = randomUUID();
      fnStore.set(storeKey, { key: String(key), fnc: obj[key] });
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        value: () => {
          throw Error(msg);
        }
      });
      return () => unlockMethod(obj, storeKey);
    };
    unlockMethod = (obj, storeKey) => {
      const data = fnStore.get(storeKey);
      if (!data) {
        return { status: false, msg: `\u672A\u627E\u5230\u88AB\u9501\u5B9A\u7684\u65B9\u6CD5 ${String(storeKey)}` };
      }
      const { key, fnc: fnc2 } = data;
      if (typeof fnc2 !== "function") {
        return { status: false, msg: `\u5C5E\u6027 ${String(key)} \u4E0D\u662F\u4E00\u4E2A\u51FD\u6570` };
      }
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        value: fnc2.bind(obj)
      });
      fnStore.delete(storeKey);
      return { status: true, msg: `\u89E3\u9501\u65B9\u6CD5 ${String(key)} \u6210\u529F` };
    };
    lockProp = (obj, key) => {
      const descriptor = Object.getOwnPropertyDescriptor(obj, key);
      if (descriptor) {
        Object.defineProperty(obj, key, {
          /** 属性是否可枚举 */
          enumerable: true,
          /** 属性描述符是否可配置 */
          configurable: false,
          /** 属性是否可写  */
          writable: false,
          /** 保持原有的值 */
          value: descriptor.value
        });
      } else {
        throw new Error(`Property ${String(key)} does not exist on the object`);
      }
    };
    lock = {
      /** 锁定属性 */
      prop: lockProp,
      /** 锁定方法 */
      method: lockMethod
    };
  }
});

// src/utils/fs/changelog.ts
var changelog_exports = {};
__export(changelog_exports, {
  log: () => log,
  logs: () => logs,
  parseChangelog: () => parseChangelog,
  range: () => range
});
var log, logs, range, parseChangelog;
var init_changelog = __esm({
  "src/utils/fs/changelog.ts"() {
    log = (version2, data) => {
      const regex = new RegExp(`## \\[${version2}\\](.|\\n)*?(?=## \\[|$)`, "g");
      const match = data.match(regex);
      return match ? match[0] : null;
    };
    logs = (version2, data, length = 1, reverse = false) => {
      if (typeof length !== "number") {
        throw new TypeError("\u63D0\u53D6\u957F\u5EA6\u5FC5\u987B\u4E3A\u6570\u5B57");
      }
      const list2 = parseChangelog(data);
      const keys = Object.keys(list2);
      const index6 = keys.indexOf(version2);
      const start3 = reverse ? index6 - length : index6;
      const end = reverse ? index6 : index6 + length;
      const versions = keys.slice(start3, end).map((key) => list2[key] ? list2[key] : "");
      return versions.join("");
    };
    range = (data, startVersion, endVersion) => {
      const list2 = parseChangelog(data);
      const keys = Object.keys(list2);
      const start3 = keys.indexOf(startVersion);
      const end = keys.indexOf(endVersion);
      if (start3 > end) {
        const versions2 = keys.slice(end, start3).map((key) => list2[key] ? list2[key] : "");
        return versions2.join("");
      }
      const versions = keys.slice(start3, end).map((key) => list2[key] ? list2[key] : "");
      return versions.join("");
    };
    parseChangelog = (data) => {
      const regex = /## \[(.*?)\]([\s\S]*?)(?=## \[|$)/g;
      const changelog = {};
      for (const match of data.matchAll(regex)) {
        const version2 = match[1];
        const content = match[0];
        changelog[version2] = content;
      }
      return changelog;
    };
  }
});

// src/utils/fs/key.ts
var key_exports = {};
__export(key_exports, {
  EVENT_COUNT: () => EVENT_COUNT,
  FILE_CHANGE: () => FILE_CHANGE,
  RECV_MSG: () => RECV_MSG,
  SEND_MSG: () => SEND_MSG,
  WS_CLOSE: () => WS_CLOSE,
  WS_CLOSE_ONEBOT: () => WS_CLOSE_ONEBOT,
  WS_CLOSE_PUPPETEER: () => WS_CLOSE_PUPPETEER,
  WS_CLOSE_SANDBOX: () => WS_CLOSE_SANDBOX,
  WS_CONNECTION: () => WS_CONNECTION,
  WS_CONNECTION_ONEBOT: () => WS_CONNECTION_ONEBOT,
  WS_CONNECTION_PUPPETEER: () => WS_CONNECTION_PUPPETEER,
  WS_CONNECTION_SANDBOX: () => WS_CONNECTION_SANDBOX,
  WS_CONNECTION_TERMINAL: () => WS_CONNECTION_TERMINAL,
  WS_SNAPKA: () => WS_SNAPKA
});
var RECV_MSG, SEND_MSG, EVENT_COUNT, FILE_CHANGE, WS_CONNECTION, WS_CONNECTION_ONEBOT, WS_CONNECTION_PUPPETEER, WS_CONNECTION_SANDBOX, WS_CONNECTION_TERMINAL, WS_CLOSE, WS_CLOSE_ONEBOT, WS_CLOSE_PUPPETEER, WS_CLOSE_SANDBOX, WS_SNAPKA;
var init_key2 = __esm({
  "src/utils/fs/key.ts"() {
    RECV_MSG = "karin:count:recv";
    SEND_MSG = "karin:count:send";
    EVENT_COUNT = "karin:count:fnc";
    FILE_CHANGE = "karin:file:change";
    WS_CONNECTION = "ws:connection";
    WS_CONNECTION_ONEBOT = "ws:connection:onebot";
    WS_CONNECTION_PUPPETEER = "ws:connection:puppeteer";
    WS_CONNECTION_SANDBOX = "ws:connection:sandbox";
    WS_CONNECTION_TERMINAL = "ws:connection:terminal";
    WS_CLOSE = "ws:close";
    WS_CLOSE_ONEBOT = "ws:close:onebot";
    WS_CLOSE_PUPPETEER = "ws:close:puppeteer";
    WS_CLOSE_SANDBOX = "ws:close:sandbox";
    WS_SNAPKA = "ws:connection:snapka";
  }
});

// src/utils/fs/fs.ts
var fs_exports = {};
__export(fs_exports, {
  Watch: () => Watch,
  Watcher: () => Watcher,
  YamlEditor: () => YamlEditor,
  absPath: () => absPath,
  applyComments: () => applyComments,
  base64: () => base64,
  buffer: () => buffer,
  clearRequire: () => clearRequire,
  clearRequireFile: () => clearRequireFile,
  comment: () => comment,
  copyConfig: () => copyConfig,
  copyConfigSync: () => copyConfigSync,
  copyFiles: () => copyFiles,
  copyFilesSync: () => copyFilesSync,
  createPluginDir: () => createPluginDir,
  downFile: () => downFile,
  downloadFile: () => downloadFile,
  existToMkdir: () => existToMkdir,
  existToMkdirSync: () => existToMkdirSync,
  exists: () => exists,
  existsSync: () => existsSync,
  filesByExt: () => filesByExt,
  formatPath: () => formatPath,
  getAllFiles: () => getAllFiles,
  getAllFilesSync: () => getAllFilesSync,
  getFiles: () => getFiles,
  getPluginInfo: () => getPluginInfo,
  getRelPath: () => getRelPath,
  isDir: () => isDir,
  isDirSync: () => isDirSync,
  isFile: () => isFile,
  isFileSync: () => isFileSync,
  isPathEqual: () => isPathEqual,
  isPlugin: () => isPlugin,
  isPublic: () => isPublic,
  isSubPath: () => isSubPath,
  json: () => json,
  key: () => key_exports,
  lock: () => lock,
  lockMethod: () => lockMethod,
  lockProp: () => lockProp,
  log: () => log,
  logs: () => logs,
  mkdir: () => mkdir,
  mkdirSync: () => mkdirSync,
  parseChangelog: () => parseChangelog,
  pkgRoot: () => pkgRoot,
  randomStr: () => randomStr,
  range: () => range,
  read: () => read,
  readFile: () => readFile,
  readJson: () => readJson,
  readJsonSync: () => readJsonSync,
  requireFile: () => requireFile,
  requireFileSync: () => requireFileSync,
  rmSync: () => rmSync,
  save: () => save,
  sep: () => sep,
  splitPath: () => splitPath,
  stream: () => stream,
  urlToPath: () => urlToPath,
  watch: () => watch,
  watchAndMerge: () => watchAndMerge,
  write: () => write,
  writeJson: () => writeJson,
  writeJsonSync: () => writeJsonSync,
  yaml: () => yaml3
});
var init_fs = __esm({
  "src/utils/fs/fs.ts"() {
    init_fsPromises();
    init_fsSync();
    init_data();
    init_file();
    init_json();
    init_path();
    init_pkg2();
    init_require();
    init_static();
    init_yaml();
    init_watch();
    init_lock();
    init_changelog();
    init_key2();
  }
});

// src/utils/fs/index.ts
var fs_exports2 = {};
__export(fs_exports2, {
  EVENT_COUNT: () => EVENT_COUNT,
  FILE_CHANGE: () => FILE_CHANGE,
  RECV_MSG: () => RECV_MSG,
  SEND_MSG: () => SEND_MSG,
  WS_CLOSE: () => WS_CLOSE,
  WS_CLOSE_ONEBOT: () => WS_CLOSE_ONEBOT,
  WS_CLOSE_PUPPETEER: () => WS_CLOSE_PUPPETEER,
  WS_CLOSE_SANDBOX: () => WS_CLOSE_SANDBOX,
  WS_CONNECTION: () => WS_CONNECTION,
  WS_CONNECTION_ONEBOT: () => WS_CONNECTION_ONEBOT,
  WS_CONNECTION_PUPPETEER: () => WS_CONNECTION_PUPPETEER,
  WS_CONNECTION_SANDBOX: () => WS_CONNECTION_SANDBOX,
  WS_CONNECTION_TERMINAL: () => WS_CONNECTION_TERMINAL,
  WS_SNAPKA: () => WS_SNAPKA,
  Watch: () => Watch,
  Watcher: () => Watcher,
  YamlEditor: () => YamlEditor,
  absPath: () => absPath,
  applyComments: () => applyComments,
  base64: () => base64,
  buffer: () => buffer,
  clearRequire: () => clearRequire,
  clearRequireFile: () => clearRequireFile,
  comment: () => comment,
  copyConfig: () => copyConfig,
  copyConfigSync: () => copyConfigSync,
  copyFiles: () => copyFiles,
  copyFilesSync: () => copyFilesSync,
  createPluginDir: () => createPluginDir,
  downFile: () => downFile,
  downloadFile: () => downloadFile,
  existToMkdir: () => existToMkdir,
  existToMkdirSync: () => existToMkdirSync,
  exists: () => exists,
  existsSync: () => existsSync,
  file: () => fs_exports,
  filesByExt: () => filesByExt,
  formatPath: () => formatPath,
  getAllFiles: () => getAllFiles,
  getAllFilesSync: () => getAllFilesSync,
  getFiles: () => getFiles,
  getPluginInfo: () => getPluginInfo,
  getRelPath: () => getRelPath,
  isDir: () => isDir,
  isDirSync: () => isDirSync,
  isFile: () => isFile,
  isFileSync: () => isFileSync,
  isPathEqual: () => isPathEqual,
  isPlugin: () => isPlugin,
  isPublic: () => isPublic,
  isSubPath: () => isSubPath,
  json: () => json,
  key: () => key_exports,
  lock: () => lock,
  lockMethod: () => lockMethod,
  lockProp: () => lockProp,
  log: () => log,
  logs: () => logs,
  mkdir: () => mkdir,
  mkdirSync: () => mkdirSync,
  parseChangelog: () => parseChangelog,
  pkgRoot: () => pkgRoot,
  randomStr: () => randomStr,
  range: () => range,
  read: () => read,
  readFile: () => readFile,
  readJson: () => readJson,
  readJsonSync: () => readJsonSync,
  requireFile: () => requireFile,
  requireFileSync: () => requireFileSync,
  rmSync: () => rmSync,
  save: () => save,
  sep: () => sep,
  splitPath: () => splitPath,
  stream: () => stream,
  urlToPath: () => urlToPath,
  watch: () => watch,
  watchAndMerge: () => watchAndMerge,
  write: () => write,
  writeJson: () => writeJson,
  writeJsonSync: () => writeJsonSync,
  yaml: () => yaml3
});
var init_fs2 = __esm({
  "src/utils/fs/index.ts"() {
    init_fs();
    init_require();
    init_changelog();
    init_key2();
    init_fs();
  }
});
var diffArray, diffSimpleArray, clamp, random, formatNumber, percentage, formatUnit, isEven, average, round, isNumber, isNumberInArray;
var init_number = __esm({
  "src/utils/common/number.ts"() {
    diffArray = (old, data) => {
      const removed = lodash3.differenceWith(old, data, lodash3.isEqual);
      const added = lodash3.differenceWith(data, old, lodash3.isEqual);
      const common = lodash3.intersectionWith(old, data, lodash3.isEqual);
      return { removed, added, common };
    };
    diffSimpleArray = (old, data) => {
      const removed = lodash3.difference(old, data);
      const added = lodash3.difference(data, old);
      const common = lodash3.intersection(old, data);
      return { removed, added, common };
    };
    clamp = (value, min, max) => {
      return Math.min(Math.max(value, min), max);
    };
    random = (min, max) => {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    formatNumber = (num, digits = 0) => {
      return num.toLocaleString("en-US", {
        minimumFractionDigits: digits,
        maximumFractionDigits: digits
      });
    };
    percentage = (value, total, digits = 2) => {
      if (total === 0) return 0;
      return Number((value / total * 100).toFixed(digits));
    };
    formatUnit = (num, digits = 1) => {
      const units = ["", "K", "M", "B"];
      const order = Math.floor(Math.log10(Math.abs(num)) / 3);
      if (order === 0) return num.toString();
      const unit = units[order] || "";
      const value = (num / Math.pow(1e3, order)).toFixed(digits);
      return `${value}${unit}`;
    };
    isEven = (num) => {
      return num % 2 === 0;
    };
    average = (numbers) => {
      if (numbers.length === 0) return 0;
      return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    };
    round = (num, decimals = 0) => {
      return Number(Math.round(Number(num + "e" + decimals)) + "e-" + decimals);
    };
    isNumber = (num, defaultValue = 0) => {
      if (typeof num === "number") return num;
      return defaultValue;
    };
    isNumberInArray = (arr, defaultValue = 0) => {
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (typeof item === "number") return item;
      }
      return defaultValue;
    };
  }
});
var TypedListeners, listeners;
var init_listeners = __esm({
  "src/core/internal/listeners.ts"() {
    TypedListeners = class extends EventEmitter {
      /**
       * 注册事件监听器
       * @param event 事件名称
       * @param listener 监听器函数
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * 注册一次性事件监听器
       * @param event 事件名称
       * @param listener 监听器函数
       */
      once(event, listener) {
        return super.once(event, listener);
      }
      /**
       * 移除事件监听器
       * @param event 事件名称
       * @param listener 监听器函数
       */
      off(event, listener) {
        return super.off(event, listener);
      }
      /**
       * 触发事件
       * @param event 事件名称
       * @param args 事件参数
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * 获取事件监听器列表
       * @param event 事件名称
       */
      listeners(event) {
        return super.listeners(event);
      }
      /**
       * 移除所有事件监听器
       * @param event 事件名称
       * @returns this
       */
      removeAllListeners(event) {
        super.removeAllListeners(event);
        return this;
      }
      /**
       * 设置最大监听器数量
       * @param n 最大监听器数量
       * @returns this
       */
      setMaxListeners(n) {
        super.setMaxListeners(n);
        return this;
      }
      /**
       * 获取最大监听器数量
       * @returns 最大监听器数量
       */
      getMaxListeners() {
        return super.getMaxListeners();
      }
      /**
       * 添加事件监听器
       * @param event 事件名称
       * @param listener 监听器函数
       */
      addListener(event, listener) {
        return super.addListener(event, listener);
      }
      /**
       * 获取事件监听器数量
       * @param event 事件名称
       * @returns 监听器数量
       */
      listenerCount(event) {
        return super.listenerCount(event);
      }
      /**
       * 返回已注册的事件名称数组
       * @param event 事件名称
       * @returns 监听器数量
       */
      eventNames() {
        return super.eventNames();
      }
      /**
       * 返回指定事件的原始监听器数组（包括一次性监听器）
       * @param event 事件名称
       * @returns 监听器数量
       */
      rawListeners(event) {
        return super.rawListeners(event);
      }
      /**
       * 为指定事件添加监听器，但将其添加到监听器数组的开头
       * @param event 事件名称
       * @returns 监听器数量
       */
      prependListener(event, listener) {
        return super.prependListener(event, listener);
      }
      /**
       *  为指定事件添加一次性监听器，并将其添加到监听器数组的开头
       * @param event 事件名称
       * @returns 监听器数量
       */
      prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
      }
      /**
       * 移除事件监听器
       * @param event 事件名称
       * @param listener 监听器函数
       */
      removeListener(event, listener) {
        return super.removeListener(event, listener);
      }
    };
    listeners = new TypedListeners();
  }
});

// src/adapter/onebot/core/cache.ts
var cacheMap;
var init_cache2 = __esm({
  "src/adapter/onebot/core/cache.ts"() {
    cacheMap = {
      wsServer: /* @__PURE__ */ new Map(),
      wsClient: /* @__PURE__ */ new Map(),
      http: /* @__PURE__ */ new Map()
    };
  }
});

// src/adapter/base/index.ts
var AdapterBase;
var init_base = __esm({
  "src/adapter/base/index.ts"() {
    AdapterBase = class {
      account;
      adapter;
      super;
      raw;
      constructor() {
        this.raw = {};
        this.super = {};
        this.account = { uin: "", uid: "", selfId: "", subId: {}, name: "", avatar: "" };
        this.adapter = {
          index: -1,
          name: "",
          version: "",
          platform: "qq",
          standard: "other",
          protocol: "console",
          communication: "other",
          address: "",
          secret: null,
          connectTime: Date.now()
        };
      }
      get #errMsg() {
        return `[adapter][${this.adapter.protocol}] \u6B64\u63A5\u53E3\u672A\u5B9E\u73B0`;
      }
      get selfId() {
        return this.account.selfId;
      }
      get selfName() {
        return this.account.name;
      }
      selfSubId(key) {
        return this.account.subId[key];
      }
      /**
       * 打印当前Bot的专属日志
       * @param level 日志等级
       * @param args 日志内容
       */
      logger(level, ...args) {
        logger.bot(level, this.account.selfId, ...args);
      }
      /**
       * 发送消息
       * @param _contact 目标信息
       * @param _elements 消息元素
       * @param _retryCount 重试次数 默认为0
       */
      sendMsg(_contact, _elements, _retryCount) {
        throw new Error(this.#errMsg);
      }
      /**
       * 发送长消息
       * @param _contact 目标信息
       * @param _resId 资源ID
       */
      sendLongMsg(_contact, _resId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 发送合并转发消息
       * @param _contact 目标信息
       * @param _elements 消息元素
       * @param _options 首层小卡片外显参数
       */
      sendForwardMsg(_contact, _elements, _options) {
        throw new Error(this.#errMsg);
      }
      /**
       * 撤回消息
       * @param _contact 目标信息
       * @param _messageId 消息ID
       */
      recallMsg(_contact, _messageId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取头像url
       * @param _userId 用户ID
       * @param _size 头像大小，默认需要为`0`，请开发者注意
       * @returns 头像的url地址
       */
      getAvatarUrl(_userId, _size) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群头像url
       * @param _groupId 群号
       * @param _size 头像大小，默认`0`
       * @param _history 历史头像记录，默认`0`，若要获取历史群头像则填写1,2,3...
       * @returns 头像的url地址
       */
      getGroupAvatarUrl(_groupId, _size, _history) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取消息
       * @param _contact 目标信息
       * @param _messageId 消息ID
       * @returns MessageResponse对象
       */
      getMsg(_contact, _messageId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取msgId获取历史消息
       * @param _contact 目标信息
       * @param _startMsgId 起始消息ID
       * @param _count 获取消息数量 默认为1
       * @returns 包含历史消息的数组
       */
      getHistoryMsg(_contact, _startMsgId, _count) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取合并转发消息
       * @param _resId 资源ID
       * @returns 包含MessageResponse对象的数组
       */
      getForwardMsg(_resId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取精华消息
       * @param _groupId 群ID
       * @param _page 页码
       * @param _pageSize 每页数量
       * @returns EssenceMessageBody对象
       */
      getGroupHighlights(_groupId, _page, _pageSize) {
        throw new Error(this.#errMsg);
      }
      /**
       * 构造一个资源ID 即上传合并转发消息后不进行发送
       * @param _contact 目标信息
       * @param _elements 转发消息元素
       * @description 此接口并不是所有协议端都支持的，因此在使用时请注意
       */
      createResId(_contact, _elements) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置、取消群精华消息
       * @param _groupId 群ID
       * @param _messageId 群消息ID
       * @param _create true为添加精华消息，false为删除精华消息 默认为true
       */
      setGroupHighlights(_groupId, _messageId, _create) {
        throw new Error(this.#errMsg);
      }
      /**
       * 发送好友赞
       * @param _targetId 目标ID
       * @param _count 赞的次数
       */
      sendLike(_targetId, _count) {
        throw new Error(this.#errMsg);
      }
      /**
       * 群踢人
       * @param _groupId 群ID
       * @param _targetId 被踢出目标的ID 任选其一
       * @param _rejectAddRequest 是否拒绝再次申请，默认为false
       * @param _kickReason 踢出原因，可选
       */
      groupKickMember(_groupId, _targetId, _rejectAddRequest, _kickReason) {
        throw new Error(this.#errMsg);
      }
      /**
       * 禁言群成员
       * @param _groupId 群ID
       * @param _targetId 被禁言目标的ID 任选其一
       * @param _duration 禁言时长 单位:秒
       */
      setGroupMute(_groupId, _targetId, _duration) {
        throw new Error(this.#errMsg);
      }
      /**
       * 群全员禁言
       * @param _groupId 群ID
       * @param _isBan 是否开启全员禁言
       */
      setGroupAllMute(_groupId, _isBan) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置群管理员
       * @param _groupId 群ID
       * @param _targetId 目标用户的ID
       * @param _isAdmin 是否设置为管理员
       */
      setGroupAdmin(_groupId, _targetId, _isAdmin) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置群名片
       * @param _groupId 群ID
       * @param _targetId 目标用户的ID
       * @param _card 新的群名片
       */
      setGroupMemberCard(_groupId, _targetId, _card) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置群名
       * @param _groupId 群ID
       * @param _groupName 新的群名
       */
      setGroupName(_groupId, _groupName) {
        throw new Error(this.#errMsg);
      }
      /**
       * 退出群组
       * @param _groupId 群ID
       * @param _isDismiss 如果Bot是群主，是否解散群
       */
      setGroupQuit(_groupId, _isDismiss) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置群专属头衔 仅群主可用
       * @param _groupId 群ID
       * @param _targetId 目标用户的ID
       * @param _title 新的专属头衔
       */
      setGroupMemberTitle(_groupId, _targetId, _title) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取陌生人信息 此接口数据无法保证完全正确并且无法保证数据的完整性
       * @param _targetId 用户ID 任选其一
       * @returns 陌生人信息数组
       */
      getStrangerInfo(_targetId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取好友列表
       * @param _refresh 是否刷新好友列表
       * @returns 好友列表数组
       */
      getFriendList(_refresh) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群信息
       * @param _groupId 群ID
       * @param _noCache 是否刷新缓存
       * @returns 群信息
       */
      getGroupInfo(_groupId, _noCache) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群列表
       * @param _refresh 是否刷新好友列表
       * @returns 群列表数组
       */
      getGroupList(_refresh) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群成员信息
       * 此接口在非QQ平台上很难获取到标准信息，因此返回的数据可能会有所不同
       * @param _groupId 群ID
       * @param _targetId 目标用户的ID
       * @param _refresh 是否刷新缓存
       * @returns 群成员信息
       */
      getGroupMemberInfo(_groupId, _targetId, _refresh) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群成员列表
       * @param _groupId 群ID
       * @param _refresh 是否刷新缓存
       * @returns 群成员列表数组
       */
      getGroupMemberList(_groupId, _refresh) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群荣誉信息
       * @param _groupId 群ID
       * @param refresh 是否刷新缓存
       * @returns 群荣誉信息数组
       */
      getGroupHonor(_groupId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置好友请求结果
       * @param _requestId 请求事件ID
       * @param _isApprove 是否同意
       * @param _remark 好友备注 同意时有效
       */
      setFriendApplyResult(_requestId, _isApprove, _remark) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置申请加入群请求结果
       * @param _requestId 请求事件ID
       * @param _isApprove 是否同意
       * @param _denyReason 拒绝理由 拒绝时有效
       */
      setGroupApplyResult(_requestId, _isApprove, _denyReason) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置邀请加入群请求结果
       * @param _requestId 请求事件ID
       * @param _isApprove 是否同意
       */
      setInvitedJoinGroupResult(_requestId, _isApprove) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置消息表情回应
       * @param _contact 目标信息
       * @param _messageId 消息ID
       * @param _faceId 表情ID
       */
      setMsgReaction(_contact, _messageId, _faceId, _isSet) {
        throw new Error(this.#errMsg);
      }
      /**
       * 上传群文件、私聊文件
       * @param _contact 目标信息
       * @param _file 本地文件绝对路径
       * @param _name 文件名称 必须提供
       * @param _folder 父目录ID 不提供则上传到根目录 仅在群聊时有效
       */
      uploadFile(_contact, _file, _name, _folder) {
        throw new Error(this.#errMsg);
      }
      /**
       * 让协议端下载文件到协议端本地
       * @param _options 下载文件的选项
       * @returns 下载文件的绝对路径和文件MD5
       */
      downloadFile(_options) {
        throw new Error(this.#errMsg);
      }
      /**
       * 创建群文件夹
       * @param _groupId 群号
       * @param _name 文件夹名
       * @returns 返回文件夹id和已使用空间
       */
      createGroupFolder(_groupId, _name) {
        throw new Error(this.#errMsg);
      }
      /**
       * 重命名群文件的文件夹
       * @param _groupId 群号
       * @param _folderId 文件夹id
       * @param _name 文件夹名
       * @returns 无返回值
       */
      renameGroupFolder(_groupId, _folderId, _name) {
        throw new Error(this.#errMsg);
      }
      /**
       * 删除群文件的文件夹
       * @param _groupId 群号
       * @param _folderId 文件夹id
       * @returns 无返回值
       */
      delGroupFolder(_groupId, _folderId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 上传群文件
       * @description 此接口仅可以在Bot和协议端在同一台设备上时使用
       * @param _groupId 群号
       * @param _file 文件绝对路径
       * @param _name 文件名
       * @returns 无返回值
       */
      uploadGroupFile(_groupId, _file, _name) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取文件url
       * @param _contact 目标信息
       * @param _fileId 文件id
       * @returns 文件url
       */
      getFileUrl(_contact, _fileId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 删除群文件
       * @param _groupId 群号
       * @param _fileId 文件id
       * @param _busId 文件类型ID
       * @returns 无返回值
       */
      delGroupFile(_groupId, _fileId, _busId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群文件系统信息
       * @param _groupId 群号
       * @returns 返回文件数量、文件数量上限、已使用空间和空间上限
       */
      getGroupFileSystemInfo(_groupId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群文件夹下文件列表
       * @param _groupId 群号
       * @param _folderId 文件夹id，空则为根目录
       * @returns 返回文件和文件夹的列表
       */
      getGroupFileList(_groupId, _folderId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置群备注
       * @param _groupId 群号
       * @param _remark 新的备注
       */
      setGroupRemark(_groupId, _remark) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取陌生群信息
       * @param _groupId 群号
       */
      getNotJoinedGroupInfo(_groupId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取艾特全体成员剩余次数
       * @param _groupId 群号
       * @returns 返回是否允许at全体成员和全群剩余次数、个人剩余次数
       */
      getAtAllCount(_groupId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群被禁言用户列表
       * @param _groupId
       * @returns 返回禁言用户列表
       */
      getGroupMuteList(_groupId) {
        throw new Error(this.#errMsg);
      }
      /**
       * 戳一戳用户 支持群聊和私聊
       * @param _contact 目标信息
       * @param _count 戳一戳次数 默认为1
       */
      pokeUser(_contact, _count) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取 Cookies
       * @param _domain The domain to get cookies from
       */
      getCookies(_domain) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取 QQ 相关接口凭证
       * @param _domain The domain to get credentials from
       */
      getCredentials(_domain) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取 CSRF Token
       */
      getCSRFToken() {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置头像
       * @param file base64:// file:// http(s)://
       */
      setAvatar(_file) {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取 rkey
       * @returns rkey
       */
      getRkey() {
        throw new Error(this.#errMsg);
      }
      /**
       * 获取群 Ai 语音可用声色列表
       * @returns 声色列表
       */
      getAiCharacters() {
        throw new Error(this.#errMsg);
      }
      /**
       * 设置群 Ai 语音声色
       * @param _groupId 群号
       * @param _characterId 声色ID
       * @param _text 文本
       * @returns 是否设置成功
       */
      sendAiCharacter(_groupId, _characterId, _text) {
        throw new Error(this.#errMsg);
      }
    };
  }
});

// src/utils/message/segment.ts
var segment_exports = {};
__export(segment_exports, {
  at: () => at,
  basketball: () => basketball,
  bubbleFace: () => bubbleFace,
  button: () => button,
  contact: () => contact,
  customMusic: () => customMusic,
  dice: () => dice,
  face: () => face,
  file: () => file,
  gift: () => gift,
  image: () => image,
  json: () => json2,
  keyboard: () => keyboard,
  location: () => location,
  longMsg: () => longMsg,
  markdown: () => markdown,
  markdownTpl: () => markdownTpl,
  marketFace: () => marketFace,
  music: () => music,
  node: () => node,
  nodeDirect: () => nodeDirect,
  pasmsg: () => pasmsg,
  raw: () => raw,
  record: () => record,
  reply: () => reply,
  rps: () => rps,
  share: () => share,
  text: () => text,
  video: () => video,
  weather: () => weather,
  xml: () => xml
});
var text, at, face, reply, image, video, record, json2, xml, markdown, markdownTpl, pasmsg, keyboard, button, longMsg, raw, basketball, dice, rps, bubbleFace, weather, location, share, gift, marketFace, contact, music, customMusic, node, nodeDirect, file;
var init_segment = __esm({
  "src/utils/message/segment.ts"() {
    text = (text2) => {
      return { type: "text", text: text2 };
    };
    at = (targetId, name) => {
      return { type: "at", targetId, name };
    };
    face = (id, isBig) => {
      return { type: "face", id: Number(id), isBig };
    };
    reply = (messageId) => {
      return { type: "reply", messageId: String(messageId) };
    };
    image = (file2, options = {}) => {
      return {
        ...options,
        type: "image",
        file: file2,
        fid: options?.fid,
        size: options?.size,
        summary: options?.summary,
        fileType: options.fileType,
        height: options?.height,
        width: options?.width,
        md5: options?.md5,
        name: options?.name,
        subType: options?.subType
      };
    };
    video = (file2, options) => {
      return {
        type: "video",
        file: file2,
        height: options?.height,
        width: options?.width,
        md5: options?.md5,
        name: options?.name
      };
    };
    record = (file2, magic = false, options) => {
      return {
        type: "record",
        file: file2,
        magic,
        md5: options?.md5,
        name: options?.name
      };
    };
    json2 = (data) => {
      return { type: "json", data };
    };
    xml = (data) => {
      return { type: "xml", data };
    };
    markdown = (markdown2, config3) => {
      return { type: "markdown", markdown: markdown2, config: config3 };
    };
    markdownTpl = (templateId, params) => {
      return { type: "markdownTpl", templateId, params };
    };
    pasmsg = (id, source = "msg") => {
      return { type: "pasmsg", id, source };
    };
    keyboard = (data) => {
      const rows = [];
      if (!Array.isArray(data)) data = [data];
      for (const i of data) {
        if (Array.isArray(i)) {
          const button3 = [];
          for (const v of i) button3.push(v);
          rows.push(button3);
        } else {
          rows.push([i]);
        }
      }
      return { type: "keyboard", rows };
    };
    button = (data) => {
      return { type: "button", data: Array.isArray(data) ? data : [data] };
    };
    longMsg = (id) => {
      return { type: "longMsg", id };
    };
    raw = (data) => {
      return { type: "raw", data };
    };
    basketball = (id) => {
      return { type: "basketball", id: Number(id) };
    };
    dice = (id) => {
      return { type: "dice", id: Number(id) };
    };
    rps = (id) => {
      return { type: "rps", id: Number(id) };
    };
    bubbleFace = (id, count3) => {
      return { type: "bubbleFace", id: Number(id), count: Number(count3) };
    };
    weather = (city, code) => {
      return { type: "weather", city, code };
    };
    location = (lat, lon, title, address) => {
      return { type: "location", lat, lon, title, address };
    };
    share = (url, title, content, image2) => {
      return { type: "share", url, title, content, image: image2 };
    };
    gift = (qq, id) => {
      return { type: "gift", qq, id };
    };
    marketFace = (id) => {
      return { type: "marketFace", id };
    };
    contact = (scene, peer) => {
      return { type: "contact", scene, peer };
    };
    music = (platform, id) => {
      return { type: "music", platform, id };
    };
    customMusic = (url, audio, title, author, pic) => {
      return { type: "music", platform: "custom", url, audio, title, author, pic };
    };
    node = (userId, nickname, message2, options) => {
      return { type: "node", subType: "fake", userId, nickname, message: message2, options };
    };
    nodeDirect = (id) => {
      return { type: "node", subType: "messageID", messageId: id, message_id: id };
    };
    file = (file2, options) => {
      return {
        type: "file",
        file: file2,
        name: options?.name,
        hash: options?.hash,
        size: options?.size,
        fid: options?.fid
      };
    };
  }
});
var createRawMessage, makeMessage, makeForward;
var init_message = __esm({
  "src/utils/message/message.ts"() {
    init_segment();
    createRawMessage = (data) => {
      if (!Array.isArray(data)) data = [data];
      const msg = [];
      const rawStr = data.map((v) => {
        switch (v.type) {
          case "text": {
            msg.push(v.text);
            return v.text;
          }
          case "image":
          case "video":
          case "record": {
            if (Buffer.isBuffer(v.file)) return `[${v.type}:Buffer://...]`;
            if (/^http|^file/.test(v.file)) return `[${v.type}:${v.file}]`;
            return `[${v.type}:base64://...]`;
          }
          case "file": {
            if (Buffer.isBuffer(v.file)) return `[file:Buffer://..., fid:${v.fid}, hash:${v.hash}]`;
            if (/^http|^file/.test(v.file)) return `[file:${v.file}, fid:${v.fid}, hash:${v.hash}]`;
            return `[file:base64://..., fid:${v.fid}, hash:${v.hash}]`;
          }
          case "json":
          case "xml": {
            msg.push(v.data);
            return `[${v.type}:${v.data}]`;
          }
          case "at":
            return `[at:${v.targetId}]`;
          case "face":
            return `[face:${v.id}]`;
          case "reply":
            return `[reply:${v.messageId}]`;
          case "rps":
            return `[rps:${v.id}]`;
          case "dice":
            return `[dice:${v.id}]`;
          case "share":
            return `[share:${JSON.stringify(v)}]`;
          case "contact":
            return `[contact:${JSON.stringify(v)}]`;
          case "location":
            return `[location:${JSON.stringify(v)}]`;
          case "music":
            return `[music:${JSON.stringify(v)}]`;
          case "markdown":
            return `[markdown:${v.markdown}]`;
          case "button":
            return `[button:${JSON.stringify(v.data)}]`;
          case "keyboard":
            return `[rows:${JSON.stringify(v.rows)}]`;
          case "longMsg":
            return `[longmsg:${v.id}]`;
          case "pasmsg":
            return `[pasmsg:${v.id}]`;
          case "markdownTpl":
            return `[markdowntpl:${JSON.stringify({ templateId: v.templateId, ...v.params })}]`;
          case "raw":
            return `[raw:${JSON.stringify(v.data)}]`;
          default:
            return `[\u672A\u77E5:${lodash3.truncate(JSON.stringify(v), { length: 200 })}]`;
        }
      }).join("");
      return {
        /** 原始消息字符串: `[at:10001]这是一条测试的文本消息` */
        raw: rawStr,
        /**
         * - 经过处理的纯文本
         * - 可用于正则匹配
         * - tips: 此时还没有处理bot前缀
         */
        msg: msg.join("").trim()
      };
    };
    makeMessage = (elements) => {
      if (typeof elements === "string") return [text(elements)];
      if (!Array.isArray(elements)) return [elements];
      return elements.map((v) => typeof v === "string" ? text(v) : v);
    };
    makeForward = (elements, fakeId, fakeName) => {
      if (!Array.isArray(elements)) elements = [elements];
      return elements.map((v) => node(fakeId || "", fakeName || "", makeMessage(v)));
    };
  }
});

// src/utils/message/index.ts
var init_message2 = __esm({
  "src/utils/message/index.ts"() {
    init_message();
    init_segment();
  }
});
var NoticeType, RequestType, OneBotErrorType, OneBotCloseType, OneBotEventKey, OneBotCore, buildUrl, headersToObject, setupTimeout, request, http_default, OneBotWsBase, DEFAULT_WS_OPTIONS, OneBotWsClientManager, oneBotWsClientManager, OneBotWsClient, OneBotWsServer, OneBotWsServerManager, oneBotWsServerManager, DEFAULT_OPTIONS, OneBotHttp, OneBotMessageType, OneBotHttpManager, oneBotHttpManager;
var init_dist2 = __esm({
  "../onebot/dist/index.mjs"() {
    NoticeType = /* @__PURE__ */ ((NoticeType2) => {
      NoticeType2["GroupUpload"] = "group_upload";
      NoticeType2["GroupAdmin"] = "group_admin";
      NoticeType2["GroupDecrease"] = "group_decrease";
      NoticeType2["GroupIncrease"] = "group_increase";
      NoticeType2["GroupBan"] = "group_ban";
      NoticeType2["FriendAdd"] = "friend_add";
      NoticeType2["GroupRecall"] = "group_recall";
      NoticeType2["FriendRecall"] = "friend_recall";
      NoticeType2["Notify"] = "notify";
      NoticeType2["Nc_EmojiLike"] = "group_msg_emoji_like";
      NoticeType2["Lgl_EmojiLike"] = "reaction";
      NoticeType2["GroupEssence"] = "essence";
      NoticeType2["GroupCard"] = "group_card";
      NoticeType2["Lgl_FriendOfflineFile"] = "offline_file";
      return NoticeType2;
    })(NoticeType || {});
    RequestType = /* @__PURE__ */ ((RequestType2) => {
      RequestType2["Friend"] = "friend";
      RequestType2["Group"] = "group";
      return RequestType2;
    })(RequestType || {});
    OneBotErrorType = /* @__PURE__ */ ((OneBotErrorType2) => {
      OneBotErrorType2[OneBotErrorType2["ERROR"] = 1001] = "ERROR";
      OneBotErrorType2[OneBotErrorType2["CONNECTION_FAILED"] = 2002] = "CONNECTION_FAILED";
      OneBotErrorType2[OneBotErrorType2["RECONNECTING"] = 2003] = "RECONNECTING";
      OneBotErrorType2[OneBotErrorType2["RECONNECT_FAILED"] = 2004] = "RECONNECT_FAILED";
      OneBotErrorType2[OneBotErrorType2["AUTH_FAILED"] = 3001] = "AUTH_FAILED";
      OneBotErrorType2[OneBotErrorType2["AUTH_INVALID_FORMAT"] = 3002] = "AUTH_INVALID_FORMAT";
      return OneBotErrorType2;
    })(OneBotErrorType || {});
    OneBotCloseType = /* @__PURE__ */ ((OneBotCloseType2) => {
      OneBotCloseType2[OneBotCloseType2["ERROR"] = 1001] = "ERROR";
      OneBotCloseType2[OneBotCloseType2["MANUAL_CLOSE"] = 1002] = "MANUAL_CLOSE";
      OneBotCloseType2[OneBotCloseType2["MAX_RETRIES"] = 2001] = "MAX_RETRIES";
      OneBotCloseType2[OneBotCloseType2["SERVER_CLOSE"] = 2002] = "SERVER_CLOSE";
      OneBotCloseType2[OneBotCloseType2["CONNECTION_FAILED"] = 2003] = "CONNECTION_FAILED";
      OneBotCloseType2[OneBotCloseType2["HEARTBEAT_FAILED"] = 3001] = "HEARTBEAT_FAILED";
      OneBotCloseType2[OneBotCloseType2["HEARTBEAT_FAILED_MAX_RETRIES"] = 3002] = "HEARTBEAT_FAILED_MAX_RETRIES";
      return OneBotCloseType2;
    })(OneBotCloseType || {});
    OneBotEventKey = /* @__PURE__ */ ((OneBotEventKey2) => {
      OneBotEventKey2["OPEN"] = "open";
      OneBotEventKey2["ERROR"] = "error";
      OneBotEventKey2["CLOSE"] = "close";
      OneBotEventKey2["SEND_API"] = "sendApi";
      OneBotEventKey2["RESPONSE"] = "response";
      OneBotEventKey2["EVENT"] = "event";
      OneBotEventKey2["MESSAGE"] = "message";
      OneBotEventKey2["NOTICE"] = "notice";
      OneBotEventKey2["REQUEST"] = "request";
      OneBotEventKey2["META_EVENT"] = "meta_event";
      OneBotEventKey2["MESSAGE_SENT"] = "message_sent";
      return OneBotEventKey2;
    })(OneBotEventKey || {});
    OneBotCore = class extends EventEmitter {
      /** 是否主动关闭 */
      _manualClosed = false;
      /** 协议信息 */
      protocol;
      /** 机器人信息 */
      self;
      /** 配置 */
      _options;
      constructor(options) {
        super();
        this.protocol = {
          name: "OneBot",
          version: "0.0.0",
          connectTime: Date.now()
        };
        this._options = {
          ...options,
          timeout: options?.timeout || 120 * 1e3
        };
        this.self = {
          id: 0,
          nickname: "",
          avatar: ""
        };
      }
      /**
       * 判断是否为echo事件
       * @param data - 事件数据
       */
      isEcho(data) {
        return "echo" in data && "status" in data && "data" in data;
      }
      /**
       * 将`base64://`转为`base64://...`
       */
      _formatBase64(base642) {
        return base642.replace(/(["']?(?:base64|base):\/\/)[^"',}\s]*["']?/g, "$1...");
      }
      /**
       * 格式化API动作
       * @param action - API动作
       * @returns 格式化后的API动作
       */
      _formatAction(action) {
        return action.replace(/^(|nc_|lgl_)/, "");
      }
      /**
       * 格式化Api返回错误
       */
      _formatApiError(action, params, error) {
        return new Error(
          [
            `[${this.self_id}][sendApi] \u8BF7\u6C42\u9519\u8BEF:`,
            `  action: ${action}`,
            `  params: ${this._formatBase64(params)}`
          ].join("\n"),
          { cause: error }
        );
      }
      /**
       * 初始化Bot基本信息
       * @param maxRetries - 最大重试次数
       * @param retryInterval - 重试间隔(毫秒)
       * @returns 是否初始化成功
       */
      async _initBotInfo(maxRetries = 3, retryInterval = 1e3) {
        const fetchBotInfo = async () => {
          const { user_id, nickname } = await this.getLoginInfo();
          this.self.id = user_id;
          this.self.nickname = nickname;
          this.self.avatar = `https://q1.qlogo.cn/g?b=qq&s=0&nk=${user_id}`;
          const { app_name, app_version } = await this.getVersionInfo();
          this.protocol.name = app_name;
          this.protocol.version = app_version;
        };
        for (let i = 0; i < maxRetries; i++) {
          try {
            await fetchBotInfo();
            return true;
          } catch (error) {
            if (i === maxRetries - 1) {
              throw new Error(`\u521D\u59CB\u5316Bot\u4FE1\u606F\u5931\u8D25\uFF0C\u5DF2\u91CD\u8BD5${maxRetries}\u6B21`, { cause: error });
            }
            await new Promise((resolve) => setTimeout(resolve, retryInterval));
          }
        }
        return false;
      }
      /**
      * 添加事件监听
      * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
      * @param listener - 事件监听器
      */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * 添加一次性事件监听
       * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
       * @param listener - 事件监听器
       */
      once(event, listener) {
        return super.once(event, listener);
      }
      /**
       * 触发事件
       * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
       * @param arg - 事件参数
       */
      emit(event, arg = {}) {
        return super.emit(event, arg);
      }
      /**
       * 移除事件监听
       * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
       * @param listener - 事件监听器
       */
      off(event, listener) {
        return super.off(event, listener);
      }
      /**
       * 移除事件监听
       * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
       * @param listener - 事件监听器
       */
      removeListener(event, listener) {
        return super.removeListener(event, listener);
      }
      /**
       * 移除所有事件监听
       * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
       */
      removeAllListeners(event) {
        return super.removeAllListeners(event);
      }
      /**
       * 获取事件监听器
       * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
       * @returns 事件监听器
       */
      listeners(event) {
        return super.listeners(event);
      }
      /**
       * 获取事件监听器数量
       * @param event - 事件名称 请导入`OneBotEventKey`枚举使用
       * @returns 事件监听器数量
       */
      listenerCount(event) {
        return super.listenerCount(event);
      }
      /** 机器人ID */
      get self_id() {
        return this.self.id;
      }
      /**
       * 初始化
       */
      async init() {
        throw new Error("Not implemented");
      }
      /**
       * 事件分发
       * @param data - 事件数据
       */
      _dispatch(data) {
        this.emit("event", data);
        if (data.post_type === "message") {
          this.emit("message", data);
          return;
        }
        if (data.post_type === "message_sent") {
          this.emit("message_sent", data);
          return;
        }
        if (data.post_type === "notice") {
          this.emit("notice", data);
          return;
        }
        if (data.post_type === "request") {
          this.emit("request", data);
          return;
        }
        if (data.post_type === "meta_event") {
          this.emit("meta_event", data);
          return;
        }
        throw new Error(`[OneBot][WebSocket] \u672A\u77E5\u4E8B\u4EF6\u7C7B\u578B: ${JSON.stringify(data)}`);
      }
      /**
       * 发送API请求
       * @param action - API动作
       * @param params - API参数
       * @param timeout - 超时时间
       * @returns
       */
      async sendApi(_action, _params, _timeout = this._options.timeout) {
        throw new Error("Not implemented");
      }
      /**
       * 发送消息
       * @param message_type - 消息类型
       * @param user_id - 用户ID
       * @param message - 消息
       * @returns 消息ID
       */
      async sendMsg(message_type, user_id, message2) {
        return this.sendApi("send_msg", {
          message_type,
          user_id,
          message: message2,
          auto_escape: false
        });
      }
      /**
       * 发送私聊消息
       * @param user_id - 用户ID
       * @param message - 消息
       * @returns 消息ID
       */
      async sendPrivateMsg(user_id, message2) {
        return this.sendApi("send_private_msg", {
          user_id,
          message: message2,
          auto_escape: false
        });
      }
      /**
       * 发送群消息
       * @param group_id - 群ID
       * @param message - 消息
       * @returns 消息ID
       */
      async sendGroupMsg(group_id, message2) {
        return this.sendApi("send_group_msg", {
          group_id,
          message: message2,
          auto_escape: false
        });
      }
      /**
       * 撤回消息
       * @param message_id - 消息ID
       * @returns
       */
      async deleteMsg(message_id) {
        return this.sendApi("delete_msg", {
          message_id
        });
      }
      /**
       * 获取消息
       * @param message_id - 消息ID
       * @returns 消息详情
       */
      async getMsg(message_id) {
        return this.sendApi("get_msg", {
          message_id
        });
      }
      /**
       * 获取合并转发消息
       * @param id - 合并转发ID
       * @returns 合并转发消息
       */
      async getForwardMsg(id) {
        return this.sendApi("get_forward_msg", {
          id
        });
      }
      /**
       * 设置消息表情回应
       * @param message_id - 消息ID
       * @param emoji_id - 表情ID
       * @param set - 设置或取消
       * @returns 操作结果
       */
      async setMessageReaction(message_id, emoji_id, set) {
        return this.sendApi("set_message_reaction", {
          message_id,
          emoji_id,
          set
        });
      }
      /**
       * NapCat扩展: 获取消息的表情已回应列表
       * @param message_id - 消息ID
       * @param user_id - 用户ID
       * @param emojiType - 表情类型
       * @param count - 数量
       * @returns 表情回应列表
       */
      async nc_fetchEmojiLike(message_id, user_id, emojiType, count3) {
        return this.sendApi("fetch_emoji_like", {
          message_id,
          user_id,
          emojiType,
          count: count3
        });
      }
      /**
       * Lagrange扩展: 加入群聊表情接龙
       * @param group_id - 群ID
       * @param message_id - 消息ID
       * @param emoji_id - 表情ID
       * @returns
       */
      async lgl_joinGroupEmojiChain(group_id, message_id, emoji_id) {
        return this.sendApi(".join_group_emoji_chain", {
          group_id,
          message_id,
          emoji_id
        });
      }
      /**
       * Lagrange扩展: 加入好友表情接龙
       * @param user_id - 用户ID
       * @param message_id - 消息ID
       * @param emoji_id - 表情ID
       * @returns
       */
      async lgl_joinFriendEmojiReaction(user_id, message_id, emoji_id) {
        return this.sendApi(".join_friend_emoji_reaction", {
          user_id,
          message_id,
          emoji_id
        });
      }
      /**
       * Lagrange扩展: 调用群机器人回调
       * @param group_id - 群ID
       * @param bot_id - 机器人ID
       * @param data_1 - 数据1
       * @param data_2 - 数据2
       * @returns 机器人Uin
       */
      async lgl_sendGroupBotCallback(group_id, bot_id, data_1, data_2) {
        return this.sendApi("send_group_bot_callback", {
          group_id,
          bot_id,
          data_1,
          data_2
        });
      }
      /**
       * NapCat扩展: 标记私聊消息为已读
       * @param user_id - 用户ID
       * @param message_id - 消息ID
       * @returns
       */
      async nc_markPrivateMsgAsRead(user_id, message_id) {
        return this.sendApi("mark_private_msg_as_read", {
          user_id,
          message_id
        });
      }
      /**
       * NapCat扩展: 标记群消息为已读
       * @param group_id - 群ID
       * @param message_id - 消息ID
       * @returns
       */
      async nc_markGroupMsgAsRead(group_id, message_id) {
        return this.sendApi("mark_group_msg_as_read", {
          group_id,
          message_id
        });
      }
      /**
       * NapCat扩展: 标记所有消息为已读
       * @returns
       */
      async nc_markAllAsRead() {
        return this.sendApi("_mark_all_as_read", {});
      }
      /**
       * NapCat扩展: 转发好友单条消息
       * @param user_id - 用户ID
       * @param message_id - 消息ID
       * @returns
       */
      async nc_forwardFriendSingleMsg(user_id, message_id) {
        return this.sendApi("forward_friend_single_msg", {
          user_id,
          message_id
        });
      }
      /**
       * NapCat扩展: 转发群单条消息
       * @param group_id - 群ID
       * @param message_id - 消息ID
       * @returns
       */
      async nc_forwardGroupSingleMsg(group_id, message_id) {
        return this.sendApi("forward_group_single_msg", {
          group_id,
          message_id
        });
      }
      /**
       * GoCQ扩展: 发送合并转发消息
       * @param messages - 消息节点列表
       * @returns 消息ID
       */
      async sendForwardMsg(messages) {
        return this.sendApi("send_forward_msg", {
          messages
        });
      }
      /**
       * GoCQ扩展: 发送合并转发(群聊)
       * @param group_id - 群ID
       * @param messages - 消息节点列表
       * @returns 消息ID
       */
      async sendGroupForwardMsg(group_id, messages) {
        return this.sendApi("send_group_forward_msg", {
          group_id,
          messages
        });
      }
      /**
       * GoCQ扩展: 发送合并转发(好友)
       * @param user_id - 用户ID
       * @param messages - 消息节点列表
       * @returns 消息ID
       */
      async sendPrivateForwardMsg(user_id, messages) {
        return this.sendApi("send_private_forward_msg", {
          user_id,
          messages
        });
      }
      /**
       * GoCQ扩展: 获取群消息历史记录
       * @param group_id - 群ID
       * @param message_seq - 起始消息序号
       * @param count - 获取消息条数 (扩展)
       * @returns 消息历史记录
       */
      async getGroupMsgHistory(group_id, message_seq, count3) {
        return this.sendApi("get_group_msg_history", {
          group_id,
          message_seq,
          count: count3
        });
      }
      /**
       * NapCat扩展: 获取群消息历史记录
       * @param group_id - 群ID
       * @param message_seq - 起始消息序列号
       * @param count - 获取消息条数 (扩展)
       * @param reverse - 是否倒序 (扩展)
       * @returns 消息历史记录
       */
      async nc_getGroupMsgHistory(group_id, message_seq, count3, reverse) {
        return this.sendApi("nc_get_group_msg_history", {
          group_id,
          message_seq,
          count: count3,
          reverse
        });
      }
      /**
       * Lagrange扩展: 获取群消息历史记录
       * @param group_id - 群ID
       * @param message_id - 起始消息ID
       * @param count - 获取消息条数 (扩展)
       * @returns 消息历史记录
       */
      async lgl_getGroupMsgHistory(group_id, message_id, count3) {
        return this.sendApi("lgl_get_group_msg_history", {
          group_id,
          message_id,
          count: count3
        });
      }
      /**
       * NapCat扩展: 获取好友消息历史记录
       * @param user_id - 用户ID
       * @param message_seq - 起始消息序列号
       * @param count - 获取消息条数 (扩展)
       * @param reverse - 是否倒序 (扩展)
       * @returns 消息历史记录
       */
      async nc_getFriendMsgHistory(user_id, message_seq, count3, reverse) {
        return this.sendApi("nc_get_friend_msg_history", {
          user_id,
          message_seq,
          count: count3,
          reverse
        });
      }
      /**
       * Lagrange扩展: 获取好友消息历史记录
       * @param user_id - 用户ID
       * @param message_id - 起始消息ID
       * @param count - 获取消息条数 (扩展)
       * @returns 消息历史记录
       */
      async lgl_getFriendMsgHistory(user_id, message_id, count3) {
        return this.sendApi("lgl_get_friend_msg_history", {
          user_id,
          message_id,
          count: count3
        });
      }
      /**
       * 获取 Ai 声色列表
       * @returns Ai声色列表
       */
      async getAiCharacters() {
        return this.sendApi("get_ai_characters", {});
      }
      /**
       * 发送群 Ai 语音
       * @param group_id - 群ID
       * @param text - 文本内容
       * @param character_id - 角色ID
       * @returns 消息ID
       */
      async sendGroupAiRecord(group_id, text2, character_id) {
        return this.sendApi("send_group_ai_record", {
          group_id,
          text: text2,
          character_id
        });
      }
      /**
       * Lagrange扩展: 标记消息为已读
       * @param message_id - 消息ID
       * @returns
       */
      async lgl_markMsgAsRead(message_id) {
        return this.sendApi("mark_msg_as_read", {
          message_id
        });
      }
      /**
       * Lagrange扩展: 给消息添加表情回应
       * @param group_id - 群ID
       * @param message_id - 消息ID
       * @param code - 表情ID
       * @param is_add - 是否为添加
       * @returns
       */
      async lgl_setGroupReaction(group_id, message_id, code, is_add) {
        return this.sendApi("set_group_reaction", {
          group_id,
          message_id,
          code,
          is_add
        });
      }
      /**
       * NapCat扩展: 给消息添加表情回应
       * @param message_id - 消息ID
       * @param emoji_id - 表情ID
       * @param set - 设置或取消
       * @returns 操作结果
       */
      async nc_setMsgEmojiLike(message_id, emoji_id, set) {
        return this.sendApi("set_msg_emoji_like", {
          message_id,
          emoji_id,
          set
        });
      }
      /**
       * 发送好友赞
       * @param user_id - 用户ID
       * @param times - 赞的次数
       */
      async sendLike(user_id, times) {
        return this.sendApi("send_like", {
          user_id,
          times
        });
      }
      /**
       * 处理加好友请求
       * @param flag - 请求标识
       * @param approve - 是否同意
       * @param remark - 备注
       */
      async setFriendAddRequest(flag, approve, remark) {
        return this.sendApi("set_friend_add_request", {
          flag,
          approve,
          remark
        });
      }
      /**
       * Lagrange扩展: 处理加好友请求
       * @param flag - 请求标识
       * @param approve - 是否同意
       * @param reason - 理由
       */
      async lgl_setFriendAddRequest(flag, approve, reason) {
        return this.sendApi("lgl_set_friend_add_request", {
          flag,
          approve,
          reason
        });
      }
      /**
       * 获取陌生人信息
       * @param user_id - 用户ID
       * @param no_cache - 是否不使用缓存
       */
      async getStrangerInfo(user_id, no_cache) {
        return this.sendApi("get_stranger_info", {
          user_id,
          no_cache
        });
      }
      /**
       * NapCat扩展: 获取陌生人信息
       * @param user_id - 用户ID
       */
      async nc_getStrangerInfo(user_id) {
        return this.sendApi("nc_get_stranger_info", {
          user_id
        });
      }
      /**
       * 获取好友列表
       */
      async getFriendList() {
        return this.sendApi("get_friend_list", {});
      }
      /**
       * NapCat扩展: 获取好友列表
       * @param no_cache - 是否不使用缓存
       */
      async nc_getFriendList(no_cache) {
        return this.sendApi("nc_get_friend_list", {
          no_cache
        });
      }
      /**
       * Lagrange扩展: 获取好友列表
       */
      async lgl_getFriendList() {
        return this.sendApi("lgl_get_friend_list", {});
      }
      /**
       * GoCQ扩展: 获取单向好友列表
       */
      async getUnidirectionalFriendList() {
        return this.sendApi("get_unidirectional_friend_list", {});
      }
      /**
       * NapCat扩展: 获取单向好友列表
       */
      async nc_getUnidirectionalFriendList() {
        return this.sendApi("nc_get_unidirectional_friend_list", {});
      }
      /**
       * GoCQ扩展: 删除好友
       * @param user_id - 用户ID
       */
      async deleteFriend(user_id) {
        return this.sendApi("delete_friend", {
          user_id
        });
      }
      /**
       * NapCat扩展: 删除好友
       * @param user_id - 用户ID
       * @param friend_id - 好友ID
       * @param temp_block - 临时拉黑
       * @param temp_both_del - 临时双向删除
       */
      async nc_deleteFriend(user_id, friend_id, temp_block, temp_both_del) {
        return this.sendApi("nc_delete_friend", {
          user_id,
          friend_id,
          temp_block,
          temp_both_del
        });
      }
      /**
       * Lagrange扩展: 删除好友
       * @param user_id - 用户ID
       * @param block - 是否拉黑
       */
      async lgl_deleteFriend(user_id, block) {
        return this.sendApi("lgl_delete_friend", {
          user_id,
          block
        });
      }
      /**
       * GoCQ扩展: 删除单向好友
       * @param user_id - 用户ID
       */
      async deleteUnidirectionalFriend(user_id) {
        return this.sendApi("delete_unidirectional_friend", {
          user_id
        });
      }
      /**
       * NapCat扩展: 设置好友备注
       * @param user_id - 用户ID
       * @param remark - 备注
       */
      async nc_setFriendRemark(user_id, remark) {
        return this.sendApi("nc_set_friend_remark", {
          user_id,
          remark
        });
      }
      /**
       * NapCat扩展: 获取分类的好友列表
       */
      async nc_getFriendsWithCategory() {
        return this.sendApi("nc_get_friends_with_category", {});
      }
      /**
       * NapCat扩展: 获取可疑好友请求
       */
      async nc_getDoubtFriendsAddRequest() {
        return this.sendApi("nc_get_doubt_friends_add_request", {});
      }
      /**
       * NapCat扩展: 处理可疑好友请求
       * @param request_id - 请求ID
       * @param approve - 是否同意
       */
      async nc_setDoubtFriendsAddRequest(request_id, approve) {
        return this.sendApi("nc_set_doubt_friends_add_request", {
          request_id,
          approve
        });
      }
      /**
       * NapCat扩展: 好友戳一戳
       * @param user_id - 用户ID
       * @param target_id - 目标ID
       */
      async nc_friendPoke(user_id, target_id) {
        return this.sendApi("nc_friend_poke", {
          user_id,
          target_id
        });
      }
      /**
       * 群组踢人
       * @param group_id - 群ID
       * @param user_id - 用户ID
       * @param reject_add_request - 是否拒绝再次加群
       */
      async setGroupKick(group_id, user_id, reject_add_request) {
        return this.sendApi("set_group_kick", {
          group_id,
          user_id,
          reject_add_request
        });
      }
      /**
       * 群组单人禁言
       * @param group_id - 群ID
       * @param user_id - 用户ID
       * @param duration - 禁言时长
       */
      async setGroupBan(group_id, user_id, duration) {
        return this.sendApi("set_group_ban", {
          group_id,
          user_id,
          duration
        });
      }
      /**
       * 群组匿名用户禁言
       * @param group_id - 群ID
       * @param anonymous - 匿名对象
       * @param flag - 匿名标识
       * @param duration - 禁言时长
       */
      async setGroupAnonymousBan(group_id, anonymous, flag, duration) {
        return this.sendApi("set_group_anonymous_ban", {
          group_id,
          anonymous,
          flag,
          duration
        });
      }
      /**
       * 群组全员禁言
       * @param group_id - 群ID
       * @param enable - 是否启用
       */
      async setGroupWholeBan(group_id, enable) {
        return this.sendApi("set_group_whole_ban", {
          group_id,
          enable
        });
      }
      /**
       * 群组设置管理员
       * @param group_id - 群ID
       * @param user_id - 用户ID
       * @param enable - 是否设置为管理员
       */
      async setGroupAdmin(group_id, user_id, enable) {
        return this.sendApi("set_group_admin", {
          group_id,
          user_id,
          enable
        });
      }
      /**
       * 群组匿名
       * @param group_id - 群ID
       * @param enable - 是否启用
       */
      async setGroupAnonymous(group_id, enable) {
        return this.sendApi("set_group_anonymous", {
          group_id,
          enable
        });
      }
      /**
       * 设置群名片（群备注）
       * @param group_id - 群ID
       * @param user_id - 用户ID
       * @param card - 名片
       */
      async setGroupCard(group_id, user_id, card) {
        return this.sendApi("set_group_card", {
          group_id,
          user_id,
          card
        });
      }
      /**
       * 设置群名
       * @param group_id - 群ID
       * @param group_name - 群名
       */
      async setGroupName(group_id, group_name) {
        return this.sendApi("set_group_name", {
          group_id,
          group_name
        });
      }
      /**
       * 退出群组
       * @param group_id - 群ID
       * @param is_dismiss - 是否解散
       */
      async setGroupLeave(group_id, is_dismiss) {
        return this.sendApi("set_group_leave", {
          group_id,
          is_dismiss
        });
      }
      /**
       * Lagrange扩展: 退出群组
       * @param group_id - 群ID
       */
      async lgl_setGroupLeave(group_id) {
        return this.sendApi("lgl_set_group_leave", {
          group_id
        });
      }
      /**
       * 设置群组专属头衔
       * @param group_id - 群ID
       * @param user_id - 用户ID
       * @param special_title - 头衔
       * @param duration - 时长
       */
      async setGroupSpecialTitle(group_id, user_id, special_title, duration) {
        return this.sendApi("set_group_special_title", {
          group_id,
          user_id,
          special_title,
          duration
        });
      }
      /**
       * 获取群信息
       * @param group_id - 群ID
       * @param no_cache - 是否不使用缓存
       */
      async getGroupInfo(group_id, no_cache) {
        return this.sendApi("get_group_info", {
          group_id,
          no_cache
        });
      }
      /**
       * 获取群列表
       */
      async getGroupList() {
        return this.sendApi("get_group_list", {});
      }
      /**
       * 获取群成员信息
       * @param group_id - 群ID
       * @param user_id - 用户ID
       * @param no_cache - 是否不使用缓存
       */
      async getGroupMemberInfo(group_id, user_id, no_cache) {
        return this.sendApi("get_group_member_info", {
          group_id,
          user_id,
          no_cache
        });
      }
      /**
       * 获取群成员列表
       * @param group_id - 群ID
       * @param no_cache - 是否不使用缓存
       */
      async getGroupMemberList(group_id, no_cache) {
        return this.sendApi("get_group_member_list", {
          group_id,
          no_cache
        });
      }
      /**
       * 获取群荣誉信息
       * @param group_id - 群ID
       * @param type - 荣誉类型
       */
      async getGroupHonorInfo(group_id, type) {
        return this.sendApi("get_group_honor_info", {
          group_id,
          type
        });
      }
      /**
       * 处理加群请求/邀请
       * @param flag - 请求标识
       * @param sub_type - 类型
       * @param approve - 是否同意
       * @param reason - 理由
       */
      async setGroupAddRequest(flag, sub_type, approve, reason) {
        return this.sendApi("set_group_add_request", {
          flag,
          sub_type,
          approve,
          reason
        });
      }
      /**
       * GoCQ拓展: 设置群头像
       * @param group_id - 群ID
       * @param file - 文件
       * @param cache - 缓存
       */
      async setGroupPortrait(group_id, file2, cache10) {
        return this.sendApi("set_group_portrait", {
          group_id,
          file: file2,
          cache: cache10
        });
      }
      /**
       * GoCQ拓展: 设置精华消息
       * @param message_id - 消息ID
       */
      async setEssenceMsg(message_id) {
        return this.sendApi("set_essence_msg", {
          message_id
        });
      }
      /**
       * GoCQ拓展: 移出精华消息
       * @param message_id - 消息ID
       */
      async deleteEssenceMsg(message_id) {
        return this.sendApi("delete_essence_msg", {
          message_id
        });
      }
      /**
       * GoCQ拓展: 获取精华消息列表
       * @param group_id - 群ID
       */
      async getEssenceMsgList(group_id) {
        return this.sendApi("get_essence_msg_list", {
          group_id
        });
      }
      /**
       * GoCQ拓展: 群打卡
       * @param group_id - 群ID
       */
      async sendGroupSign(group_id) {
        return this.sendApi("send_group_sign", {
          group_id
        });
      }
      /**
       * GoCQ拓展: 获取群公告
       * @param group_id - 群ID
       */
      async getGroupNotice(group_id) {
        return this.sendApi("_get_group_notice", {
          group_id
        });
      }
      /**
       * GoCQ拓展: 发送群公告
       * @param group_id - 群ID
       * @param content - 内容
       * @param image - 图片
       */
      async sendGroupNotice(group_id, content, image2) {
        return this.sendApi("_send_group_notice", {
          group_id,
          content,
          image: image2
        });
      }
      /**
       * GoCQ拓展: 删除群公告
       * @param group_id - 群ID
       * @param notice_id - 公告ID
       */
      async delGroupNotice(group_id, notice_id) {
        return this.sendApi("_del_group_notice", {
          group_id,
          notice_id
        });
      }
      /**
       * GoCQ拓展: 获取群系统消息
       */
      async getGroupSystemMsg() {
        return this.sendApi("get_group_system_msg", {});
      }
      /**
       * GoCQ拓展: 获取群@全体成员剩余次数
       * @param group_id - 群ID
       */
      async getGroupAtAllRemain(group_id) {
        return this.sendApi("get_group_at_all_remain", {
          group_id
        });
      }
      /**
       * Lagrange拓展: 设置群Bot发言状态
       * @param group_id - 群ID
       * @param status - 状态
       */
      async lgl_setGroupBotStatus(group_id, status) {
        return this.sendApi("set_group_bot_status", {
          group_id,
          status
        });
      }
      /**
       * NapCat拓展: 群组踢多人
       * @param group_id - 群ID
       * @param user_ids - 用户ID数组
       * @param reject_add_request - 是否拒绝再次加群
       */
      async nc_setGroupKickMembers(group_id, user_ids, reject_add_request) {
        return this.sendApi("set_group_kick_members", {
          group_id,
          user_ids,
          reject_add_request
        });
      }
      /**
       * NapCat拓展: 设置机器人进群选项
       * @param group_id - 群ID
       * @param option - 选项
       */
      async nc_setGroupRobotAddOption(group_id, option) {
        return this.sendApi("set_group_robot_add_option", {
          group_id,
          option
        });
      }
      /**
       * NapCat拓展: 设置群添加选项
       * @param group_id - 群ID
       * @param option - 选项
       */
      async nc_setGroupAddOption(group_id, option) {
        return this.sendApi("set_group_add_option", {
          group_id,
          option
        });
      }
      /**
       * NapCat拓展: 设置群搜索
       * @param group_id - 群ID
       * @param enable - 是否启用
       */
      async nc_setGroupSearch(group_id, enable) {
        return this.sendApi("set_group_search", {
          group_id,
          enable
        });
      }
      /**
       * NapCat拓展: 设置群备注
       * @param group_id - 群ID
       * @param remark - 备注
       */
      async nc_setGroupRemark(group_id, remark) {
        return this.sendApi("set_group_remark", {
          group_id,
          remark
        });
      }
      /**
       * NapCat拓展: 群内戳一戳
       * @param group_id - 群ID
       * @param user_id - 用户ID
       */
      async nc_groupPoke(group_id, user_id) {
        return this.sendApi("group_poke", {
          group_id,
          user_id
        });
      }
      /**
       * NapCat拓展: 获取群信息扩展
       * @param group_id - 群ID
       */
      async nc_getGroupInfoEx(group_id) {
        return this.sendApi("get_group_info_ex", {
          group_id
        });
      }
      /**
       * NapCat拓展: 获取群详细信息
       * @param group_id - 群ID
       */
      async nc_getGroupDetailInfo(group_id) {
        return this.sendApi("get_group_detail_info", {
          group_id
        });
      }
      /**
       * NapCat拓展: 获取群忽略添加请求
       * @param group_id - 群ID
       */
      async nc_getGroupIgnoreAddRequest(group_id) {
        return this.sendApi("get_group_ignore_add_request", {
          group_id
        });
      }
      /**
       * NapCat拓展: 获取群禁言列表
       * @param group_id - 群ID
       */
      async nc_getGroupShutList(group_id) {
        return this.sendApi("get_group_shut_list", {
          group_id
        });
      }
      /**
       * NapCat扩展: 获取群过滤系统消息
       * @param group_id - 群ID
       */
      async nc_getGroupIgnoredNotifies(group_id) {
        return this.sendApi("get_group_ignored_notifies", {
          group_id
        });
      }
      /**
       * GoCQ扩展: 获取群文件资源链接
       * @param group_id - 群ID
       * @param file_id - 文件ID
       * @param busid - 业务ID 废弃属性
       */
      async getGroupFileUrl(group_id, file_id, busid) {
        return this.sendApi("get_group_file_url", {
          group_id,
          file_id,
          busid
        });
      }
      /**
       * GoCQ扩展: 获取私聊文件资源链接
       * @param user_id - 用户ID
       * @param file_id - 文件ID
       * @param busid - 业务ID 废弃属性
       */
      async getPrivateFileUrl(user_id, file_id, busid) {
        return this.sendApi("get_private_file_url", {
          user_id,
          file_id,
          busid
        });
      }
      /**
       * Lagrange扩展: 获取私聊文件资源链接
       * @param user_id - 用户ID
       * @param file_id - 文件ID
       * @param file_hash - 文件哈希
       */
      async lgl_getPrivateFileUrl(user_id, file_id, file_hash) {
        return this.sendApi("lgl_get_private_file_url", {
          user_id,
          file_id,
          file_hash
        });
      }
      /**
       * GoCQ扩展: 上传群文件
       * @param group_id - 群ID
       * @param file - 文件路径
       * @param name - 文件名
       * @param folder - 文件夹
       */
      async uploadGroupFile(group_id, file2, name, folder) {
        return this.sendApi("upload_group_file", {
          group_id,
          file: file2,
          name,
          folder
        });
      }
      /**
       * GoCQ扩展: 上传私聊文件
       * @param user_id - 用户ID
       * @param file - 文件路径
       * @param name - 文件名
       */
      async uploadPrivateFile(user_id, file2, name) {
        return this.sendApi("upload_private_file", {
          user_id,
          file: file2,
          name
        });
      }
      /**
       * GoCQ扩展: 获取群文件系统信息
       * @param group_id - 群ID
       */
      async getGroupFileSystemInfo(group_id) {
        return this.sendApi("get_group_file_system_info", {
          group_id
        });
      }
      /**
       * GoCQ扩展: 获取群根目录文件列表
       * @param group_id - 群ID
       */
      async getGroupRootFiles(group_id) {
        return this.sendApi("get_group_root_files", {
          group_id
        });
      }
      /**
       * GoCQ扩展: 获取群子目录文件列表
       * @param group_id - 群ID
       * @param folder_id - 文件夹ID
       */
      async getGroupFilesByFolder(group_id, folder_id) {
        return this.sendApi("get_group_files_by_folder", {
          group_id,
          folder_id
        });
      }
      /**
       * GoCQ扩展: 创建群文件文件夹
       * @param group_id - 群ID
       * @param name - 文件夹名
       */
      async createGroupFileFolder(group_id, name) {
        return this.sendApi("create_group_file_folder", {
          group_id,
          name
        });
      }
      /**
       * GoCQ扩展: 删除群文件文件夹
       * @param group_id - 群ID
       * @param folder_id - 文件夹ID
       */
      async deleteGroupFolder(group_id, folder_id) {
        return this.sendApi("delete_group_folder", {
          group_id,
          folder_id
        });
      }
      /**
       * GoCQ扩展: 删除群文件
       * @param group_id - 群ID
       * @param file_id - 文件ID
       * @param busid - 业务ID
       */
      async deleteGroupFile(group_id, file_id, busid) {
        return this.sendApi("delete_group_file", {
          group_id,
          file_id,
          busid
        });
      }
      /**
       * NapCat/Lagrange扩展: 删除群文件
       * @param group_id - 群ID
       * @param file_id - 文件ID
       */
      async nc_deleteGroupFile(group_id, file_id) {
        return this.sendApi("nc_delete_group_file", {
          group_id,
          file_id
        });
      }
      /**
       * Lagrange扩展: 上传图片
       * @param file - 文件路径
       */
      async lgl_uploadImage(file2) {
        return this.sendApi("lgl_upload_image", {
          file: file2
        });
      }
      /**
       * 社区扩展: 移动群文件
       * @param group_id - 群ID
       * @param file_id - 文件ID
       * @param folder_id - 文件夹ID
       */
      async moveGroupFile(group_id, file_id, folder_id) {
        return this.sendApi("move_group_file", {
          group_id,
          file_id,
          folder_id
        });
      }
      /**
       * Lagrange扩展: 重命名群文件文件夹
       * @param group_id - 群ID
       * @param folder_id - 文件夹ID
       * @param new_name - 新名称
       */
      async lgl_renameGroupFileFolder(group_id, folder_id, new_name) {
        return this.sendApi("lgl_rename_group_file_folder", {
          group_id,
          folder_id,
          new_name
        });
      }
      /**
       * NapCat扩展: 转发群文件
       * @param group_id - 群ID
       * @param file_id - 文件ID
       */
      async nc_transGroupFile(group_id, file_id) {
        return this.sendApi("nc_trans_group_file", {
          group_id,
          file_id
        });
      }
      /**
       * NapCat扩展: 重命名群文件
       * @param group_id - 群ID
       * @param file_id - 文件ID
       * @param current_parent_directory - 当前父目录
       * @param new_name - 新名称
       */
      async nc_renameGroupFile(group_id, file_id, current_parent_directory, new_name) {
        return this.sendApi("nc_rename_group_file", {
          group_id,
          file_id,
          current_parent_directory,
          new_name
        });
      }
      /**
       * NapCat扩展: 获取文件
       * @param file_id - 文件ID
       */
      async nc_getFile(file2) {
        return this.sendApi("nc_get_file", {
          file: file2
        });
      }
      /**
       * 获取登录号信息
       */
      async getLoginInfo() {
        return this.sendApi("get_login_info", {});
      }
      /**
       * 获取版本信息
       */
      async getVersionInfo() {
        return this.sendApi("get_version_info", {});
      }
      /**
       * 获取状态
       */
      async getStatus() {
        return this.sendApi("get_status", {});
      }
      /**
       * 获取Cookies
       * @param domain - 域名
       */
      async getCookies(domain) {
        return this.sendApi("get_cookies", { domain });
      }
      /**
       * NapCat扩展: 获取Cookies
       * @param domain - 域名
       */
      async nc_getCookies(domain) {
        return this.sendApi("nc_get_cookies", { domain });
      }
      /**
       * 获取CSRF Token
       */
      async getCsrfToken() {
        return this.sendApi("get_csrf_token", {});
      }
      /**
       * 获取QQ相关接口凭证
       * @param domain - 域名
       */
      async getCredentials(domain) {
        return this.sendApi("get_credentials", { domain });
      }
      /**
       * 获取语音
       * @param file - 文件名
       * @param out_format - 输出格式
       */
      async getRecord(file2, out_format) {
        return this.sendApi("get_record", { file: file2, out_format });
      }
      /**
       * NapCat扩展: 获取语音
       * @param out_format - 输出格式
       * @param file - 文件名
       * @param file_id - 文件ID
       */
      async nc_getRecord(out_format, file2, file_id) {
        return this.sendApi("nc_get_record", { file: file2, file_id, out_format });
      }
      /**
       * 获取图片
       * @param file - 文件名
       */
      async getImage(file2) {
        return this.sendApi("get_image", { file: file2 });
      }
      /**
       * NapCat扩展: 获取图片
       * @param file - 文件名
       * @param file_id - 文件ID
       */
      async nc_getImage(file2, file_id) {
        return this.sendApi("nc_get_image", { file: file2, file_id });
      }
      /**
       * 检查是否可以发送图片
       */
      async canSendImage() {
        return this.sendApi("can_send_image", {});
      }
      /**
       * 检查是否可以发送语音
       */
      async canSendRecord() {
        return this.sendApi("can_send_record", {});
      }
      /**
       * 设置登录号资料
       * @param nickname - 昵称
       * @param company - 公司
       * @param email - 邮箱
       * @param college - 学校
       * @param personal_note - 个性签名
       */
      async setQqProfile(nickname, company, email, college, personal_note) {
        return this.sendApi("set_qq_profile", { nickname, company, email, college, personal_note });
      }
      /**
       * 获取企点账号信息
       */
      async qidianGetAccountInfo() {
        return this.sendApi("qidian_get_account_info", {});
      }
      /**
       * 获取在线机型
       * @param model - 机型
       */
      async getModelShow(model) {
        return this.sendApi("_get_model_show", { model });
      }
      /**
       * 设置在线机型
       * @param model - 机型
       * @param model_show - 展示名
       */
      async setModelShow(model, model_show) {
        return this.sendApi("_set_model_show", { model, model_show });
      }
      /**
       * 获取当前账号在线客户端列表
       * @param no_cache - 是否不使用缓存
       */
      async getOnlineClients(no_cache) {
        return this.sendApi("get_online_clients", { no_cache });
      }
      /**
       * 社区扩展: 获取已收藏的QQ表情列表
       */
      async fetchCustomFace() {
        return this.sendApi("fetch_custom_face", {});
      }
      /**
       * 社区扩展: 设置QQ头像
       * @param file - 文件路径
       */
      async setQqAvatar(file2) {
        return this.sendApi("set_qq_avatar", { file: file2 });
      }
      /**
       * 社区扩展: 获取rkey
       */
      async getRkey() {
        return this.sendApi("get_rkey", {});
      }
      /**
       * NapCat扩展: 获取NC版rkey
       */
      async nc_getRkey() {
        return this.sendApi("nc_get_rkey", {});
      }
      /**
       * Lagrange扩展: 获取mface key
       */
      async lgl_getMfaceKey() {
        return this.sendApi("get_mface_key", {});
      }
      /**
       * NapCat扩展: 获取rkey服务器
       */
      async nc_getRkeyServer() {
        return this.sendApi("get_rkey_server", {});
      }
      /**
       * NapCat扩展: 设置自定义在线状态
       * @param face - 头像
       * @param text - 状态文本
       */
      async nc_setDiyOnlineStatus(face2, text2) {
        return this.sendApi("set_diy_online_status", { face: face2, text: text2 });
      }
      /**
       * NapCat扩展: 设置在线状态
       * @param status - 状态
       */
      async nc_setOnlineStatus(status) {
        return this.sendApi("set_online_status", { status });
      }
      /**
       * NapCat扩展: 设置输入状态
       * @param user_id - 用户ID
       * @param typing - 是否正在输入
       */
      async nc_setInputStatus(user_id, typing) {
        return this.sendApi("set_input_status", { user_id, typing });
      }
      /**
       * NapCat扩展: 获取个人资料点赞
       * @param user_id - 用户ID
       */
      async nc_getProfileLike(user_id) {
        return this.sendApi("get_profile_like", { user_id });
      }
      /**
       * NapCat扩展: 获取官方机器人账号范围
       */
      async nc_getRobotUinRange() {
        return this.sendApi("get_robot_uin_range", {});
      }
      /**
       * NapCat扩展: 设置自己的个性签名
       * @param longNick - 个性签名
       */
      async nc_setSelfLongnick(longNick) {
        return this.sendApi("set_self_longnick", { longNick });
      }
      /**
       * NapCat扩展: 获取最近联系人
       * @param count - 数量
       */
      async nc_getRecentContact(count3) {
        return this.sendApi("get_recent_contact", { count: count3 });
      }
      /**
       * NapCat扩展: 获取用户状态
       * @param user_id - 用户ID
       */
      async nc_getUserStatus(user_id) {
        return this.sendApi("get_user_status", { user_id });
      }
      /**
       * NapCat扩展: 获取clientkey
       */
      async nc_getClientkey() {
        return this.sendApi("get_clientkey", {});
      }
      /**
       * 重启 OneBot 实现
       * @param delay - 延迟
       */
      async restartOneBot(delay) {
        return this.sendApi("set_restart", { delay });
      }
      /**
       * 清理缓存
       */
      async cleanCache() {
        return this.sendApi("clean_cache", {});
      }
      /**
       * 下载文件到缓存目录
       * @param url - 链接
       * @param thread_count - 线程数
       * @param headers - 请求头
       */
      async downloadFile(url, thread_count, headers) {
        return this.sendApi("download_file", { url, thread_count, headers });
      }
      /**
       * NapCat扩展: 下载文件到缓存目录
       * @param url - 链接
       * @param base64 - base64
       * @param name - 文件名
       * @param headers - 请求头
       */
      async nc_downloadFile(url, base642, name, headers) {
        return this.sendApi("nc_download_file", { url, base64: base642, name, headers });
      }
      /**
       * 检查链接安全性
       * @param url - 链接
       */
      async checkUrlSafely(url) {
        return this.sendApi("check_url_safely", { url });
      }
      /**
       * 获取中文分词
       * @param content - 内容
       */
      async getWordSlices(content) {
        return this.sendApi(".get_word_slices", { content });
      }
      /**
       * 对事件执行快速操作
       * @param context - 上下文
       * @param operation - 操作
       */
      async handleQuickOperation(context2, operation) {
        return this.sendApi(".handle_quick_operation", { context: context2, operation });
      }
      /**
       * OCR图片
       * @param image - 图片
       */
      async ocrImage(image2) {
        return this.sendApi("ocr_image", { image: image2 });
      }
      /**
       * OCR图片 (别名)
       * @param image - 图片
       */
      async dotOcrImage(image2) {
        return this.sendApi(".ocr_image", { image: image2 });
      }
      /**
       * NapCat扩展: OCR图片
       * @param image - 图片
       */
      async nc_ocrImage(image2) {
        return this.sendApi("nc_ocr_image", { image: image2 });
      }
      /**
       * NapCat扩展: 英文翻译为中文
       * @param text - 英文
       */
      async nc_translateEn2zh(text2) {
        return this.sendApi("translate_en2zh", { text: text2 });
      }
      /**
       * NapCat扩展: 点击按钮
       * @param message_id - 消息ID
       * @param button_index - 按钮索引
       */
      async nc_clickInlineKeyboardButton(message_id, button_index) {
        return this.sendApi("click_inline_keyboard_button", { message_id, button_index });
      }
      /**
       * NapCat扩展: 获取推荐好友/群聊卡片
       * @param user_id - 用户ID
       */
      async nc_arkSharePeer(user_id) {
        return this.sendApi("ArkSharePeer", { user_id });
      }
      /**
       * NapCat扩展: 获取推荐群聊卡片
       * @param group_id - 群ID
       */
      async nc_arkShareGroup(group_id) {
        return this.sendApi("ArkShareGroup", { group_id });
      }
      /**
       * NapCat扩展: 创建收藏
       * @param message_id - 消息ID
       */
      async nc_createCollection(message_id) {
        return this.sendApi("create_collection", { message_id });
      }
      /**
       * NapCat扩展: 获取收藏列表
       */
      async nc_getCollectionList() {
        return this.sendApi("get_collection_list", {});
      }
      /**
       * NapCat扩展: 退出机器人
       */
      async nc_botExit() {
        return this.sendApi("bot_exit", {});
      }
      /**
       * NapCat扩展: 发送自定义组包
       * @param args - 参数
       */
      async nc_sendPacket(args) {
        return this.sendApi("send_packet", args);
      }
      /**
       * NapCat扩展: 获取packet状态
       */
      async nc_getPacketStatus() {
        return this.sendApi("nc_get_packet_status", {});
      }
      /**
       * NapCat扩展: 获取小程序卡片
       * @param args - 参数
       */
      async nc_getMiniAppArk(args) {
        return this.sendApi("get_mini_app_ark", args);
      }
      /**
       * NapCat扩展: 发送戳一戳
       * @param args - 参数
       */
      async nc_sendPoke(args) {
        return this.sendApi("send_poke", args);
      }
    };
    buildUrl = (url, params) => {
      if (!params) return url;
      const queryString = Object.entries(params).map(([key, value]) => {
        const encodedValue = encodeURIComponent(
          typeof value === "object" ? JSON.stringify(value) : String(value)
        );
        return `${encodeURIComponent(key)}=${encodedValue}`;
      }).join("&");
      return url + (url.includes("?") ? "&" : "?") + queryString;
    };
    headersToObject = (headers) => {
      const result = {};
      headers.forEach((value, key) => {
        result[key.toLowerCase()] = value;
      });
      return result;
    };
    setupTimeout = (abortController, timeout2) => {
      return setTimeout(() => {
        abortController.abort();
      }, timeout2);
    };
    request = async (config3) => {
      const { url, method = "GET", headers = {}, timeout: timeout2 = 1e4, data, responseType = "json" } = config3;
      let requestUrl = url;
      const requestInit = {
        method,
        headers: { ...headers }
      };
      if (method === "GET" && data) {
        requestUrl = buildUrl(url, data);
      } else if (data) {
        if (typeof data === "object") {
          requestInit.body = JSON.stringify(data);
        } else {
          requestInit.body = data;
        }
      }
      if (!headers["Content-Type"] && !headers["content-type"]) {
        requestInit.headers = {
          ...requestInit.headers,
          "Content-Type": "application/json;charset=UTF-8"
        };
      }
      const abortController = new AbortController();
      requestInit.signal = abortController.signal;
      let timeoutId;
      if (timeout2 > 0) {
        timeoutId = setupTimeout(abortController, timeout2);
      }
      try {
        const response = await fetch(requestUrl, requestInit);
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        let responseData;
        switch (responseType) {
          case "json":
            responseData = await response.json();
            break;
          case "text":
            responseData = await response.text();
            break;
          case "blob":
            responseData = await response.blob();
            break;
          case "arraybuffer":
            responseData = await response.arrayBuffer();
            break;
          default:
            try {
              responseData = await response.json();
            } catch {
              responseData = await response.text();
            }
        }
        const httpResponse = {
          data: responseData,
          status: response.status,
          statusText: response.statusText,
          headers: headersToObject(response.headers),
          config: config3
        };
        if (!response.ok) {
          const error = new Error(`\u8BF7\u6C42\u5931\u8D25\uFF0C\u72B6\u6001\u7801: ${response.status}`);
          error.type = "server";
          error.config = config3;
          error.status = response.status;
          error.response = httpResponse;
          throw error;
        }
        return httpResponse;
      } catch (error) {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (error instanceof Error) {
          const httpError = error;
          if (error.name === "AbortError") {
            httpError.message = `\u8BF7\u6C42\u8D85\u65F6\uFF08${timeout2}ms\uFF09`;
            httpError.type = "timeout";
          } else if (!httpError.type) {
            httpError.type = "network";
          }
          httpError.config = config3;
          throw httpError;
        }
        throw error;
      }
    };
    http_default = {
      get: (url, params, config3 = {}) => {
        return request({
          ...config3,
          method: "GET",
          url,
          data: params
        });
      },
      post: (url, data, config3 = {}) => {
        return request({
          ...config3,
          method: "POST",
          url,
          data
        });
      },
      request: (config3) => {
        return request(config3);
      }
    };
    OneBotWsBase = class extends OneBotCore {
      /** 请求ID */
      echo;
      /** 是否setSocket */
      _setSocket = false;
      /** WebSocket实例 */
      _socket;
      constructor(socket, options) {
        super(options);
        this.echo = BigInt(0);
        this._socket = socket;
      }
      /**
       * 获取关闭类型
       */
      static get CloseType() {
        return {
          /** 常规关闭 */
          ERROR: 1001,
          /** 主动关闭 */
          MANUAL_CLOSE: 1002,
          /** 客户端独有:重连上限 */
          MAX_RETRIES: 2001,
          /** 客户端独有: 服务端关闭 */
          SERVER_CLOSE: 2002
          /* SERVER_CLOSE */
        };
      }
      /**
       * 获取错误类型
       */
      static get ErrorType() {
        return {
          /** 常规错误 */
          ERROR: 1001,
          /** 客户端独有: 初始化失败，正在尝试重连 */
          CONNECTION_FAILED: 2002,
          /** 客户端独有: 初始化失败，重连关闭 */
          RECONNECTING: 2003,
          /** 客户端独有: 初始化失败，重连达到上限 */
          RECONNECT_FAILED: 2004,
          /** 服务端独有: 鉴权失败 */
          AUTH_FAILED: 3001
          /* AUTH_FAILED */
        };
      }
      /**
       * 关闭连接
       */
      close() {
        this._manualClosed = true;
        this._socket.close();
        this.emit(
          "close",
          1002
          /* MANUAL_CLOSE */
        );
        this.removeAllListeners();
      }
      /**
       * 更新socket
       * @param socket - 新的socket
       * @return 返回一个状态函数 请在处理设置socket相关后调用 否则close事件无法触发
       */
      setSocket(socket) {
        this._setSocket = true;
        this._socket.close();
        this._socket.removeAllListeners();
        this._socket = socket;
        return () => {
          this._setSocket = false;
        };
      }
      /**
       * 判断是否为echo事件
       * @param data - 事件数据
       */
      isEcho(data) {
        return "echo" in data && "status" in data && "data" in data;
      }
      /**
       * 初始化WebSocket连接
       */
      async init() {
        await this._initBotInfo();
      }
      /**
       * 发送API请求
       * @param action - API动作
       * @param params - API参数
       * @param timeout - 超时时间
       * @returns 返回API响应 注意: 返回的是response.data，而不是response
       */
      async sendApi(action, params, timeout2 = this._options.timeout) {
        const echo = (++this.echo).toString();
        const request22 = JSON.stringify({ echo, action, params });
        return new Promise((resolve, reject) => {
          const timeoutId = setTimeout(() => {
            reject(this._formatApiError(action, request22, "\u8BF7\u6C42\u8D85\u65F6"));
          }, timeout2 * 1e3);
          this.emit("sendApi", { echo, action, params, request: request22 });
          this._socket.send(request22);
          this.once(`echo:${echo}`, (data) => {
            clearTimeout(timeoutId);
            if (data.status === "ok") {
              resolve(data.data);
            } else {
              reject(this._formatApiError(action, request22, data));
            }
            this.emit("response", { echo, action, params, request: request22, data });
          });
        });
      }
    };
    DEFAULT_WS_OPTIONS = {
      autoReconnect: true,
      reconnectInterval: 5e3,
      maxReconnectAttempts: 100,
      timeout: 1e4
    };
    OneBotWsClientManager = class {
      /**
       * 获取格式化之后的参数
       * @param options - 连接配置
       * @returns 格式化之后的参数
       */
      getOptions(options) {
        const mergedOptions = {
          ...DEFAULT_WS_OPTIONS,
          ...options,
          accessToken: options.accessToken ?? "",
          headers: options.headers ?? {},
          autoReconnect: options.autoReconnect ?? DEFAULT_WS_OPTIONS.autoReconnect,
          reconnectInterval: options.reconnectInterval ?? DEFAULT_WS_OPTIONS.reconnectInterval,
          maxReconnectAttempts: options.maxReconnectAttempts ?? DEFAULT_WS_OPTIONS.maxReconnectAttempts,
          timeout: options.timeout ?? DEFAULT_WS_OPTIONS.timeout
        };
        if (options.accessToken) {
          mergedOptions.headers["authorization"] = `Bearer ${options.accessToken}`;
        }
        return mergedOptions;
      }
      /**
       * 创建 OneBotWsClient 客户端实例
       * @param url - WebSocket URL
       * @param options - 配置选项
       * @returns OneBotWsClient客户端实例
       */
      async createClient(url, options) {
        const mergedOptions = this.getOptions(options);
        const socket = this.createWebSocket(url, mergedOptions);
        const client = new OneBotWsClient(socket, url, mergedOptions);
        return client;
      }
      /**
       * 创建 WebSocket 示例
       * @param url - WebSocket URL
       * @param options - 配置选项
       * @returns WebSocket客户端实例
       */
      createWebSocket(url, options) {
        const mergedOptions = this.getOptions(options);
        const socket = Object.keys(mergedOptions.headers || {}).length > 0 ? new WebSocket(url, { headers: mergedOptions.headers }) : new WebSocket(url);
        return socket;
      }
    };
    oneBotWsClientManager = new OneBotWsClientManager();
    OneBotWsClient = class extends OneBotWsBase {
      _options;
      /** 重连尝试次数 */
      _reconnectAttempts = 0;
      /** 连接URL */
      _url;
      constructor(socket, url, options) {
        super(socket, options);
        this._url = url;
        this._options = this.getOptions(options);
        this._setupEventListeners();
      }
      /**
       * 关闭之前的一些操作
       * @param type - 关闭事件类型
       */
      #close(type) {
        this.emit("close", type);
        this.removeAllListeners();
      }
      /**
       * 更新socket
       * @param socket - 新的socket
       * @returns 返回一个状态函数 请在处理设置socket相关后调用 否则close事件无法触发
       */
      setSocket(socket) {
        const status = super.setSocket(socket);
        this._setupEventListeners();
        return status;
      }
      /**
       * 获取当前URL
       */
      getUrl() {
        return this._url;
      }
      /**
       * 获取重连尝试次数
       */
      getReconnectAttempts() {
        return this._reconnectAttempts;
      }
      /**
       * 重置重连尝试次数
       */
      resetReconnectAttempts() {
        this._reconnectAttempts = 0;
      }
      /**
       * 是否已手动关闭
       */
      isManualClosed() {
        return this._manualClosed;
      }
      /**
       * 设置自动重连选项
       */
      setAutoReconnect(enable) {
        this._options.autoReconnect = enable;
      }
      /**
       * 设置重连间隔
       */
      setReconnectInterval(interval) {
        this._options.reconnectInterval = interval;
      }
      /**
       * 设置最大重连次数
       */
      setMaxReconnectAttempts(max) {
        this._options.maxReconnectAttempts = max;
      }
      /**
       * 获取格式化之后的参数
       * @param options - 连接配置
       * @returns 格式化之后的参数
       */
      getOptions(options) {
        const mergedOptions = {
          ...DEFAULT_WS_OPTIONS,
          ...options,
          accessToken: options.accessToken ?? "",
          headers: options.headers ?? {},
          autoReconnect: options.autoReconnect ?? DEFAULT_WS_OPTIONS.autoReconnect,
          reconnectInterval: options.reconnectInterval ?? DEFAULT_WS_OPTIONS.reconnectInterval,
          maxReconnectAttempts: options.maxReconnectAttempts ?? DEFAULT_WS_OPTIONS.maxReconnectAttempts,
          timeout: options.timeout ?? DEFAULT_WS_OPTIONS.timeout
        };
        if (options.accessToken) {
          mergedOptions.headers["authorization"] = `Bearer ${options.accessToken}`;
        }
        return mergedOptions;
      }
      /**
       * 重连
       * @param url - 连接URL
       * @param options - 连接配置 默认使用当前配置
       * @returns 是否重连成功
       */
      async reconnect(url, options = this._options) {
        this._manualClosed = false;
        this._options = this.getOptions(options);
        const _socket = oneBotWsClientManager.createWebSocket(url, options);
        this.setSocket(_socket)();
        return true;
      }
      /**
       * 设置事件监听器
       * @private
       */
      _setupEventListeners() {
        let isConnected = false;
        this._socket.removeAllListeners();
        this._socket.on("open", async () => {
          isConnected = true;
          this._reconnectAttempts = 0;
          this.emit(
            "open"
            /* OPEN */
          );
        });
        this._socket.on("close", () => {
          if (this._setSocket) return;
          if (this._manualClosed) return;
          if (this._options.autoReconnect) {
            if (isConnected) {
              this.#close(
                2003
                /* CONNECTION_FAILED */
              );
            }
            if (this._options.maxReconnectAttempts < 0) {
              this.emit("error", {
                error: new Error(`[OneBot] \u91CD\u8FDE\u6B21\u6570\u8FBE\u5230\u4E0A\u9650: ${this._url}`),
                type: 2004,
                totalReconnectAttempt: this._reconnectAttempts,
                maxReconnectAttempt: this._options.maxReconnectAttempts
              });
              this.#close(
                2001
                /* MAX_RETRIES */
              );
              return;
            }
            this._reconnectAttempts++;
            setTimeout(() => {
              this.reconnect(this._url, {
                ...this._options,
                maxReconnectAttempts: this._options.maxReconnectAttempts - 1
              });
            }, this._options.reconnectInterval);
            return;
          }
          this.emit(
            "close",
            1001
            /* ERROR */
          );
          this.removeAllListeners();
        });
        this._socket.on("error", (error) => {
          if (isConnected) {
            this.emit("error", {
              error,
              type: 1001
              /* ERROR */
            });
          } else {
            this.emit("error", {
              error,
              type: 2002,
              reconnectAttempt: this._reconnectAttempts,
              reconnectInterval: this._options.reconnectInterval,
              maxReconnectAttempt: this._options.maxReconnectAttempts
            });
          }
        });
        this._socket.on("message", (event) => {
          const raw2 = event.toString() || "{}";
          const data = JSON.parse(raw2);
          if (this.isEcho(data)) {
            this.emit(`echo:${data.echo}`, data);
            return;
          }
          this._dispatch(data);
        });
      }
    };
    OneBotWsServer = class extends OneBotWsBase {
      /** 请求对象 */
      _request;
      constructor(socket, request22, options) {
        super(socket, options);
        this._options = this.getOptions(options);
        this._request = request22;
      }
      async init() {
        this._setupEventListeners();
        await super.init();
      }
      /**
       * 关闭之前的一些操作
       * @param type - 关闭事件类型
       */
      #close(type) {
        this.emit("close", type);
        this.removeAllListeners();
      }
      /**
       * 更新socket
       */
      setSocket(socket) {
        const status = super.setSocket(socket);
        this._setupEventListeners();
        return status;
      }
      /**
       * 获取格式化之后的参数
       * @param options - 配置选项
       * @returns 格式化之后的参数
       */
      getOptions(options) {
        return {
          timeout: options.timeout ?? DEFAULT_WS_OPTIONS.timeout,
          accessToken: options.accessToken ?? ""
        };
      }
      /**
       * 获取客户端信息
       */
      getClientInfo() {
        return {
          ip: this._request.socket.remoteAddress,
          headers: this._request.headers
        };
      }
      /**
       * 获取请求对象
       */
      getRequest() {
        return this._request;
      }
      /**
       * 设置事件监听器
       * @private
       */
      _setupEventListeners() {
        this?._socket?.removeAllListeners();
        this.emit(
          "open"
          /* OPEN */
        );
        this._socket.on("close", () => {
          if (this._setSocket) return;
          if (this._manualClosed) return;
          this.#close(
            1001
            /* ERROR */
          );
        });
        this._socket.on("error", (error) => {
          this.emit("error", {
            error,
            type: 1001
            /* ERROR */
          });
        });
        this._socket.on("message", (event) => {
          const raw2 = event.toString() || "{}";
          const data = JSON.parse(raw2);
          if (this.isEcho(data)) {
            this.emit(`echo:${data.echo}`, data);
            return;
          }
          this._dispatch(data);
        });
        this._socket.on("error", (error) => {
          this.emit("error", {
            type: 1001,
            error
          });
        });
      }
    };
    OneBotWsServerManager = class {
      /**
       * 创建WebSocket服务端
       * @param socket - WebSocket实例
       * @param request - 请求
       * @param options - 配置选项
       * @returns OneBotWsServer服务端实例
       */
      createServer(socket, request22, options) {
        if (options?.accessToken) {
          const authHeader = request22.headers["authorization"];
          if (!authHeader) {
            socket.close(
              3002
              /* AUTH_INVALID_FORMAT */
            );
            throw new Error("WebSocket\u8FDE\u63A5\u9274\u6743\u5931\u8D25\uFF1A\u7F3A\u5C11Authorization\u5934");
          }
          const match = authHeader.match(/^Bearer\s+(.+)$/);
          if (!match) {
            socket.close(
              3002
              /* AUTH_INVALID_FORMAT */
            );
            throw new Error("WebSocket\u8FDE\u63A5\u9274\u6743\u5931\u8D25\uFF1AAuthorization\u5934\u683C\u5F0F\u9519\u8BEF");
          }
          const token = match[1];
          if (token !== options.accessToken) {
            socket.close(
              3001
              /* AUTH_FAILED */
            );
            throw new Error("WebSocket\u8FDE\u63A5\u9274\u6743\u5931\u8D25\uFF1A\u65E0\u6548\u7684Token");
          }
        }
        const server2 = new OneBotWsServer(socket, request22, options);
        return server2;
      }
    };
    oneBotWsServerManager = new OneBotWsServerManager();
    DEFAULT_OPTIONS = {
      /** 心跳 默认5000ms */
      heartbeat: 5e3,
      /** 最大重连次数 默认100次 */
      maxReconnectAttempts: 100,
      /** 超时时间 默认10000ms */
      timeout: 1e4
    };
    OneBotHttp = class _OneBotHttp extends OneBotCore {
      /** 是否已初始化 */
      _initialized = false;
      /** 心跳失败次数 */
      _heartbeatFailCount = 0;
      /** 配置 */
      _options;
      /** 心跳计时器 */
      _heartbeatInterval;
      constructor(options) {
        super(options);
        this._options = this.getOptions(options);
        this.self.id = options.self_id;
      }
      /**
       * 发送第一次心跳
       */
      async _sendFirstHeartbeat() {
        const { status, error } = await this._sendHeartbeat(true);
        if (!status) {
          this.emit("error", {
            type: 1001,
            error: new Error(`\u53D1\u9001\u7B2C\u4E00\u6B21\u5FC3\u8DF3\u5931\u8D25: \u8BF7\u68C0\u67E5\u76EE\u6807\u5730\u5740\u662F\u5426\u53EF\u8BBF\u95EE: ${this._options.httpHost}`, { cause: error })
          });
        }
      }
      /**
       * 获取格式化后的配置
       * @param options - 配置选项
       * @returns 内部配置
       */
      static getOptions(options) {
        const mergedOptions = {
          headers: {
            ...options.headers || {}
          },
          self_id: options.self_id,
          httpHost: options.httpHost,
          accessToken: options.accessToken || "",
          OneBotAccessToken: options.OneBotAccessToken || "",
          heartbeat: options.heartbeat || DEFAULT_OPTIONS.heartbeat,
          maxReconnectAttempts: options.maxReconnectAttempts || DEFAULT_OPTIONS.maxReconnectAttempts,
          timeout: options.timeout || DEFAULT_OPTIONS.timeout
        };
        if (mergedOptions.accessToken) {
          mergedOptions.headers.authorization = `Bearer ${mergedOptions.accessToken}`;
        }
        return mergedOptions;
      }
      /**
       * 获取格式化后的配置
       * @param options - 配置选项
       * @returns 内部配置
       */
      getOptions(options) {
        return _OneBotHttp.getOptions(options);
      }
      /**
       * 发送API请求
       * @param action - API动作
       * @param params - API参数
       * @param timeout - 超时时间
       * @returns 返回API响应 注意: 返回的是response.data，而不是response
       */
      async sendApi(action, params, timeout2 = this._options.timeout) {
        const host2 = `${this._options.httpHost}/${action}`;
        const request22 = JSON.stringify(params);
        this.emit("sendApi", { action, params, request: request22, echo: "" });
        const data = await http_default.post(host2, request22, { timeout: timeout2, headers: this._options.headers });
        if (data.data.status === "ok") {
          return data.data.data;
        } else {
          throw this._formatApiError(action, request22, data.data);
        }
      }
      /**
       * 发送心跳
       * @param isInit - 是否是初始化
       */
      async _sendHeartbeat(isInit2 = false) {
        try {
          await this.getVersionInfo();
          this._heartbeatFailCount = 0;
          return { status: true, error: null };
        } catch (error) {
          this._heartbeatFailCount++;
          if (isInit2) {
            this.emit(
              "close",
              3001
              /* HEARTBEAT_FAILED */
            );
            this._stopHeartbeat();
            this.removeAllListeners();
            return { status: false, error };
          }
          if (this._options.maxReconnectAttempts > 0) {
            this._options.maxReconnectAttempts--;
            this.emit("error", {
              error,
              type: 2002,
              maxReconnectAttempt: this._options.maxReconnectAttempts,
              reconnectAttempt: this._heartbeatFailCount,
              reconnectInterval: this._options.heartbeat
            });
            return { status: false, error };
          }
          this.emit("error", {
            error,
            type: 2004,
            totalReconnectAttempt: this._heartbeatFailCount,
            maxReconnectAttempt: this._options.maxReconnectAttempts
          });
          this.emit(
            "close",
            3002
            /* HEARTBEAT_FAILED_MAX_RETRIES */
          );
          this._stopHeartbeat();
          this.removeAllListeners();
          return { status: false, error };
        }
      }
      /**
       * 停止心跳
       */
      _stopHeartbeat() {
        if (this._heartbeatInterval) {
          clearInterval(this._heartbeatInterval);
          this._heartbeatInterval = void 0;
        }
      }
      /**
       * 开始心跳
       */
      _startHeartbeat() {
        this._stopHeartbeat();
        this._heartbeatInterval = setInterval(() => this._sendHeartbeat(), this._options.heartbeat);
      }
      /**
       * 初始化
       */
      async init() {
        if (this._initialized) return;
        await this._sendFirstHeartbeat();
        await this._initBotInfo();
        this._initialized = true;
        this._startHeartbeat();
        this.emit(
          "open"
          /* OPEN */
        );
      }
      /**
       * 关闭连接
       */
      close() {
        this._stopHeartbeat();
        this.emit(
          "close",
          1002
          /* MANUAL_CLOSE */
        );
        this.removeAllListeners();
      }
      /**
       * 更新配置
       * @param options 新配置
       */
      async updateOptions(options) {
        this._options = {
          self_id: this._options.self_id,
          accessToken: typeof options.accessToken !== "undefined" ? options.accessToken : this._options.accessToken,
          OneBotAccessToken: typeof options.OneBotAccessToken !== "undefined" ? options.OneBotAccessToken : this._options.OneBotAccessToken,
          httpHost: typeof options.httpHost !== "undefined" ? options.httpHost : this._options.httpHost,
          heartbeat: typeof options.heartbeat !== "undefined" ? options.heartbeat : this._options.heartbeat,
          maxReconnectAttempts: typeof options.maxReconnectAttempts !== "undefined" ? options.maxReconnectAttempts : this._options.maxReconnectAttempts,
          timeout: typeof options.timeout !== "undefined" ? options.timeout : this._options.timeout,
          headers: typeof options.headers !== "undefined" ? options.headers : this._options.headers
        };
        if (this._options.accessToken) {
          this._options.headers.authorization = `Bearer ${this._options.accessToken}`;
        }
        this._stopHeartbeat();
        this._startHeartbeat();
      }
      /**
       * 收到事件
       * @description 事件仅接受原始请求体，请不要使用JSON.parse(event)
       * @param event - 事件 原始请求体
       * @param headers - 头部
       */
      handleEvent(event, headers) {
        if (!this._initialized) return;
        const data = typeof event === "string" ? JSON.parse(event) : event;
        if (data.self_id !== this.self.id) {
          throw new Error(`[OneBot] \u6536\u5230\u4E8B\u4EF6\u7684self_id\u4E0E\u5F53\u524DBot\u7684self_id\u4E0D\u4E00\u81F4: ${data.self_id} !== ${this.self.id}`);
        }
        if (this.verifyEvent(event, headers)) {
          return this._dispatch(data);
        }
        throw new Error(`[OneBot] \u9274\u6743\u5931\u8D25: ${data?.self_id || this.self.id} x-signature: ${headers?.["x-signature"]}`);
      }
      /**
       * 校验一个事件是否合法
       * @param event - 事件
       * @param headers - 头部
       * @returns 是否合法
       */
      verifyEvent(event, headers) {
        if (!this._options.accessToken) {
          return true;
        }
        if (typeof headers !== "object" || !headers["x-signature"]) {
          return false;
        }
        const sign2 = `sha1=${createHmac("sha1", this._options.accessToken).update(event).digest("hex")}`;
        return sign2 === headers["x-signature"];
      }
      /**
       * 重新连接
       * @description 适用于产生close事件之后，需要重新使用当前实例
       * @description `温馨提示，所有on方法都需要重新注册`
       */
      async reconnect() {
        this._initialized = false;
        await this.init();
      }
    };
    OneBotMessageType = /* @__PURE__ */ ((OneBotMessageType2) => {
      OneBotMessageType2["Text"] = "text";
      OneBotMessageType2["Face"] = "face";
      OneBotMessageType2["Image"] = "image";
      OneBotMessageType2["Record"] = "record";
      OneBotMessageType2["Video"] = "video";
      OneBotMessageType2["At"] = "at";
      OneBotMessageType2["Rps"] = "rps";
      OneBotMessageType2["Dice"] = "dice";
      OneBotMessageType2["Shake"] = "shake";
      OneBotMessageType2["Poke"] = "poke";
      OneBotMessageType2["Anonymous"] = "anonymous";
      OneBotMessageType2["Share"] = "share";
      OneBotMessageType2["Contact"] = "contact";
      OneBotMessageType2["Location"] = "location";
      OneBotMessageType2["Music"] = "music";
      OneBotMessageType2["Reply"] = "reply";
      OneBotMessageType2["Forward"] = "forward";
      OneBotMessageType2["Node"] = "node";
      OneBotMessageType2["Xml"] = "xml";
      OneBotMessageType2["Json"] = "json";
      OneBotMessageType2["File"] = "file";
      OneBotMessageType2["Redbag"] = "redbag";
      OneBotMessageType2["Gift"] = "gift";
      OneBotMessageType2["Markdown"] = "markdown";
      return OneBotMessageType2;
    })(OneBotMessageType || {});
    OneBotHttpManager = class {
      /**
       * 创建HTTP客户端
       * @param options - 配置选项
       * @returns OneBotHttp客户端实例
       */
      createClient(options) {
        const mergedOptions = OneBotHttp.getOptions(options);
        const client = new OneBotHttp(mergedOptions);
        return client;
      }
    };
    oneBotHttpManager = new OneBotHttpManager();
  }
});
var formatLogString, buildError, convertOneBotMessageToKarin, AdapterConvertKarin, getFileMessage, fileToBase64, KarinConvertAdapter;
var init_convert = __esm({
  "src/adapter/onebot/core/convert.ts"() {
    init_message2();
    init_dist2();
    formatLogString = (str) => {
      return str.replace(/(["']?(?:base64|base):\/\/)[^"',}\s]*["']?/g, "$1...");
    };
    buildError = (selfId, action, request3, error) => {
      if (error) {
        const err = JSON.stringify(error, null, 2).replace(/\\n/g, "\n");
        return new Error(`[${selfId}][sendApi] \u8BF7\u6C42\u9519\u8BEF:
  action: ${action}
  params: ${formatLogString(request3)}
  error: ${err}}`);
      }
      logger.error(`[${selfId}][sendApi][\u8BF7\u6C42\u9519\u8BEF]:
  action: ${action}
  params: ${formatLogString(request3)}`);
    };
    convertOneBotMessageToKarin = async (message2, onebot) => {
      const handlers = {
        text: () => segment_exports.text(message2.data.text),
        face: () => segment_exports.face(Number(message2.data.id)),
        image: () => segment_exports.image(message2.data.url || message2.data.file, {
          ...message2.data,
          fileType: message2.data.type,
          fid: message2.data.fid,
          md5: message2.data.md5,
          size: message2.data.size,
          summary: message2.data.summary,
          width: message2.data.width,
          height: message2.data.height
        }),
        record: () => segment_exports.record(message2.data.url || message2.data.file, message2.data.magic === 1),
        video: () => segment_exports.video(message2.data.url || message2.data.file),
        at: () => segment_exports.at(message2.data.qq, message2.data.name),
        contact: () => segment_exports.contact(message2.data.type === "qq" ? "friend" : "group", message2.data.id),
        location: () => segment_exports.location(
          Number(message2.data.lat),
          Number(message2.data.lon),
          message2.data.title || "",
          message2.data.content || ""
        ),
        reply: () => segment_exports.reply(message2.data.id),
        json: () => segment_exports.json(message2.data.data),
        xml: () => segment_exports.xml(message2.data.data),
        file: async () => await getFileMessage(message2.data, onebot)
      };
      const handler3 = handlers[message2.type];
      return handler3 ? await handler3() : segment_exports.text(JSON.stringify(message2));
    };
    AdapterConvertKarin = async (data, onebot) => {
      if (!Array.isArray(data)) return [];
      const elements = [];
      try {
        for (const i of data) {
          const element = await convertOneBotMessageToKarin(i, onebot);
          elements.push(element);
        }
        return elements;
      } catch (error) {
        logger.error(new Error("[OneBot] \u6D88\u606F\u6BB5\u8F6C\u6362\u9519\u8BEF:", { cause: error }));
        return elements;
      }
    };
    getFileMessage = async (file2, adapter3) => {
      if ("file_name" in file2 && "file_hash" in file2) {
        return segment_exports.file(file2.url, {
          name: file2.file_name,
          hash: file2.file_hash,
          fid: file2.file_id
        });
      }
      if (Object.keys(file2).length === 3 && "file_size" in file2 && "file_id" in file2) {
        const { url, file_size: fileSize } = await adapter3._onebot.nc_getFile(file2.file_id);
        return segment_exports.file(url, {
          name: file2.file,
          size: Number(fileSize),
          fid: file2.file_id,
          hash: file2.file_hash
        });
      }
      return segment_exports.file(file2.file, { ...file2 });
    };
    fileToBase64 = (file2, url) => {
      if (typeof file2 !== "string") {
        throw new TypeError("\u6587\u4EF6\u4EC5\u652F\u6301 file:// http(s):// base64:// \u534F\u8BAE");
      }
      if (!url || !file2.startsWith("file://")) return file2;
      const list2 = ["127.0.0.1", "localhost"];
      const link = new URL(url);
      return list2.includes(link.hostname) ? file2 : `base64://${fs5.readFileSync(file2.replace("file://", "")).toString("base64")}`;
    };
    KarinConvertAdapter = (data, onebot) => {
      const elements = [];
      for (const i of data) {
        switch (i.type) {
          case "text":
            elements.push({ type: OneBotMessageType.Text, data: { text: i.text } });
            break;
          case "face":
            elements.push({ type: OneBotMessageType.Face, data: { id: i.id + "" } });
            break;
          case "at":
            elements.push({ type: OneBotMessageType.At, data: { qq: String(i.targetId), name: i.name } });
            break;
          case "reply":
            elements.push({ type: OneBotMessageType.Reply, data: { id: i.messageId } });
            break;
          case "image": {
            elements.push({
              type: OneBotMessageType.Image,
              data: {
                file: fileToBase64(i.file, onebot.adapter.address),
                md5: i.md5,
                size: i.size,
                width: i.width,
                height: i.height,
                fid: i.fid,
                summary: i.summary
              }
            });
            break;
          }
          case "video": {
            elements.push({ type: OneBotMessageType.Video, data: { file: i.file } });
            break;
          }
          case "json": {
            elements.push({ type: OneBotMessageType.Json, data: { data: i.data } });
            break;
          }
          case "xml": {
            elements.push({ type: OneBotMessageType.Xml, data: { data: i.data } });
            break;
          }
          case "record": {
            elements.push({
              type: OneBotMessageType.Record,
              data: {
                file: fileToBase64(i.file, onebot.adapter.address),
                magic: i.magic ?? false ? 1 : 0
              }
            });
            break;
          }
          case "music": {
            if (i.platform === "custom") {
              const { url, audio, title, author, pic } = i;
              elements.push({
                type: OneBotMessageType.Music,
                data: {
                  type: "custom",
                  url,
                  audio,
                  title,
                  content: author,
                  image: pic
                }
              });
            } else {
              elements.push({
                type: OneBotMessageType.Music,
                data: {
                  type: i.platform,
                  id: i.id
                }
              });
            }
            break;
          }
          // case OB11MessageType.Contact: {
          //   elements.push({ type, data: { type: i.scene, id: i.peer } })
          //   break
          // }
          // case OB11MessageType.Location: {
          //   elements.push({ type, data: { lat: i.lat, lon: i.lon, title: i.title, content: i.address } })
          //   break
          // }
          // case 'longMsg':
          // case 'basketball':
          // case 'marketFace': {
          //   elements.push({ type: 'marketFace', data: { id: i.id + '' } })
          //   break
          // }
          // case 'gift': {
          //   elements.push({ type: 'gift', data: { qq: i.qq, id: i.id } })
          //   break
          // }
          // case 'weather': {
          //   elements.push({ type: 'weather', data: { city: i.city, type: i.type } })
          //   break
          // }
          case "dice": {
            elements.push({ type: OneBotMessageType.Dice, data: { id: i.id } });
            break;
          }
          case "rps": {
            elements.push({ type: OneBotMessageType.Rps, data: {} });
            break;
          }
          case "share": {
            elements.push({ type: OneBotMessageType.Share, data: { url: i.url, title: i.title, content: i.content, image: i.image } });
            break;
          }
          case "raw":
            elements.push(i.data);
            break;
          case "node": {
            if (i.subType === "messageID") {
              elements.push({ type: OneBotMessageType.Forward, data: { id: i.messageId } });
            } else {
              elements.push({
                type: OneBotMessageType.Node,
                data: {
                  user_id: i.userId || onebot.selfId,
                  nickname: i.nickname || onebot.selfName,
                  content: KarinConvertAdapter(i.message, onebot)
                  // prompt: i?.options?.prompt,
                  // summary: i?.options?.summary,
                  // source: i?.options?.source,
                }
              });
            }
            break;
          }
          case "button":
          case "markdown":
          case "keyboard":
          default: {
            elements.push(i);
            break;
          }
        }
      }
      return elements;
    };
  }
});

// src/event/handler/other/cd.ts
var userCD, groupCD, groupUserCD, privateCD, groupsCD, noticeRequestCD;
var init_cd = __esm({
  "src/event/handler/other/cd.ts"() {
    userCD = {};
    groupCD = {};
    groupUserCD = {};
    privateCD = (eventCfg, key) => {
      if (userCD[key]) {
        return false;
      }
      if (eventCfg?.cd > 0) {
        userCD[key] = setTimeout(() => {
          delete userCD[key];
        }, eventCfg?.cd * 1e3);
      }
      return true;
    };
    groupsCD = (eventCfg, groupKey, userKey) => {
      if (groupCD[groupKey] || groupUserCD[userKey]) {
        return false;
      }
      if (eventCfg?.cd > 0) {
        groupCD[groupKey] = setTimeout(() => {
          delete groupCD[groupKey];
        }, eventCfg?.cd * 1e3);
      }
      if (eventCfg?.userCD > 0) {
        groupUserCD[userKey] = setTimeout(() => {
          delete groupUserCD[userKey];
        }, eventCfg?.userCD * 1e3);
      }
      return true;
    };
    noticeRequestCD = (ctx3, config3, key) => {
      const list2 = [
        "frientPoke",
        "receiveLike",
        "groupPoke",
        "groupMessageReaction"
      ];
      if (!list2.includes(ctx3.subEvent)) {
        return true;
      }
      if (userCD[key]) {
        return false;
      }
      if (config3?.cd > 0) {
        userCD[key] = setTimeout(() => {
          delete userCD[key];
        }, config3?.cd * 1e3);
      }
      return true;
    };
  }
});

// src/utils/config/tools.ts
var formatArray, initCount, formatObject, createCount, getCacheCfg, clearCache;
var init_tools = __esm({
  "src/utils/config/tools.ts"() {
    formatArray = (data) => {
      try {
        return data.map((v) => String(v)) || [];
      } catch {
        return [];
      }
    };
    initCount = (count3, key) => {
      if (!count3[key]) {
        count3[key] = { start: 0, count: 1 };
      } else {
        count3[key].count++;
      }
    };
    formatObject = (data) => {
      const list2 = {};
      Object.entries(data).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          list2[key] = formatArray(value);
          return;
        }
        if (typeof value === "object") {
          list2[key] = formatObject(value);
          return;
        }
        list2[key] = value;
      });
      return list2;
    };
    createCount = () => {
      return {};
    };
    getCacheCfg = (cache10, count3, keys) => {
      const key = keys[0];
      if (cache10[key]) {
        initCount(count3, key);
        return cache10[key];
      }
      for (let i = 0; i < keys.length; i++) {
        const v = keys[i];
        if (!cache10[v]) {
          continue;
        }
        if (i === 0 && v === key) {
          initCount(count3, v);
          return cache10[v];
        }
        if (v === key) {
          initCount(count3, v);
          return cache10[v];
        }
        cache10[key] = cache10[v];
        initCount(count3, key);
        return cache10[key];
      }
      return cache10.default;
    };
    clearCache = (count3, staticCache3, dynamicCache3) => {
      setInterval(() => {
        Object.keys(count3).forEach((key) => {
          if (count3[key].count - count3[key].start < 10) {
            if (staticCache3[key]) {
              delete count3[key];
              return;
            }
            delete count3[key];
            delete dynamicCache3[key];
          } else {
            count3[key].start = count3[key].count;
          }
        });
      }, 6e4);
    };
  }
});
function _mergeNamespaces2(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = require$$02;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
function requireDataStream() {
  if (hasRequiredDataStream) return dataStream;
  hasRequiredDataStream = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var Stream = require$$32;
  var util7 = require$$5;
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  }
  util7.inherits(DataStream, Stream);
  DataStream.prototype.write = function write2(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  dataStream = DataStream;
  return dataStream;
}
function requireBufferEqualConstantTime() {
  if (hasRequiredBufferEqualConstantTime) return bufferEqualConstantTime;
  hasRequiredBufferEqualConstantTime = 1;
  var Buffer2 = require$$02.Buffer;
  var SlowBuffer = require$$02.SlowBuffer;
  bufferEqualConstantTime = bufferEq;
  function bufferEq(a, b) {
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i = 0; i < a.length; i++) {
      c |= a[i] ^ b[i];
    }
    return c === 0;
  }
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
  return bufferEqualConstantTime;
}
function requireParamBytesForAlg() {
  if (hasRequiredParamBytesForAlg) return paramBytesForAlg_1;
  hasRequiredParamBytesForAlg = 1;
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  paramBytesForAlg_1 = getParamBytesForAlg;
  return paramBytesForAlg_1;
}
function requireEcdsaSigFormatter() {
  if (hasRequiredEcdsaSigFormatter) return ecdsaSigFormatter;
  hasRequiredEcdsaSigFormatter = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var getParamBytesForAlg = requireParamBytesForAlg();
  var MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base642) {
    return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if ("string" === typeof signature) {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0; offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset; offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start3, stop) {
    var padding = 0;
    while (start3 + padding < stop && buf[start3 + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start3 + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  ecdsaSigFormatter = {
    derToJose,
    joseToDer
  };
  return ecdsaSigFormatter;
}
function requireJwa() {
  if (hasRequiredJwa) return jwa;
  hasRequiredJwa = 1;
  var bufferEqual = requireBufferEqualConstantTime();
  var Buffer2 = requireSafeBuffer().Buffer;
  var crypto9 = require$$22;
  var formatEcdsa = requireEcdsaSigFormatter();
  var util7 = require$$5;
  var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto9.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  function checkIsPublicKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base642) {
    return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i = 0; i < padding; ++i) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function typeError(template2) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util7.format.bind(util7, template2).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === "string";
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits) {
    return function sign2(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto9.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  }
  function createHmacVerifier(bits) {
    return function verify2(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  }
  function createKeySigner(bits) {
    return function sign2(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto9.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits) {
    return function verify2(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto9.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  }
  function createPSSKeySigner(bits) {
    return function sign2(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto9.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto9.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto9.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits) {
    return function verify2(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto9.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto9.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto9.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  }
  function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign2() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  }
  function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify2(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign2() {
      return "";
    };
  }
  function createNoneVerifier() {
    return function verify2(thing, signature) {
      return signature === "";
    };
  }
  jwa = function jwa2(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
  return jwa;
}
function requireTostring() {
  if (hasRequiredTostring) return tostring;
  hasRequiredTostring = 1;
  var Buffer2 = require$$02.Buffer;
  tostring = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer2.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
  return tostring;
}
function requireSignStream() {
  if (hasRequiredSignStream) return signStream;
  hasRequiredSignStream = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var DataStream = requireDataStream();
  var jwa2 = requireJwa();
  var Stream = require$$32;
  var toString = requireTostring();
  var util7 = require$$5;
  function base64url(string, encoding) {
    return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString(header), "binary");
    var encodedPayload = base64url(toString(payload), encoding);
    return util7.format("%s.%s", encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa2(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util7.format("%s.%s", securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  }
  util7.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign2() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  signStream = SignStream;
  return signStream;
}
function requireVerifyStream() {
  if (hasRequiredVerifyStream) return verifyStream;
  hasRequiredVerifyStream = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var DataStream = requireDataStream();
  var jwa2 = requireJwa();
  var Stream = require$$32;
  var toString = requireTostring();
  var util7 = require$$5;
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  }
  function safeJsonParse(thing) {
    if (isObject(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return void 0;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer2.from(payload, "base64").toString(encoding);
  }
  function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa2(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  }
  util7.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify2() {
    try {
      var valid2 = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid2, obj);
      this.emit("data", valid2);
      this.emit("end");
      this.readable = false;
      return valid2;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  verifyStream = VerifyStream;
  return verifyStream;
}
function requireJws() {
  if (hasRequiredJws) return jws;
  hasRequiredJws = 1;
  var SignStream = requireSignStream();
  var VerifyStream = requireVerifyStream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  jws.ALGORITHMS = ALGORITHMS;
  jws.sign = SignStream.sign;
  jws.verify = VerifyStream.verify;
  jws.decode = VerifyStream.decode;
  jws.isValid = VerifyStream.isValid;
  jws.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  jws.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
  return jws;
}
function requireDecode() {
  if (hasRequiredDecode) return decode;
  hasRequiredDecode = 1;
  var jws2 = requireJws();
  decode = function(jwt, options) {
    options = options || {};
    var decoded = jws2.decode(jwt, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === "string") {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === "object") {
          payload = obj;
        }
      } catch (e) {
      }
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature
      };
    }
    return payload;
  };
  return decode;
}
function requireJsonWebTokenError() {
  if (hasRequiredJsonWebTokenError) return JsonWebTokenError_1;
  hasRequiredJsonWebTokenError = 1;
  var JsonWebTokenError = function(message2, error) {
    Error.call(this, message2);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message2;
    if (error) this.inner = error;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  JsonWebTokenError_1 = JsonWebTokenError;
  return JsonWebTokenError_1;
}
function requireNotBeforeError() {
  if (hasRequiredNotBeforeError) return NotBeforeError_1;
  hasRequiredNotBeforeError = 1;
  var JsonWebTokenError = requireJsonWebTokenError();
  var NotBeforeError = function(message2, date) {
    JsonWebTokenError.call(this, message2);
    this.name = "NotBeforeError";
    this.date = date;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  NotBeforeError_1 = NotBeforeError;
  return NotBeforeError_1;
}
function requireTokenExpiredError() {
  if (hasRequiredTokenExpiredError) return TokenExpiredError_1;
  hasRequiredTokenExpiredError = 1;
  var JsonWebTokenError = requireJsonWebTokenError();
  var TokenExpiredError = function(message2, expiredAt) {
    JsonWebTokenError.call(this, message2);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  TokenExpiredError_1 = TokenExpiredError;
  return TokenExpiredError_1;
}
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
function requireTimespan() {
  if (hasRequiredTimespan) return timespan;
  hasRequiredTimespan = 1;
  var ms2 = requireMs();
  timespan = function(time2, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1e3);
    if (typeof time2 === "string") {
      var milliseconds = ms2(time2);
      if (typeof milliseconds === "undefined") {
        return;
      }
      return Math.floor(timestamp + milliseconds / 1e3);
    } else if (typeof time2 === "number") {
      return timestamp + time2;
    } else {
      return;
    }
  };
  return timespan;
}
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants;
}
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  const debug3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug3;
  return debug_1;
}
function requireRe() {
  if (hasRequiredRe) return re.exports;
  hasRequiredRe = 1;
  (function(module, exports) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug3 = requireDebug();
    exports = module.exports = {};
    const re2 = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src = exports.src = [];
    const safeSrc = exports.safeSrc = [];
    const t = exports.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index22 = R++;
      debug3(name, index22, value);
      t[name] = index22;
      src[index22] = value;
      safeSrc[index22] = safe;
      re2[index22] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index22] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re, re.exports);
  return re.exports;
}
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
function requireSemver$1() {
  if (hasRequiredSemver$1) return semver$1;
  hasRequiredSemver$1 = 1;
  const debug3 = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re2, safeSrc: src, t } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug3("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other2) {
      debug3("SemVer.compare", this.version, this.options, other2);
      if (!(other2 instanceof SemVer)) {
        if (typeof other2 === "string" && other2 === this.version) {
          return 0;
        }
        other2 = new SemVer(other2, this.options);
      }
      if (other2.version === this.version) {
        return 0;
      }
      return this.compareMain(other2) || this.comparePre(other2);
    }
    compareMain(other2) {
      if (!(other2 instanceof SemVer)) {
        other2 = new SemVer(other2, this.options);
      }
      return compareIdentifiers(this.major, other2.major) || compareIdentifiers(this.minor, other2.minor) || compareIdentifiers(this.patch, other2.patch);
    }
    comparePre(other2) {
      if (!(other2 instanceof SemVer)) {
        other2 = new SemVer(other2, this.options);
      }
      if (this.prerelease.length && !other2.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other2.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other2.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other2.prerelease[i];
        debug3("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other2) {
      if (!(other2 instanceof SemVer)) {
        other2 = new SemVer(other2, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other2.build[i];
        debug3("build compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
          const match = `-${identifier}`.match(r);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver$1 = SemVer;
  return semver$1;
}
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const SemVer = requireSemver$1();
  const parse2 = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  parse_1 = parse2;
  return parse_1;
}
function requireValid$1() {
  if (hasRequiredValid$1) return valid_1;
  hasRequiredValid$1 = 1;
  const parse2 = requireParse();
  const valid2 = (version2, options) => {
    const v = parse2(version2, options);
    return v ? v.version : null;
  };
  valid_1 = valid2;
  return valid_1;
}
function requireClean() {
  if (hasRequiredClean) return clean_1;
  hasRequiredClean = 1;
  const parse2 = requireParse();
  const clean = (version2, options) => {
    const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  clean_1 = clean;
  return clean_1;
}
function requireInc() {
  if (hasRequiredInc) return inc_1;
  hasRequiredInc = 1;
  const SemVer = requireSemver$1();
  const inc = (version2, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(
        version2 instanceof SemVer ? version2.version : version2,
        options
      ).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  inc_1 = inc;
  return inc_1;
}
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  const parse2 = requireParse();
  const diff = (version1, version2) => {
    const v1 = parse2(version1, null, true);
    const v2 = parse2(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  diff_1 = diff;
  return diff_1;
}
function requireMajor() {
  if (hasRequiredMajor) return major_1;
  hasRequiredMajor = 1;
  const SemVer = requireSemver$1();
  const major = (a, loose) => new SemVer(a, loose).major;
  major_1 = major;
  return major_1;
}
function requireMinor() {
  if (hasRequiredMinor) return minor_1;
  hasRequiredMinor = 1;
  const SemVer = requireSemver$1();
  const minor = (a, loose) => new SemVer(a, loose).minor;
  minor_1 = minor;
  return minor_1;
}
function requirePatch() {
  if (hasRequiredPatch) return patch_1;
  hasRequiredPatch = 1;
  const SemVer = requireSemver$1();
  const patch = (a, loose) => new SemVer(a, loose).patch;
  patch_1 = patch;
  return patch_1;
}
function requirePrerelease() {
  if (hasRequiredPrerelease) return prerelease_1;
  hasRequiredPrerelease = 1;
  const parse2 = requireParse();
  const prerelease = (version2, options) => {
    const parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  prerelease_1 = prerelease;
  return prerelease_1;
}
function requireCompare() {
  if (hasRequiredCompare) return compare_1;
  hasRequiredCompare = 1;
  const SemVer = requireSemver$1();
  const compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  compare_1 = compare;
  return compare_1;
}
function requireRcompare() {
  if (hasRequiredRcompare) return rcompare_1;
  hasRequiredRcompare = 1;
  const compare = requireCompare();
  const rcompare = (a, b, loose) => compare(b, a, loose);
  rcompare_1 = rcompare;
  return rcompare_1;
}
function requireCompareLoose() {
  if (hasRequiredCompareLoose) return compareLoose_1;
  hasRequiredCompareLoose = 1;
  const compare = requireCompare();
  const compareLoose = (a, b) => compare(a, b, true);
  compareLoose_1 = compareLoose;
  return compareLoose_1;
}
function requireCompareBuild() {
  if (hasRequiredCompareBuild) return compareBuild_1;
  hasRequiredCompareBuild = 1;
  const SemVer = requireSemver$1();
  const compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  compareBuild_1 = compareBuild;
  return compareBuild_1;
}
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  const compareBuild = requireCompareBuild();
  const sort = (list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose));
  sort_1 = sort;
  return sort_1;
}
function requireRsort() {
  if (hasRequiredRsort) return rsort_1;
  hasRequiredRsort = 1;
  const compareBuild = requireCompareBuild();
  const rsort = (list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose));
  rsort_1 = rsort;
  return rsort_1;
}
function requireGt() {
  if (hasRequiredGt) return gt_1;
  hasRequiredGt = 1;
  const compare = requireCompare();
  const gt = (a, b, loose) => compare(a, b, loose) > 0;
  gt_1 = gt;
  return gt_1;
}
function requireLt() {
  if (hasRequiredLt) return lt_1;
  hasRequiredLt = 1;
  const compare = requireCompare();
  const lt = (a, b, loose) => compare(a, b, loose) < 0;
  lt_1 = lt;
  return lt_1;
}
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  const compare = requireCompare();
  const eq = (a, b, loose) => compare(a, b, loose) === 0;
  eq_1 = eq;
  return eq_1;
}
function requireNeq() {
  if (hasRequiredNeq) return neq_1;
  hasRequiredNeq = 1;
  const compare = requireCompare();
  const neq = (a, b, loose) => compare(a, b, loose) !== 0;
  neq_1 = neq;
  return neq_1;
}
function requireGte() {
  if (hasRequiredGte) return gte_1;
  hasRequiredGte = 1;
  const compare = requireCompare();
  const gte = (a, b, loose) => compare(a, b, loose) >= 0;
  gte_1 = gte;
  return gte_1;
}
function requireLte() {
  if (hasRequiredLte) return lte_1;
  hasRequiredLte = 1;
  const compare = requireCompare();
  const lte = (a, b, loose) => compare(a, b, loose) <= 0;
  lte_1 = lte;
  return lte_1;
}
function requireCmp() {
  if (hasRequiredCmp) return cmp_1;
  hasRequiredCmp = 1;
  const eq = requireEq();
  const neq = requireNeq();
  const gt = requireGt();
  const gte = requireGte();
  const lt = requireLt();
  const lte = requireLte();
  const cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  cmp_1 = cmp;
  return cmp_1;
}
function requireCoerce() {
  if (hasRequiredCoerce) return coerce_1;
  hasRequiredCoerce = 1;
  const SemVer = requireSemver$1();
  const parse2 = requireParse();
  const { safeRe: re2, t } = requireRe();
  const coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  coerce_1 = coerce;
  return coerce_1;
}
function requireLrucache() {
  if (hasRequiredLrucache) return lrucache;
  hasRequiredLrucache = 1;
  class LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key) {
      const value = this.map.get(key);
      if (value === void 0) {
        return void 0;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  lrucache = LRUCache;
  return lrucache;
}
function requireRange() {
  if (hasRequiredRange) return range2;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range {
    constructor(range22, options) {
      options = parseOptions(options);
      if (range22 instanceof Range) {
        if (range22.loose === !!options.loose && range22.includePrerelease === !!options.includePrerelease) {
          return range22;
        } else {
          return new Range(range22.raw, options);
        }
      }
      if (range22 instanceof Comparator) {
        this.raw = range22.value;
        this.set = [[range22]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range22.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range22) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range22;
      const cached = cache10.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
      range22 = range22.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug3("hyphen replace", range22);
      range22 = range22.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
      debug3("comparator trim", range22);
      range22 = range22.replace(re2[t.TILDETRIM], tildeTrimReplace);
      debug3("tilde trim", range22);
      range22 = range22.replace(re2[t.CARETTRIM], caretTrimReplace);
      debug3("caret trim", range22);
      let rangeList = range22.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug3("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t.COMPARATORLOOSE]);
        });
      }
      debug3("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache10.set(memoKey, result);
      return result;
    }
    intersects(range22, options) {
      if (!(range22 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range22.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range2 = Range;
  const LRU = requireLrucache();
  const cache10 = new LRU();
  const parseOptions = requireParseOptions();
  const Comparator = requireComparator();
  const debug3 = requireDebug();
  const SemVer = requireSemver$1();
  const {
    safeRe: re2,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug3("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug3("caret", comp);
    comp = replaceTildes(comp, options);
    debug3("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug3("xrange", comp);
    comp = replaceStars(comp, options);
    debug3("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug3("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug3("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug3("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug3("caret", comp, options);
    const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug3("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug3("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug3("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug3("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug3("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug3("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug3("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug3("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug3("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version2, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug3(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range2;
}
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY = Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug3("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug3("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug3("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator;
  const parseOptions = requireParseOptions();
  const { safeRe: re2, t } = requireRe();
  const cmp = requireCmp();
  const debug3 = requireDebug();
  const SemVer = requireSemver$1();
  const Range = requireRange();
  return comparator;
}
function requireSatisfies() {
  if (hasRequiredSatisfies) return satisfies_1;
  hasRequiredSatisfies = 1;
  const Range = requireRange();
  const satisfies2 = (version2, range22, options) => {
    try {
      range22 = new Range(range22, options);
    } catch (er) {
      return false;
    }
    return range22.test(version2);
  };
  satisfies_1 = satisfies2;
  return satisfies_1;
}
function requireToComparators() {
  if (hasRequiredToComparators) return toComparators_1;
  hasRequiredToComparators = 1;
  const Range = requireRange();
  const toComparators = (range22, options) => new Range(range22, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  toComparators_1 = toComparators;
  return toComparators_1;
}
function requireMaxSatisfying() {
  if (hasRequiredMaxSatisfying) return maxSatisfying_1;
  hasRequiredMaxSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const maxSatisfying = (versions, range22, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range22, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  maxSatisfying_1 = maxSatisfying;
  return maxSatisfying_1;
}
function requireMinSatisfying() {
  if (hasRequiredMinSatisfying) return minSatisfying_1;
  hasRequiredMinSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const minSatisfying = (versions, range22, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range22, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  minSatisfying_1 = minSatisfying;
  return minSatisfying_1;
}
function requireMinVersion() {
  if (hasRequiredMinVersion) return minVersion_1;
  hasRequiredMinVersion = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const gt = requireGt();
  const minVersion = (range22, loose) => {
    range22 = new Range(range22, loose);
    let minver = new SemVer("0.0.0");
    if (range22.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range22.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range22.set.length; ++i) {
      const comparators = range22.set[i];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          /* fallthrough */
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range22.test(minver)) {
      return minver;
    }
    return null;
  };
  minVersion_1 = minVersion;
  return minVersion_1;
}
function requireValid() {
  if (hasRequiredValid) return valid;
  hasRequiredValid = 1;
  const Range = requireRange();
  const validRange = (range22, options) => {
    try {
      return new Range(range22, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  valid = validRange;
  return valid;
}
function requireOutside() {
  if (hasRequiredOutside) return outside_1;
  hasRequiredOutside = 1;
  const SemVer = requireSemver$1();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const Range = requireRange();
  const satisfies2 = requireSatisfies();
  const gt = requireGt();
  const lt = requireLt();
  const lte = requireLte();
  const gte = requireGte();
  const outside = (version2, range22, hilo, options) => {
    version2 = new SemVer(version2, options);
    range22 = new Range(range22, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies2(version2, range22, options)) {
      return false;
    }
    for (let i = 0; i < range22.set.length; ++i) {
      const comparators = range22.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY) {
          comparator2 = new Comparator(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  outside_1 = outside;
  return outside_1;
}
function requireGtr() {
  if (hasRequiredGtr) return gtr_1;
  hasRequiredGtr = 1;
  const outside = requireOutside();
  const gtr = (version2, range22, options) => outside(version2, range22, ">", options);
  gtr_1 = gtr;
  return gtr_1;
}
function requireLtr() {
  if (hasRequiredLtr) return ltr_1;
  hasRequiredLtr = 1;
  const outside = requireOutside();
  const ltr = (version2, range22, options) => outside(version2, range22, "<", options);
  ltr_1 = ltr;
  return ltr_1;
}
function requireIntersects() {
  if (hasRequiredIntersects) return intersects_1;
  hasRequiredIntersects = 1;
  const Range = requireRange();
  const intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  intersects_1 = intersects;
  return intersects_1;
}
function requireSimplify() {
  if (hasRequiredSimplify) return simplify;
  hasRequiredSimplify = 1;
  const satisfies2 = requireSatisfies();
  const compare = requireCompare();
  simplify = (versions, range22, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies2(version2, range22, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range22.raw === "string" ? range22.raw : String(range22);
    return simplified.length < original.length ? simplified : range22;
  };
  return simplify;
}
function requireSubset() {
  if (hasRequiredSubset) return subset_1;
  hasRequiredSubset = 1;
  const Range = requireRange();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const satisfies2 = requireSatisfies();
  const compare = requireCompare();
  const subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
    return true;
  };
  const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  const minimumVersion = [new Comparator(">=0.0.0")];
  const simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = /* @__PURE__ */ new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies2(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies2(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies2(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  const higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  const lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  subset_1 = subset;
  return subset_1;
}
function requireSemver() {
  if (hasRequiredSemver) return semver;
  hasRequiredSemver = 1;
  const internalRe = requireRe();
  const constants2 = requireConstants();
  const SemVer = requireSemver$1();
  const identifiers2 = requireIdentifiers();
  const parse2 = requireParse();
  const valid2 = requireValid$1();
  const clean = requireClean();
  const inc = requireInc();
  const diff = requireDiff();
  const major = requireMajor();
  const minor = requireMinor();
  const patch = requirePatch();
  const prerelease = requirePrerelease();
  const compare = requireCompare();
  const rcompare = requireRcompare();
  const compareLoose = requireCompareLoose();
  const compareBuild = requireCompareBuild();
  const sort = requireSort();
  const rsort = requireRsort();
  const gt = requireGt();
  const lt = requireLt();
  const eq = requireEq();
  const neq = requireNeq();
  const gte = requireGte();
  const lte = requireLte();
  const cmp = requireCmp();
  const coerce = requireCoerce();
  const Comparator = requireComparator();
  const Range = requireRange();
  const satisfies2 = requireSatisfies();
  const toComparators = requireToComparators();
  const maxSatisfying = requireMaxSatisfying();
  const minSatisfying = requireMinSatisfying();
  const minVersion = requireMinVersion();
  const validRange = requireValid();
  const outside = requireOutside();
  const gtr = requireGtr();
  const ltr = requireLtr();
  const intersects = requireIntersects();
  const simplifyRange = requireSimplify();
  const subset = requireSubset();
  semver = {
    parse: parse2,
    valid: valid2,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies: satisfies2,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants2.RELEASE_TYPES,
    compareIdentifiers: identifiers2.compareIdentifiers,
    rcompareIdentifiers: identifiers2.rcompareIdentifiers
  };
  return semver;
}
function requireAsymmetricKeyDetailsSupported() {
  if (hasRequiredAsymmetricKeyDetailsSupported) return asymmetricKeyDetailsSupported;
  hasRequiredAsymmetricKeyDetailsSupported = 1;
  const semver2 = requireSemver();
  asymmetricKeyDetailsSupported = semver2.satisfies(process.version, ">=15.7.0");
  return asymmetricKeyDetailsSupported;
}
function requireRsaPssKeyDetailsSupported() {
  if (hasRequiredRsaPssKeyDetailsSupported) return rsaPssKeyDetailsSupported;
  hasRequiredRsaPssKeyDetailsSupported = 1;
  const semver2 = requireSemver();
  rsaPssKeyDetailsSupported = semver2.satisfies(process.version, ">=16.9.0");
  return rsaPssKeyDetailsSupported;
}
function requireValidateAsymmetricKey() {
  if (hasRequiredValidateAsymmetricKey) return validateAsymmetricKey;
  hasRequiredValidateAsymmetricKey = 1;
  const ASYMMETRIC_KEY_DETAILS_SUPPORTED = requireAsymmetricKeyDetailsSupported();
  const RSA_PSS_KEY_DETAILS_SUPPORTED = requireRsaPssKeyDetailsSupported();
  const allowedAlgorithmsForKeys = {
    "ec": ["ES256", "ES384", "ES512"],
    "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
    "rsa-pss": ["PS256", "PS384", "PS512"]
  };
  const allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
  };
  validateAsymmetricKey = function(algorithm, key) {
    if (!algorithm || !key) return;
    const keyType = key.asymmetricKeyType;
    if (!keyType) return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
      throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
      throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
      switch (keyType) {
        case "ec":
          const keyCurve = key.asymmetricKeyDetails.namedCurve;
          const allowedCurve = allowedCurves[algorithm];
          if (keyCurve !== allowedCurve) {
            throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
          }
          break;
        case "rsa-pss":
          if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
            const length = parseInt(algorithm.slice(-3), 10);
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
            }
            if (saltLength !== void 0 && saltLength > length >> 3) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
            }
          }
          break;
      }
    }
  };
  return validateAsymmetricKey;
}
function requirePsSupported() {
  if (hasRequiredPsSupported) return psSupported;
  hasRequiredPsSupported = 1;
  var semver2 = requireSemver();
  psSupported = semver2.satisfies(process.version, "^6.12.0 || >=8.0.0");
  return psSupported;
}
function requireVerify() {
  if (hasRequiredVerify) return verify;
  hasRequiredVerify = 1;
  const JsonWebTokenError = requireJsonWebTokenError();
  const NotBeforeError = requireNotBeforeError();
  const TokenExpiredError = requireTokenExpiredError();
  const decode2 = requireDecode();
  const timespan2 = requireTimespan();
  const validateAsymmetricKey2 = requireValidateAsymmetricKey();
  const PS_SUPPORTED = requirePsSupported();
  const jws2 = requireJws();
  const { KeyObject, createSecretKey, createPublicKey } = require$$22;
  const PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
  const EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
  const RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
  const HS_ALGS = ["HS256", "HS384", "HS512"];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  }
  verify = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    let done;
    if (callback) {
      done = callback;
    } else {
      done = function(err, data) {
        if (err) throw err;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
      return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
      return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
      return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
    if (!jwtString) {
      return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
      return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
      return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
      decodedToken = decode2(jwtString, { complete: true });
    } catch (err) {
      return done(err);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
      if (!callback) {
        return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function(header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function(err, secretOrPublicKey2) {
      if (err) {
        return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
      }
      const hasSignature = parts[2].trim() !== "";
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!hasSignature && !options.algorithms) {
        return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
      }
      if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
        try {
          secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
        } catch (_) {
          try {
            secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
          } catch (_2) {
            return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
          }
        }
      }
      if (!options.algorithms) {
        if (secretOrPublicKey2.type === "secret") {
          options.algorithms = HS_ALGS;
        } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
          options.algorithms = RSA_KEY_ALGS;
        } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
          options.algorithms = EC_KEY_ALGS;
        } else {
          options.algorithms = PUB_KEY_ALGS;
        }
      }
      if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey2(header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
      }
      let valid2;
      try {
        valid2 = jws2.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
      } catch (e) {
        return done(e);
      }
      if (!valid2) {
        return done(new JsonWebTokenError("invalid signature"));
      }
      const payload = decodedToken.payload;
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
        }
      }
      if (options.audience) {
        const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        const match = target.some(function(targetAudience) {
          return audiences.some(function(audience) {
            return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
          });
        });
        if (!match) {
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
        }
      }
      if (options.issuer) {
        const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        const maxAgeTimestamp = timespan2(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === "undefined") {
          return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
        }
      }
      if (options.complete === true) {
        const signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature
        });
      }
      return done(null, payload);
    });
  };
  return verify;
}
function requireLodash_includes() {
  if (hasRequiredLodash_includes) return lodash_includes;
  hasRequiredLodash_includes = 1;
  var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
  var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  function arrayMap(array, iteratee) {
    var index22 = -1, length = array ? array.length : 0, result = Array(length);
    while (++index22 < length) {
      result[index22] = iteratee(array[index22], index22, array);
    }
    return result;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index22 = fromIndex + -1;
    while (++index22 < length) {
      if (predicate(array[index22], index22, array)) {
        return index22;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index22 = fromIndex - 1, length = array.length;
    while (++index22 < length) {
      if (array[index22] === value) {
        return index22;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function baseTimes(n, iteratee) {
    var index22 = -1, result = Array(n);
    while (++index22 < n) {
      result[index22] = iteratee(index22);
    }
    return result;
  }
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if (hasOwnProperty.call(value, key) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -Infinity) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other2 = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other2) ? other2 + "" : other2;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function values(object) {
    return object ? baseValues(object, keys(object)) : [];
  }
  lodash_includes = includes;
  return lodash_includes;
}
function requireLodash_isboolean() {
  if (hasRequiredLodash_isboolean) return lodash_isboolean;
  hasRequiredLodash_isboolean = 1;
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  lodash_isboolean = isBoolean;
  return lodash_isboolean;
}
function requireLodash_isinteger() {
  if (hasRequiredLodash_isinteger) return lodash_isinteger;
  hasRequiredLodash_isinteger = 1;
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isInteger(value) {
    return typeof value == "number" && value == toInteger(value);
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -Infinity) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other2 = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other2) ? other2 + "" : other2;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  lodash_isinteger = isInteger;
  return lodash_isinteger;
}
function requireLodash_isnumber() {
  if (hasRequiredLodash_isnumber) return lodash_isnumber;
  hasRequiredLodash_isnumber = 1;
  var numberTag = "[object Number]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isNumber2(value) {
    return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
  }
  lodash_isnumber = isNumber2;
  return lodash_isnumber;
}
function requireLodash_isplainobject() {
  if (hasRequiredLodash_isplainobject) return lodash_isplainobject;
  hasRequiredLodash_isplainobject = 1;
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  lodash_isplainobject = isPlainObject;
  return lodash_isplainobject;
}
function requireLodash_isstring() {
  if (hasRequiredLodash_isstring) return lodash_isstring;
  hasRequiredLodash_isstring = 1;
  var stringTag = "[object String]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var isArray = Array.isArray;
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  }
  lodash_isstring = isString;
  return lodash_isstring;
}
function requireLodash_once() {
  if (hasRequiredLodash_once) return lodash_once;
  hasRequiredLodash_once = 1;
  var FUNC_ERROR_TEXT = "Expected a function";
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function before(n, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = void 0;
      }
      return result;
    };
  }
  function once(func) {
    return before(2, func);
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -Infinity) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other2 = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other2) ? other2 + "" : other2;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  lodash_once = once;
  return lodash_once;
}
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  const timespan2 = requireTimespan();
  const PS_SUPPORTED = requirePsSupported();
  const validateAsymmetricKey2 = requireValidateAsymmetricKey();
  const jws2 = requireJws();
  const includes = requireLodash_includes();
  const isBoolean = requireLodash_isboolean();
  const isInteger = requireLodash_isinteger();
  const isNumber2 = requireLodash_isnumber();
  const isPlainObject = requireLodash_isplainobject();
  const isString = requireLodash_isstring();
  const once = requireLodash_once();
  const { KeyObject, createSecretKey, createPrivateKey } = require$$22;
  const SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
  }
  const sign_options_schema = {
    expiresIn: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
    notBefore: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
    audience: { isValid: function(value) {
      return isString(value) || Array.isArray(value);
    }, message: '"audience" must be a string or array' },
    algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
    header: { isValid: isPlainObject, message: '"header" must be an object' },
    encoding: { isValid: isString, message: '"encoding" must be a string' },
    issuer: { isValid: isString, message: '"issuer" must be a string' },
    subject: { isValid: isString, message: '"subject" must be a string' },
    jwtid: { isValid: isString, message: '"jwtid" must be a string' },
    noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
    keyid: { isValid: isString, message: '"keyid" must be a string' },
    mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
    allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
    allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
  };
  const registered_claims_schema = {
    iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' }
  };
  function validate(schema, allowUnknown, object, parameterName) {
    if (!isPlainObject(object)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object).forEach(function(key) {
      const validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
  }
  function validateOptions(options) {
    return validate(sign_options_schema, false, options, "options");
  }
  function validatePayload(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
  }
  const options_to_payload = {
    "audience": "aud",
    "issuer": "iss",
    "subject": "sub",
    "jwtid": "jti"
  };
  const options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
  ];
  sign = function(payload, secretOrPrivateKey2, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
      alg: options.algorithm || "HS256",
      typ: isObjectPayload ? "JWT" : void 0,
      kid: options.keyid
    }, options.header);
    function failure(err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (!secretOrPrivateKey2 && options.algorithm !== "none") {
      return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey2 != null && !(secretOrPrivateKey2 instanceof KeyObject)) {
      try {
        secretOrPrivateKey2 = createPrivateKey(secretOrPrivateKey2);
      } catch (_) {
        try {
          secretOrPrivateKey2 = createSecretKey(typeof secretOrPrivateKey2 === "string" ? Buffer.from(secretOrPrivateKey2) : secretOrPrivateKey2);
        } catch (_2) {
          return failure(new Error("secretOrPrivateKey is not valid key material"));
        }
      }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey2.type !== "secret") {
      return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
      if (secretOrPrivateKey2.type !== "private") {
        return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey2.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
      secretOrPrivateKey2.asymmetricKeyDetails.modulusLength < 2048) {
        return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
    }
    if (typeof payload === "undefined") {
      return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error) {
        return failure(error);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      const invalid_options = options_for_objects.filter(function(opt) {
        return typeof options[opt] !== "undefined";
      });
      if (invalid_options.length > 0) {
        return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
      }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
      return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
      return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
      validateOptions(options);
    } catch (error) {
      return failure(error);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey2(header.alg, secretOrPrivateKey2);
      } catch (error) {
        return failure(error);
      }
    }
    const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp;
    }
    if (typeof options.notBefore !== "undefined") {
      try {
        payload.nbf = timespan2(options.notBefore, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.nbf === "undefined") {
        return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
      try {
        payload.exp = timespan2(options.expiresIn, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.exp === "undefined") {
        return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    Object.keys(options_to_payload).forEach(function(key) {
      const claim = options_to_payload[key];
      if (typeof options[key] !== "undefined") {
        if (typeof payload[claim] !== "undefined") {
          return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
        }
        payload[claim] = options[key];
      }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
      callback = callback && once(callback);
      jws2.createSign({
        header,
        privateKey: secretOrPrivateKey2,
        payload,
        encoding
      }).once("error", callback).once("done", function(signature) {
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
        callback(null, signature);
      });
    } else {
      let signature = jws2.sign({ header, payload, secret: secretOrPrivateKey2, encoding });
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
      }
      return signature;
    }
  };
  return sign;
}
function requireJsonwebtoken() {
  if (hasRequiredJsonwebtoken) return jsonwebtoken;
  hasRequiredJsonwebtoken = 1;
  jsonwebtoken = {
    decode: requireDecode(),
    verify: requireVerify(),
    sign: requireSign(),
    JsonWebTokenError: requireJsonWebTokenError(),
    NotBeforeError: requireNotBeforeError(),
    TokenExpiredError: requireTokenExpiredError()
  };
  return jsonwebtoken;
}
var jws, safeBuffer, hasRequiredSafeBuffer, dataStream, hasRequiredDataStream, bufferEqualConstantTime, hasRequiredBufferEqualConstantTime, paramBytesForAlg_1, hasRequiredParamBytesForAlg, ecdsaSigFormatter, hasRequiredEcdsaSigFormatter, jwa, hasRequiredJwa, tostring, hasRequiredTostring, signStream, hasRequiredSignStream, verifyStream, hasRequiredVerifyStream, hasRequiredJws, decode, hasRequiredDecode, JsonWebTokenError_1, hasRequiredJsonWebTokenError, NotBeforeError_1, hasRequiredNotBeforeError, TokenExpiredError_1, hasRequiredTokenExpiredError, ms, hasRequiredMs, timespan, hasRequiredTimespan, re, constants, hasRequiredConstants, debug_1, hasRequiredDebug, hasRequiredRe, parseOptions_1, hasRequiredParseOptions, identifiers, hasRequiredIdentifiers, semver$1, hasRequiredSemver$1, parse_1, hasRequiredParse, valid_1, hasRequiredValid$1, clean_1, hasRequiredClean, inc_1, hasRequiredInc, diff_1, hasRequiredDiff, major_1, hasRequiredMajor, minor_1, hasRequiredMinor, patch_1, hasRequiredPatch, prerelease_1, hasRequiredPrerelease, compare_1, hasRequiredCompare, rcompare_1, hasRequiredRcompare, compareLoose_1, hasRequiredCompareLoose, compareBuild_1, hasRequiredCompareBuild, sort_1, hasRequiredSort, rsort_1, hasRequiredRsort, gt_1, hasRequiredGt, lt_1, hasRequiredLt, eq_1, hasRequiredEq, neq_1, hasRequiredNeq, gte_1, hasRequiredGte, lte_1, hasRequiredLte, cmp_1, hasRequiredCmp, coerce_1, hasRequiredCoerce, lrucache, hasRequiredLrucache, range2, hasRequiredRange, comparator, hasRequiredComparator, satisfies_1, hasRequiredSatisfies, toComparators_1, hasRequiredToComparators, maxSatisfying_1, hasRequiredMaxSatisfying, minSatisfying_1, hasRequiredMinSatisfying, minVersion_1, hasRequiredMinVersion, valid, hasRequiredValid, outside_1, hasRequiredOutside, gtr_1, hasRequiredGtr, ltr_1, hasRequiredLtr, intersects_1, hasRequiredIntersects, simplify, hasRequiredSimplify, subset_1, hasRequiredSubset, semver, hasRequiredSemver, asymmetricKeyDetailsSupported, hasRequiredAsymmetricKeyDetailsSupported, rsaPssKeyDetailsSupported, hasRequiredRsaPssKeyDetailsSupported, validateAsymmetricKey, hasRequiredValidateAsymmetricKey, psSupported, hasRequiredPsSupported, verify, hasRequiredVerify, lodash_includes, hasRequiredLodash_includes, lodash_isboolean, hasRequiredLodash_isboolean, lodash_isinteger, hasRequiredLodash_isinteger, lodash_isnumber, hasRequiredLodash_isnumber, lodash_isplainobject, hasRequiredLodash_isplainobject, lodash_isstring, hasRequiredLodash_isstring, lodash_once, hasRequiredLodash_once, sign, hasRequiredSign, jsonwebtoken, hasRequiredJsonwebtoken, jsonwebtokenExports, index, index$1;
var init_jsonwebtoken = __esm({
  "../../node_modules/.pnpm/@karinjs+jsonwebtoken@1.1.1/node_modules/@karinjs/jsonwebtoken/dist/jsonwebtoken.js"() {
    jws = {};
    safeBuffer = { exports: {} };
    re = { exports: {} };
    jsonwebtokenExports = requireJsonwebtoken();
    index = /* @__PURE__ */ getDefaultExportFromCjs2(jsonwebtokenExports);
    index$1 = /* @__PURE__ */ _mergeNamespaces2({
      __proto__: null,
      default: index
    }, [jsonwebtokenExports]);
    jsonwebtokenExports.decode;
    jsonwebtokenExports.sign;
    jsonwebtokenExports.verify;
  }
});

// ../../node_modules/.pnpm/@karinjs+jsonwebtoken@1.1.1/node_modules/@karinjs/jsonwebtoken/index.js
var app2, jsonwebtoken_default;
var init_jsonwebtoken2 = __esm({
  "../../node_modules/.pnpm/@karinjs+jsonwebtoken@1.1.1/node_modules/@karinjs/jsonwebtoken/index.js"() {
    init_jsonwebtoken();
    init_jsonwebtoken();
    app2 = index$1.default;
    jsonwebtoken_default = app2;
  }
});

// src/server/utils/response.ts
var HTTPStatusCode, createResponse, createSuccessResponse, createUnauthorizedResponse, createAccessTokenExpiredResponse, createRefreshTokenExpiredResponse, createNotFoundResponse, createServerErrorResponse, createBadRequestResponse, createPayloadTooLargeResponse, createMethodNotAllowedResponse, createForbiddenResponse;
var init_response = __esm({
  "src/server/utils/response.ts"() {
    HTTPStatusCode = /* @__PURE__ */ ((HTTPStatusCode2) => {
      HTTPStatusCode2[HTTPStatusCode2["OK"] = 200] = "OK";
      HTTPStatusCode2[HTTPStatusCode2["BadRequest"] = 400] = "BadRequest";
      HTTPStatusCode2[HTTPStatusCode2["Unauthorized"] = 401] = "Unauthorized";
      HTTPStatusCode2[HTTPStatusCode2["Forbidden"] = 403] = "Forbidden";
      HTTPStatusCode2[HTTPStatusCode2["NotFound"] = 404] = "NotFound";
      HTTPStatusCode2[HTTPStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HTTPStatusCode2[HTTPStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
      HTTPStatusCode2[HTTPStatusCode2["InternalServerError"] = 500] = "InternalServerError";
      HTTPStatusCode2[HTTPStatusCode2["AccessTokenExpired"] = 419] = "AccessTokenExpired";
      HTTPStatusCode2[HTTPStatusCode2["RefreshTokenExpired"] = 420] = "RefreshTokenExpired";
      return HTTPStatusCode2;
    })(HTTPStatusCode || {});
    createResponse = (res, code, data, message2 = "") => {
      logger.debug(
        `[express] \u54CD\u5E94:
code: ${code}
data: ${JSON.stringify(data)}
message: ${message2}
`
      );
      res.status(code).json({
        code,
        data,
        message: message2
      });
    };
    createSuccessResponse = (res, data, message2 = "\u6210\u529F") => {
      return createResponse(res, 200 /* OK */, data, message2);
    };
    createUnauthorizedResponse = (res, message2 = "\u672A\u767B\u5F55") => {
      return createResponse(res, 401 /* Unauthorized */, null, message2);
    };
    createAccessTokenExpiredResponse = (res, message2 = "\u8BBF\u95EE\u4EE4\u724C\u5DF2\u8FC7\u671F") => {
      return createResponse(res, 419 /* AccessTokenExpired */, null, message2);
    };
    createRefreshTokenExpiredResponse = (res, message2 = "\u5237\u65B0\u4EE4\u724C\u5DF2\u8FC7\u671F") => {
      return createResponse(res, 420 /* RefreshTokenExpired */, null, message2);
    };
    createNotFoundResponse = (res, message2 = "\u672A\u627E\u5230") => {
      return createResponse(res, 404 /* NotFound */, null, message2);
    };
    createServerErrorResponse = (res, message2 = "\u670D\u52A1\u5668\u9519\u8BEF") => {
      return createResponse(res, 500 /* InternalServerError */, null, message2);
    };
    createBadRequestResponse = (res, message2 = "\u53C2\u6570\u9519\u8BEF") => {
      return createResponse(res, 400 /* BadRequest */, null, message2);
    };
    createPayloadTooLargeResponse = (res, message2 = "\u8BF7\u6C42\u4F53\u8FC7\u5927") => {
      return createResponse(res, 413 /* PayloadTooLarge */, null, message2);
    };
    createMethodNotAllowedResponse = (res, message2 = "\u65B9\u6CD5\u4E0D\u5141\u8BB8") => {
      return createResponse(res, 405 /* MethodNotAllowed */, null, message2);
    };
    createForbiddenResponse = (res, message2 = "\u7981\u6B62\u8BBF\u95EE") => {
      return createResponse(res, 403 /* Forbidden */, null, message2);
    };
  }
});
var EXPIRES_IN, REFRESH_EXPIRES_IN, secretOrPrivateKey, initSecretOrPrivateKey, getSecretOrPrivateKey, createJwt, verifyJwt, verifyRefreshToken, refreshAccessToken, updateJwt;
var init_jwt = __esm({
  "src/server/auth/jwt.ts"() {
    init_jsonwebtoken2();
    init_config();
    init_response();
    EXPIRES_IN = process.env.EXPIRES_IN || "7d";
    REFRESH_EXPIRES_IN = "30d";
    secretOrPrivateKey = "";
    initSecretOrPrivateKey = () => {
      if (!secretOrPrivateKey) {
        secretOrPrivateKey = crypto.createHash("sha256").update(authKey()).digest("hex");
      }
    };
    getSecretOrPrivateKey = () => {
      initSecretOrPrivateKey();
      return secretOrPrivateKey;
    };
    createJwt = () => {
      initSecretOrPrivateKey();
      const userId = crypto.randomUUID();
      const accessToken = jsonwebtoken_default.sign({ userId, type: "access" }, secretOrPrivateKey, { expiresIn: EXPIRES_IN });
      const refreshToken = jsonwebtoken_default.sign({ userId, type: "refresh" }, secretOrPrivateKey, { expiresIn: REFRESH_EXPIRES_IN });
      return { userId, accessToken, refreshToken };
    };
    verifyJwt = (token, userId) => {
      try {
        initSecretOrPrivateKey();
        const decoded = jsonwebtoken_default.verify(token, secretOrPrivateKey);
        if (decoded.userId === userId) {
          return { status: 200 /* OK */, data: decoded.userId };
        }
        return { status: 401 /* Unauthorized */, data: "jwt\u9274\u6743\u5931\u8D25 \u7528\u6237id\u4E0D\u5339\u914D" };
      } catch (error) {
        if (error instanceof jsonwebtoken_default.JsonWebTokenError) {
          if (error.name === "TokenExpiredError") {
            return { status: 419 /* AccessTokenExpired */, data: "jwt\u4EE4\u724C\u5DF2\u8FC7\u671F" };
          }
          return { status: 401 /* Unauthorized */, data: "jwt\u9274\u6743\u5931\u8D25 \u8BF7\u767B\u5F55" };
        }
        logger.error(error);
        return { status: 500 /* InternalServerError */, data: "\u670D\u52A1\u5668\u5185\u90E8\u9519\u8BEF" };
      }
    };
    verifyRefreshToken = (token) => {
      try {
        initSecretOrPrivateKey();
        const decoded = jsonwebtoken_default.verify(token, secretOrPrivateKey);
        if (decoded && decoded.userId && decoded.type === "refresh") {
          return { status: true, data: decoded.userId };
        }
        return { status: false, data: "\u65E0\u6548\u4EE4\u724C" };
      } catch (error) {
        if (error instanceof jsonwebtoken_default.JsonWebTokenError) {
          if (error.name === "TokenExpiredError") {
            return { status: false, data: "\u5237\u65B0\u4EE4\u724C\u5DF2\u8FC7\u671F" };
          }
          return { status: false, data: "\u65E0\u6548\u7684\u5237\u65B0\u4EE4\u724C" };
        }
        logger.error(error);
        return { status: false, data: "\u670D\u52A1\u5668\u5185\u90E8\u9519\u8BEF" };
      }
    };
    refreshAccessToken = (userId) => {
      initSecretOrPrivateKey();
      const accessToken = jsonwebtoken_default.sign({ userId }, secretOrPrivateKey, { expiresIn: EXPIRES_IN });
      return accessToken;
    };
    updateJwt = () => {
      secretOrPrivateKey = crypto.createHash("sha256").update(authKey()).digest("hex");
    };
  }
});
var parser, initEnv, ffmpegPath, ffprobePath, ffplayPath, port, host, authKey, setEnv, getEnv, env, writeEnv, env_default;
var init_env3 = __esm({
  "src/utils/config/file/env.ts"() {
    init_dotenv();
    init_data();
    init_watch();
    init_require();
    init_fs2();
    init_listeners();
    init_create2();
    init_jwt();
    parser = (content) => {
      const lines = content.split("\n");
      const list2 = [];
      const obj = {};
      lines.forEach((line, index6) => {
        obj[index6] = line;
      });
      lines.forEach((line, index6) => {
        if (!line.includes("=")) return;
        let comment2 = "";
        let [key, value] = line.split("=").map((item) => item.trim());
        if (value.includes("#")) {
          const data = value.match(/^".*"$/);
          if (data) {
            value = data[0];
            comment2 = value.replace(value, "") || "";
          } else {
            const arr = value.split("#").map((item) => item.trim());
            comment2 = arr.length > 1 ? `# ${arr[1]}` : "";
            value = arr[0];
          }
        }
        if (!comment2) {
          const data = obj[index6 - 1]?.trim();
          if (data?.startsWith("#")) comment2 = data;
        }
        value = value?.replace(/^"|"$/g, "") || "";
        list2.push({ key, value, comment: comment2.replace(/\\r|\\n/g, "").trim() });
      });
      const result = {};
      list2.forEach((item) => {
        result[item.key] = {
          value: item.value,
          comment: item.comment
        };
      });
      return result;
    };
    initEnv = () => {
      const name = process.env.EBV_FILE;
      const file2 = `${process.cwd()}/${name}`;
      getEnv();
      watch(file2, (old, data) => {
        dotenv_default.config({ path: file2, override: true });
        process.env.RUNTIME = data.RUNTIME.value || "node";
        logger.level = process.env.LOG_LEVEL || "info";
        if (old?.WS_SERVER_AUTH_KEY?.value !== data?.WS_SERVER_AUTH_KEY?.value) {
          logger.warn("[hmr] WebSocket\u670D\u52A1\u5668\u9274\u6743\u79D8\u94A5\u5DF2\u66F4\u65B0");
          disconnectAllOneBotServer();
        }
        if (old?.HTTP_AUTH_KEY?.value !== data?.HTTP_AUTH_KEY?.value) {
          logger.warn("[hmr] HTTP\u9274\u6743\u79D8\u94A5\u5DF2\u66F4\u65B0");
          updateJwt();
        }
        const options = { file: file2, old, data };
        listeners.emit(FILE_CHANGE, options);
        listeners.emit(`${FILE_CHANGE}:${name}`, options);
      }, { parser });
    };
    ffmpegPath = () => process.env.FFMPEG_PATH;
    ffprobePath = () => process.env.FFPROBE_PATH;
    ffplayPath = () => process.env.FFPLAY_PATH;
    port = () => Number(process.env.HTTP_PORT) || 7777;
    host = () => process.env.HTTP_HOST || "127.0.0.1";
    authKey = () => {
      const key = process.env.HTTP_AUTH_KEY;
      if (!key || key === "default") {
        const value = randomStr();
        process.env.HTTP_AUTH_KEY = value;
        logger.warn(`HTTP\u9274\u6743\u79D8\u94A5\u4E3A\u9ED8\u8BA4 \u4F7F\u7528\u968F\u673A\u79D8\u94A5: ${value}`);
        return value;
      }
      return key;
    };
    setEnv = (data) => {
      try {
        const targetPath = path4.join(process.cwd(), process.env.EBV_FILE);
        const envConfig = getEnv(targetPath);
        Object.entries(data).forEach(([key, value]) => {
          envConfig[key] = {
            value,
            comment: envConfig[key]?.comment ?? ""
          };
        });
        const newContent = Object.entries(envConfig).map(([key, value]) => `${value.comment}
${key}="${value.value}"`).join("\n");
        fs5.writeFileSync(targetPath, newContent);
        dotenv_default.config({ path: targetPath, override: true });
        return true;
      } catch (error) {
        logger.error("[setEnv]", error);
        return false;
      }
    };
    getEnv = (filePath = path4.join(process.cwd(), process.env.EBV_FILE)) => {
      const data = requireFileSync(filePath, { parser });
      return data;
    };
    env = () => {
      const data = getEnv(path4.join(process.cwd(), process.env.EBV_FILE));
      const env3 = {};
      Object.entries(data).forEach(([key, value]) => {
        env3[key] = value.value;
      });
      return env3;
    };
    writeEnv = (data, cwd, isCover = false) => {
      if (!cwd) cwd = path4.join(process.cwd(), process.env.EBV_FILE);
      const env3 = getEnv(cwd);
      const result = { ...env3 };
      if (!Array.isArray(data)) data = [data];
      data.forEach((item) => {
        const { key, value, comment: comment2 } = item;
        if (!key || typeof key !== "string") {
          logger.error("[writeEnv]", "key \u5FC5\u987B\u4E3A\u5B57\u7B26\u4E32");
          return;
        }
        if (result[key]) {
          if (!isCover) {
            logger.debug(`[writeEnv] key: ${key} \u5DF2\u5B58\u5728 \u8DF3\u8FC7`);
            return;
          }
        }
        result[key] = {
          value,
          comment: comment2 || result?.[key]?.comment || ""
        };
      });
      const content = Object.entries(result).map(([key, value]) => {
        const val = /^".*"$/.test(value.value) ? value.value : `"${value.value}"`;
        if (value.comment) {
          const comment2 = /^#/.test(value.comment) ? value.comment : `# ${value.comment}`;
          return `${comment2}
${key}=${val}`;
        }
        return `${key}=${val}`;
      }).join("\n");
      fs5.writeFileSync(cwd, content);
      dotenv_default.config({ path: cwd, override: true });
    };
    env_default = initEnv;
  }
});

// src/utils/config/admin.ts
var admin_exports = {};
__export(admin_exports, {
  clearFiles: () => clearFiles,
  getYaml: () => getYaml,
  setConfig: () => setConfig,
  setYaml: () => setYaml,
  updateLevel: () => updateLevel
});
var getYaml, setYaml, setConfig, clearFiles, updateLevel;
var init_admin = __esm({
  "src/utils/config/admin.ts"() {
    init_root();
    init_env3();
    init_require();
    getYaml = (name, type, isRefresh) => {
      const file2 = `${type === "user" ? configPath : defaultConfigPath}/${name}.json`;
      if (!fs5.existsSync(file2)) {
        throw new TypeError(`${file2} \u6587\u4EF6\u4E0D\u5B58\u5728`);
      }
      return requireFileSync(file2, { force: isRefresh });
    };
    setYaml = (name, data) => {
      if (name === "env") return setEnv(data);
      const file2 = `${configPath}/${name}.json`;
      if (!fs5.existsSync(file2)) return false;
      fs5.writeFileSync(file2, JSON.stringify(data, null, 2));
      return true;
    };
    setConfig = (name, data) => {
      return setYaml(name, data);
    };
    clearFiles = (dir) => {
      const list2 = fs5.readdirSync(dir);
      list2.forEach((file2) => {
        fs5.promises.rm(file2, { recursive: true, force: true });
      });
    };
    updateLevel = (level) => {
      if (level) {
        logger.level = level;
        return level;
      }
      const newLevel = process.env.LOG_LEVEL || "info";
      logger.level = newLevel;
      return newLevel;
    };
  }
});

// src/utils/config/index.ts
var config_exports = {};
__export(config_exports, {
  adapter: () => adapter,
  admin: () => admin,
  authKey: () => authKey,
  clearCache: () => clearCache,
  clearFiles: () => clearFiles,
  config: () => config2,
  createCount: () => createCount,
  defaultConfig: () => defaultConfig,
  env: () => env,
  ffmpegPath: () => ffmpegPath,
  ffplayPath: () => ffplayPath,
  ffprobePath: () => ffprobePath,
  formatArray: () => formatArray,
  formatObject: () => formatObject,
  getCacheCfg: () => getCacheCfg,
  getDirectCfg: () => getDirectCfg,
  getEnv: () => getEnv,
  getFriendCfg: () => getFriendCfg,
  getGroupCfg: () => getGroupCfg,
  getGroupsFileData: () => getGroupsFileData,
  getGuildCfg: () => getGuildCfg,
  getPrivatesFileData: () => getPrivatesFileData,
  getRenderCfg: () => getRenderCfg,
  getYaml: () => getYaml,
  groups: () => groups,
  host: () => host,
  initConfigCache: () => initConfigCache,
  initCount: () => initCount,
  initPm2: () => initPm2,
  master: () => master,
  pkg: () => pkg,
  pm2: () => pm2,
  port: () => port,
  privates: () => privates,
  redis: () => redis,
  render: () => render2,
  setConfig: () => setConfig,
  setEnv: () => setEnv,
  setYaml: () => setYaml,
  timeout: () => timeout,
  updateLevel: () => updateLevel,
  webSocketServerToken: () => webSocketServerToken,
  writeEnv: () => writeEnv
});
var init_config = __esm({
  "src/utils/config/index.ts"() {
    init_tools();
    init_default();
    init_admin();
    init_pkg();
    init_file2();
  }
});
var missing, loaderPlugin, taskStart, printMissing, errorHandler;
var init_error = __esm({
  "src/core/internal/error.ts"() {
    init_listeners();
    missing = /* @__PURE__ */ new Map();
    loaderPlugin = (name, file2, error) => {
      const pkg2 = /Cannot find package '(.+?)'/.exec(error)?.[1];
      if (pkg2) {
        const key = `${name}.${pkg2}`;
        if (missing.has(key)) return;
        missing.set(key, { name, file: file2, depend: pkg2 });
      } else {
        logger.error(`\u8F7D\u5165\u63D2\u4EF6\u9519\u8BEF\uFF1A${logger.red(`${name}/${path4.basename(file2)}`)}`);
        listeners.emit("error", error);
      }
    };
    taskStart = (name, task2, error) => {
      logger.error(`[\u5B9A\u65F6\u4EFB\u52A1][${name}][${task2}] \u6267\u884C\u9519\u8BEF`);
      listeners.emit("error", error);
    };
    printMissing = () => {
      try {
        if (!missing.size) return;
        const msg = ["\n-----\u4F9D\u8D56\u7F3A\u5931----"];
        for (const [, { name, file: file2, depend }] of missing) {
          msg.push(`[${name}][${path4.basename(file2)}] \u7F3A\u5C11\u4F9D\u8D56\uFF1A${logger.red(depend)}`);
        }
        msg.push("-------------------");
        const one = missing.values().next().value;
        msg.push(...[
          "\u6E29\u99A8\u63D0\u793A:",
          `1. \u5982\u679C\u662F\u65B0\u5B89\u88C5\u7684\u63D2\u4EF6\uFF0C\u8BF7\u5C1D\u8BD5\u6267\u884C ${logger.red("pnpm install -P")} \u81EA\u52A8\u5B89\u88C5\u4F9D\u8D56`,
          `2. \u5982\u679C\u6267\u884C\u7B2C\u4E00\u6B65\u65E0\u6548\uFF0C\u8BF7\u5C1D\u8BD5\u6267\u884C ${logger.red("pnpm imstall \u4F9D\u8D56\u540D\u79F0 -w")} \u624B\u52A8\u5B89\u88C5\u4F9D\u8D56`,
          `\u4E3E\u4F8B: ${logger.red(`pnpm add ${one.depend} -w`)}`,
          logger.yellow("\u5BF9\u4E8E\u624B\u52A8\u5B89\u88C5\u7684\u4F9D\u8D56\uFF0C\u5982\u679C\u5BF9\u5E94\u63D2\u4EF6\u672A\u5728\u4F7F\u7528\uFF0C\u8BF7\u8FDB\u884C\u53CA\u65F6\u5378\u8F7D: pnpm rm \u4F9D\u8D56\u540D\u79F0")
        ]);
        msg.push("-------------------");
        logger.error(msg.join("\n"));
      } finally {
        missing.clear();
      }
    };
    errorHandler = {
      /** 插件载入错误 */
      loaderPlugin,
      /** 定时任务执行错误 */
      taskStart,
      /** 打印插件载入错误 */
      printMissing
    };
  }
});
var StatusHelper, StatusHelperSubscription, statusListener;
var init_status_listener = __esm({
  "src/core/internal/status_listener.ts"() {
    StatusHelper = class {
      psCpuUsage = process.cpuUsage();
      psCurrentTime = process.hrtime();
      cpuTimes = os.cpus().map((cpu) => cpu.times);
      replaceNaN(value) {
        return isNaN(value) ? 0 : value;
      }
      sysCpuInfo() {
        const currentTimes = os.cpus().map((cpu) => cpu.times);
        const { total, active } = currentTimes.map((times, index6) => {
          const prevTimes = this.cpuTimes[index6];
          const totalCurrent = times.user + times.nice + times.sys + times.idle + times.irq;
          const totalPrev = prevTimes.user + prevTimes.nice + prevTimes.sys + prevTimes.idle + prevTimes.irq;
          const activeCurrent = totalCurrent - times.idle;
          const activePrev = totalPrev - prevTimes.idle;
          return {
            total: totalCurrent - totalPrev,
            active: activeCurrent - activePrev
          };
        }).reduce(
          (acc, cur) => ({
            total: acc.total + cur.total,
            active: acc.active + cur.active
          }),
          { total: 0, active: 0 }
        );
        this.cpuTimes = currentTimes;
        return {
          usage: this.replaceNaN(active / total * 100).toFixed(2),
          model: os.cpus()[0].model,
          speed: os.cpus()[0].speed,
          core: os.cpus().length
        };
      }
      sysMemoryUsage() {
        const { total, free } = { total: os.totalmem(), free: os.freemem() };
        return ((total - free) / 1024 / 1024).toFixed(2);
      }
      karinUsage() {
        const mem = process.memoryUsage();
        const numCpus = os.cpus().length;
        const usageDiff = process.cpuUsage(this.psCpuUsage);
        const endTime = process.hrtime(this.psCurrentTime);
        this.psCpuUsage = process.cpuUsage();
        this.psCurrentTime = process.hrtime();
        const usageMS = (usageDiff.user + usageDiff.system) / 1e3;
        const totalMS = endTime[0] * 1e3 + endTime[1] / 1e6;
        const normPercent = usageMS / totalMS / numCpus * 100;
        return {
          cpu: this.replaceNaN(normPercent).toFixed(2),
          memory: ((mem.heapTotal + mem.external + mem.arrayBuffers) / 1024 / 1024).toFixed(2)
        };
      }
      /**
       * 获取系统状态信息
       */
      systemStatus() {
        const karinUsage = this.karinUsage();
        const sysCpuInfo = this.sysCpuInfo();
        const memUsage = process.memoryUsage();
        let userInfo;
        try {
          userInfo = os.userInfo();
        } catch (e) {
          userInfo = void 0;
        }
        let loadavg;
        try {
          loadavg = os.loadavg();
        } catch (e) {
          loadavg = void 0;
        }
        return {
          cpu: {
            core: sysCpuInfo.core,
            model: sysCpuInfo.model,
            speed: (sysCpuInfo.speed / 1e3).toFixed(2),
            usage: {
              system: sysCpuInfo.usage,
              karin: karinUsage.cpu
            }
          },
          memory: {
            total: (os.totalmem() / 1024 / 1024).toFixed(2),
            usage: {
              system: this.sysMemoryUsage(),
              karin: karinUsage.memory
            },
            details: {
              rss: (memUsage.rss / 1024 / 1024).toFixed(2),
              heapTotal: (memUsage.heapTotal / 1024 / 1024).toFixed(2),
              heapUsed: (memUsage.heapUsed / 1024 / 1024).toFixed(2),
              external: (memUsage.external / 1024 / 1024).toFixed(2),
              arrayBuffers: (memUsage.arrayBuffers / 1024 / 1024).toFixed(2)
            }
          },
          system: {
            arch: `${os.platform()} ${os.arch()}`,
            hostname: os.hostname(),
            osName: os.type(),
            osVersion: os.release(),
            platform: os.platform(),
            uptime: os.uptime(),
            loadavg,
            tmpdir: os.tmpdir(),
            homedir: os.homedir()
          },
          process: {
            nodeVersion: process.version,
            pid: process.pid,
            uptime: process.uptime(),
            execPath: process.execPath,
            argv: process.argv,
            env: {
              nodeEnv: process.env.NODE_ENV,
              timezone: process.env.TZ
            },
            user: userInfo ? {
              username: userInfo.username,
              homedir: userInfo.homedir,
              shell: userInfo.shell
            } : void 0
          },
          network: {
            interfaces: os.networkInterfaces()
          }
        };
      }
    };
    StatusHelperSubscription = class extends EventEmitter {
      statusHelper;
      interval = null;
      constructor(time2 = 3e3) {
        super();
        this.statusHelper = new StatusHelper();
        this.on("newListener", (event) => {
          if (event === "statusUpdate" && this.listenerCount("statusUpdate") === 0) {
            this.startInterval(time2);
          }
        });
        this.on("removeListener", (event) => {
          if (event === "statusUpdate" && this.listenerCount("statusUpdate") === 0) {
            this.stopInterval();
          }
        });
      }
      startInterval(time2) {
        this.interval ??= setInterval(() => {
          const status = this.statusHelper.systemStatus();
          this.emit("statusUpdate", status);
        }, time2);
      }
      stopInterval() {
        if (this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
      }
    };
    statusListener = new StatusHelperSubscription();
  }
});

// src/core/internal/index.ts
var init_internal = __esm({
  "src/core/internal/index.ts"() {
    init_error();
    init_listeners();
    init_status_listener();
  }
});

// src/hooks/cache.ts
var hookId, createHookId, cache4;
var init_cache3 = __esm({
  "src/hooks/cache.ts"() {
    hookId = 0;
    createHookId = () => ++hookId;
    cache4 = {
      message: {
        message: [],
        friend: [],
        group: [],
        guild: [],
        direct: [],
        groupTemp: []
      },
      sendMsg: {
        message: [],
        forward: [],
        afterMessage: [],
        afterForward: []
      },
      empty: {
        message: [],
        notice: [],
        request: []
      },
      eventCall: {
        message: [],
        group: [],
        guild: [],
        groupTemp: [],
        friend: [],
        direct: [],
        notice: [],
        request: []
      }
    };
  }
});
var addHook, eventCall, emitHooks, eventCallEmit;
var init_eventCall = __esm({
  "src/hooks/eventCall.ts"() {
    init_cache3();
    addHook = (list2, callback, options = {}) => {
      const id = createHookId();
      list2.push({
        id,
        priority: options.priority ?? 1e4,
        callback
      });
      return { id, list: lodash3.orderBy(list2, ["priority"], ["asc"]) };
    };
    eventCall = Object.assign(
      /**
       * 添加通用事件调用钩子
       * @param callback 事件处理回调函数
       * @param options 钩子配置项
       * @returns 钩子ID
       */
      (callback, options = {}) => {
        const { id, list: list2 } = addHook(cache4.eventCall.message, callback, options);
        logger.mark(`[hooks] \u6DFB\u52A0\u901A\u7528\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
        cache4.eventCall.message = list2;
        return id;
      },
      {
        /**
         * 添加群聊事件调用钩子
         * @param callback 事件处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        group(callback, options = {}) {
          const { id, list: list2 } = addHook(cache4.eventCall.group, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u7FA4\u804A\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.group = list2;
          return id;
        },
        /**
         * 添加频道事件调用钩子
         * @param callback 事件处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        guild(callback, options = {}) {
          const { id, list: list2 } = addHook(cache4.eventCall.guild, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u9891\u9053\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.guild = list2;
          return id;
        },
        /**
         * 添加群临时事件调用钩子
         * @param callback 事件处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        groupTemp(callback, options = {}) {
          const { id, list: list2 } = addHook(cache4.eventCall.groupTemp, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u7FA4\u4E34\u65F6\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.groupTemp = list2;
          return id;
        },
        /**
         * 添加好友事件调用钩子
         * @param callback 事件处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        friend(callback, options = {}) {
          const { id, list: list2 } = addHook(cache4.eventCall.friend, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u597D\u53CB\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.friend = list2;
          return id;
        },
        /**
         * 添加私聊事件调用钩子
         * @param callback 事件处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        direct(callback, options = {}) {
          const { id, list: list2 } = addHook(cache4.eventCall.direct, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u79C1\u804A\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.direct = list2;
          return id;
        },
        /**
         * 添加通知事件调用钩子
         * @param callback 事件处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        notice(callback, options = {}) {
          const { id, list: list2 } = addHook(cache4.eventCall.notice, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u901A\u77E5\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.notice = list2;
          return id;
        },
        /**
         * 添加请求事件调用钩子
         * @param callback 事件处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        request(callback, options = {}) {
          const { id, list: list2 } = addHook(cache4.eventCall.request, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u8BF7\u6C42\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.request = list2;
          return id;
        },
        /**
         * 删除钩子
         * @param id 钩子ID
         */
        remove(id) {
          logger.mark(`[hooks] \u79FB\u9664\u4E8B\u4EF6\u8C03\u7528\u94A9\u5B50: ${id}`);
          cache4.eventCall.message = cache4.eventCall.message.filter((item) => item.id !== id);
          cache4.eventCall.group = cache4.eventCall.group.filter((item) => item.id !== id);
          cache4.eventCall.guild = cache4.eventCall.guild.filter((item) => item.id !== id);
          cache4.eventCall.groupTemp = cache4.eventCall.groupTemp.filter((item) => item.id !== id);
          cache4.eventCall.friend = cache4.eventCall.friend.filter((item) => item.id !== id);
          cache4.eventCall.direct = cache4.eventCall.direct.filter((item) => item.id !== id);
          cache4.eventCall.notice = cache4.eventCall.notice.filter((item) => item.id !== id);
          cache4.eventCall.request = cache4.eventCall.request.filter((item) => item.id !== id);
        }
      }
    );
    emitHooks = async (event, plugin, hooks2) => {
      let isNext = false;
      for (const hook of hooks2) {
        const result = hook.callback(event, plugin, () => {
          isNext = true;
        });
        if (isPromise(result)) await result;
        if (!isNext) return false;
        isNext = false;
      }
      return true;
    };
    eventCallEmit = {
      /**
       * 触发通用事件调用钩子
       * @param event 事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      message: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.message),
      /**
       * 触发群聊事件调用钩子
       * @param event 群聊事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      group: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.group),
      /**
       * 触发频道事件调用钩子
       * @param event 频道事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      guild: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.guild),
      /**
       * 触发群临时事件调用钩子
       * @param event 群临时事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      groupTemp: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.groupTemp),
      /**
       * 触发好友事件调用钩子
       * @param event 好友事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      friend: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.friend),
      /**
       * 触发私聊事件调用钩子
       * @param event 私聊事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      direct: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.direct),
      /**
       * 触发通知事件调用钩子
       * @param event 通知事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      notice: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.notice),
      /**
       * 触发请求事件调用钩子
       * @param event 请求事件
       * @param plugin 插件对象
       * @returns 是否继续正常流程
       */
      request: (event, plugin) => emitHooks(event, plugin, cache4.eventCall.request)
    };
  }
});
var addMessageHook, addGeneralHook, empty, emitMessageHooks, emitGeneralHooks, emptyEmit;
var init_empty = __esm({
  "src/hooks/empty.ts"() {
    init_cache3();
    addMessageHook = (list2, callback, options = {}) => {
      const id = createHookId();
      list2.push({
        id,
        priority: options.priority ?? 1e4,
        callback
      });
      return { id, list: lodash3.orderBy(list2, ["priority"], ["asc"]) };
    };
    addGeneralHook = (list2, callback, options = {}) => {
      const id = createHookId();
      list2.push({
        id,
        priority: options.priority ?? 1e4,
        callback
      });
      return { id, list: lodash3.orderBy(list2, ["priority"], ["asc"]) };
    };
    empty = Object.assign(
      /**
       * 添加未找到匹配插件消息钩子
       * @param callback 消息处理回调函数
       * @param options 钩子配置项
       * @returns 钩子ID
       */
      (callback, options = {}) => {
        const { id, list: list2 } = addMessageHook(cache4.empty.message, callback, options);
        logger.mark(`[hooks] \u6DFB\u52A0\u672A\u627E\u5230\u5339\u914D\u63D2\u4EF6\u6D88\u606F\u94A9\u5B50: ${id}`);
        cache4.empty.message = list2;
        return id;
      },
      {
        /**
         * 添加未找到匹配插件消息钩子
         * @param callback 消息处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        message(callback, options = {}) {
          const { id, list: list2 } = addMessageHook(cache4.empty.message, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u672A\u627E\u5230\u5339\u914D\u63D2\u4EF6\u6D88\u606F\u94A9\u5B50: ${id}`);
          cache4.empty.message = list2;
          return id;
        },
        /**
         * 添加未找到匹配插件通知钩子
         * @param callback 通知处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        notice(callback, options = {}) {
          const { id, list: list2 } = addGeneralHook(cache4.empty.notice, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u672A\u627E\u5230\u5339\u914D\u63D2\u4EF6\u901A\u77E5\u94A9\u5B50: ${id}`);
          cache4.empty.notice = list2;
          return id;
        },
        /**
         * 添加未找到匹配插件请求钩子
         * @param callback 请求处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        request(callback, options = {}) {
          const { id, list: list2 } = addGeneralHook(cache4.empty.request, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u672A\u627E\u5230\u5339\u914D\u63D2\u4EF6\u8BF7\u6C42\u94A9\u5B50: ${id}`);
          cache4.empty.request = list2;
          return id;
        },
        /**
         * 删除未找到匹配插件钩子
         * @param id 钩子ID
         */
        remove(id) {
          logger.mark(`[hooks] \u79FB\u9664\u672A\u627E\u5230\u5339\u914D\u63D2\u4EF6\u94A9\u5B50: ${id}`);
          cache4.empty.message = cache4.empty.message.filter((item) => item.id !== id);
          cache4.empty.notice = cache4.empty.notice.filter((item) => item.id !== id);
          cache4.empty.request = cache4.empty.request.filter((item) => item.id !== id);
        }
      }
    );
    emitMessageHooks = async (event, hooks2) => {
      let isNext = false;
      for (const hook of hooks2) {
        const result = hook.callback(event, () => {
          isNext = true;
        });
        if (isPromise(result)) await result;
        if (!isNext) return false;
        isNext = false;
      }
      return true;
    };
    emitGeneralHooks = async (event, hooks2) => {
      let isNext = false;
      for (const hook of hooks2) {
        const result = hook.callback(event, () => {
          isNext = true;
        });
        if (isPromise(result)) await result;
        if (!isNext) return false;
        isNext = false;
      }
      return true;
    };
    emptyEmit = {
      /**
       * 触发未找到匹配插件消息钩子
       * @param event 消息事件
       * @returns 是否继续正常流程
       */
      message: (event) => emitMessageHooks(event, cache4.empty.message),
      /**
       * 触发未找到匹配插件通知钩子
       * @param event 通知事件
       * @returns 是否继续正常流程
       */
      notice: (event) => emitGeneralHooks(event, cache4.empty.notice),
      /**
       * 触发未找到匹配插件请求钩子
       * @param event 请求事件
       * @returns 是否继续正常流程
       */
      request: (event) => emitGeneralHooks(event, cache4.empty.request)
    };
  }
});

// src/utils/system/error.ts
var stringifyError, errorToString;
var init_error2 = __esm({
  "src/utils/system/error.ts"() {
    stringifyError = (error) => {
      const { name, message: message2, stack } = error || {};
      return { name, message: message2, stack };
    };
    errorToString = (error) => {
      if (!error) return "";
      return [
        `name: ${error.name}`,
        `message: ${error.message}`,
        `stack: ${error.stack?.toString()}`
      ].join("\n");
    };
  }
});
var exec;
var init_exec = __esm({
  "src/utils/system/exec.ts"() {
    init_error2();
    exec = (cmd, options) => {
      const logger3 = global?.logger || console;
      return new Promise((resolve) => {
        if (options?.log) {
          logger3.info([
            "[exec] \u6267\u884C\u547D\u4EE4:",
            `pwd: ${options?.cwd || process.cwd()}`,
            `cmd: ${cmd}`,
            `options: ${JSON.stringify(options)}`
          ].join("\n"));
        }
        exec$1(cmd, options, (error, stdout, stderr) => {
          if (options?.log) {
            const info = stringifyError(error);
            if (info.message) info.message = `\x1B[91m${info.message}\x1B[0m`;
            logger3.info([
              "[exec] \u6267\u884C\u7ED3\u679C:",
              `stderr: ${stderr.toString()}`,
              `stdout: ${stdout.toString()}`,
              `error: ${JSON.stringify(info, null, 2)}`
            ].join("\n"));
          }
          if (options?.booleanResult) {
            return resolve(!error);
          }
          stdout = stdout.toString();
          stderr = stderr.toString();
          if (options?.trim) {
            stdout = stdout.trim();
            stderr = stderr.trim();
          }
          const value = {
            status: !error,
            error,
            stdout,
            stderr
          };
          resolve(value);
        });
      });
    };
  }
});

// src/utils/system/ffmpeg.ts
var ffmpegPath2, ffprobePath2, ffplayPath2, ffmpeg, ffprobe, ffplay;
var init_ffmpeg = __esm({
  "src/utils/system/ffmpeg.ts"() {
    init_exec();
    ffmpegPath2 = "ffmpeg";
    ffprobePath2 = "ffprobe";
    ffplayPath2 = "ffplay";
    setTimeout(async () => {
      const env3 = await exec("ffmpeg -version", { booleanResult: true });
      if (!env3) {
        const cfg = await Promise.resolve().then(() => (init_config(), config_exports));
        const ffmpeg2 = cfg.ffmpegPath();
        const ffprobe2 = cfg.ffprobePath();
        const ffplay2 = cfg.ffplayPath();
        ffmpegPath2 = ffmpeg2 ? `"${ffmpeg2}"` : ffmpegPath2;
        ffprobePath2 = ffprobe2 ? `"${ffprobe2}"` : ffprobePath2;
        ffplayPath2 = ffplay2 ? `"${ffplay2}"` : ffplayPath2;
      }
    }, 1e3);
    ffmpeg = async (cmd, options) => {
      cmd = cmd.replace(/^ffmpeg/, "").trim();
      cmd = `${ffmpegPath2} ${cmd}`;
      return await exec(cmd, options);
    };
    ffprobe = async (cmd, options) => {
      cmd = cmd.replace(/^ffprobe/, "").trim();
      cmd = `${ffprobePath2} ${cmd}`;
      return await exec(cmd, options);
    };
    ffplay = async (cmd, options) => {
      cmd = cmd.replace(/^ffplay/, "").trim();
      cmd = `${ffplayPath2} ${cmd}`;
      return await exec(cmd, options);
    };
  }
});

// src/plugin/system/env.ts
var createAddEnv;
var init_env4 = __esm({
  "src/plugin/system/env.ts"() {
    createAddEnv = (list2) => {
      if (!list2) {
        return () => {
        };
      }
      return (name, data) => {
        if (!Array.isArray(data)) {
          logger.error(`[addEnv] \u63D2\u4EF6${name}\u7684env\u5B57\u6BB5\u4E0D\u7B26\u5408\u89C4\u8303 \u5DF2\u8DF3\u8FC7\u52A0\u8F7D`);
          return;
        }
        data.forEach((val) => {
          const { key, value, comment: comment2 = "" } = val;
          if (!key || !value || typeof key !== "string" || typeof value !== "string") {
            logger.warn(
              `[addEnv] \u63D2\u4EF6${name}\u7684env\u4E0D\u7B26\u5408\u89C4\u8303 \u5DF2\u8DF3\u8FC7
key: ${key}
value: ${value}
comment: ${comment2}`
            );
            return;
          }
          list2.push({
            key,
            value,
            comment: typeof comment2 !== "string" ? String(comment2) : comment2
          });
        });
      };
    };
  }
});
var isLoopback, isIPv4Loop, isIPv6Loop, getRequestIp, isLocalRequest;
var init_ip = __esm({
  "src/utils/system/ip.ts"() {
    isLoopback = async (hostnameOrIp) => {
      try {
        const addresses = await lookup(hostnameOrIp, { all: true });
        return addresses.some((addr) => isIPv4Loop(addr.address) || isIPv6Loop(addr.address));
      } catch {
        return false;
      }
    };
    isIPv4Loop = (ip) => {
      const parts = ip.split(".").map(Number);
      const isLoopback2 = parts.length === 4 && parts[0] === 127;
      const isInRange = parts.every((part) => Number.isInteger(part) && part >= 0 && part <= 255);
      return isLoopback2 && isInRange;
    };
    isIPv6Loop = (ip) => {
      if (ip === "::1") return true;
      if (ip.startsWith("::ffff:")) {
        const ipv4Part = ip.substring(7);
        return isIPv4Loop(ipv4Part);
      }
      return false;
    };
    getRequestIp = (req) => {
      const list2 = [];
      const xForwardedFor = req.headers["x-forwarded-for"];
      if (Array.isArray(xForwardedFor)) {
        list2.push(...xForwardedFor);
      } else if (typeof xForwardedFor === "string") {
        list2.push(xForwardedFor);
      }
      const remoteAddress = req.socket.remoteAddress;
      const ip = req.ip;
      const hostname = req.hostname;
      if (ip) list2.push(ip);
      if (hostname) list2.push(hostname);
      if (remoteAddress) list2.push(remoteAddress);
      return list2.filter(Boolean);
    };
    isLocalRequest = async (req) => {
      const ips = getRequestIp(req);
      for (const ip of ips) {
        const isLocal = await isLoopback(ip);
        if (!isLocal) return false;
      }
      return true;
    };
  }
});
var isWin2, isLinux, isMac, isDocker, isRoot;
var init_system = __esm({
  "src/utils/system/system.ts"() {
    isWin2 = os.platform() === "win32";
    isLinux = os.platform() === "linux";
    isMac = os.platform() === "darwin";
    isDocker = fs5.existsSync("/.dockerenv");
    isRoot = os.userInfo().uid === 0;
  }
});

// src/utils/system/pid.ts
var getPid;
var init_pid = __esm({
  "src/utils/system/pid.ts"() {
    init_exec();
    init_system();
    getPid = async (port2) => {
      const command2 = isWin2 ? `netstat -ano | findstr :${port2}` : `lsof -i:${port2} | grep LISTEN | awk '{print $2}'`;
      const { stdout } = await exec(command2);
      if (!stdout) return null;
      if (isWin2) {
        const pid = stdout.toString().split(/\s+/).filter(Boolean).pop();
        return isNaN(Number(pid)) ? null : Number(pid);
      }
      return isNaN(Number(stdout)) ? null : Number(stdout);
    };
  }
});

// src/utils/system/time.ts
var uptime, formatTime;
var init_time = __esm({
  "src/utils/system/time.ts"() {
    uptime = () => {
      const time2 = process.uptime();
      const day = Math.floor(time2 / 86400);
      const hour = Math.floor(time2 % 86400 / 3600);
      const min = Math.floor(time2 % 3600 / 60);
      const sec = Math.floor(time2 % 60);
      const parts = [
        day ? `${day}\u5929` : "",
        hour ? `${hour}\u5C0F\u65F6` : "",
        min ? `${min}\u5206\u949F` : "",
        !day && sec ? `${sec}\u79D2` : ""
      ];
      return parts.filter(Boolean).join("");
    };
    formatTime = (time2, time22 = Date.now()) => {
      time22 = time22 || Date.now();
      time2 = time2.toString().length === 10 ? time2 * 1e3 : time2;
      time2 = Math.floor((time22 - time2) / 1e3);
      time22 = time22.toString().length === 10 ? time22 * 1e3 : time22;
      time22 = Math.floor((time22 - time2) / 1e3);
      const day = Math.floor(time2 / 86400);
      const hour = Math.floor(time2 % 86400 / 3600);
      const min = Math.floor(time2 % 3600 / 60);
      const sec = Math.floor(time2 % 60);
      return `${day}\u5929${hour}\u5C0F\u65F6${min}\u5206\u949F${sec}\u79D2`.replace(/0[天时分秒]/g, "");
    };
  }
});

// src/utils/system/class.ts
var isClass;
var init_class = __esm({
  "src/utils/system/class.ts"() {
    isClass = (fnc2) => {
      return typeof fnc2 === "function" && /^class\s/.test(fnc2.toString());
    };
  }
});

// src/utils/common/sleep.ts
var sleep;
var init_sleep = __esm({
  "src/utils/common/sleep.ts"() {
    sleep = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
  }
});
var checkPort, waitPort, killApp;
var init_port = __esm({
  "src/utils/system/port.ts"() {
    init_sleep();
    init_exec();
    init_pid();
    init_system();
    checkPort = (port2) => {
      return new Promise((resolve) => {
        const server2 = createServer$1();
        server2.once("error", () => {
          server2.close();
          resolve(false);
        });
        server2.once("listening", () => {
          server2.close();
          resolve(true);
        });
        server2.listen(port2, "127.0.0.1");
      });
    };
    waitPort = async (port2, maxAttempts = 30, interval = 1e3) => {
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const available = await checkPort(port2);
        if (available) {
          return true;
        }
        logger.debug(`\u7AEF\u53E3 ${port2} \u88AB\u5360\u7528\uFF0C\u7B49\u5F85\u91CA\u653E... (${attempt + 1}/${maxAttempts})`);
        await sleep(interval);
      }
      return false;
    };
    killApp = async (identifier, isPort = false) => {
      const pid = isPort ? await getPid(Number(identifier)) : Number(identifier);
      if (!pid) return false;
      const command2 = isWin2 ? `taskkill /F /PID ${pid}` : `kill -9 ${pid}`;
      const { stderr } = await exec(command2);
      if (stderr) return false;
      return true;
    };
  }
});

// src/utils/system/import.ts
var importModule, imports;
var init_import = __esm({
  "src/utils/system/import.ts"() {
    importModule = async (url, isRefresh = false) => {
      try {
        const module = await import(`file://${url}${isRefresh ? `?t=${Date.now()}` : ""}`);
        return { status: true, data: module };
      } catch (error) {
        return { status: false, data: error };
      }
    };
    imports = async (url, options = {}) => {
      const { isRefresh = false, isImportDefault = true } = options;
      const module = await import(`file://${url}${isRefresh ? `?t=${Date.now()}` : ""}`);
      if (isImportDefault) {
        return module.default;
      }
      return module;
    };
  }
});
var getPkg, checkPkgUpdate, getPkgVersion, getRemotePkgVersion, updatePkg, updateAllPkg, checkGitPluginUpdate, getCommit, getHash, getTime, updateGitPlugin, updateAllGitPlugin;
var init_update = __esm({
  "src/utils/system/update.ts"() {
    init_exec();
    init_require();
    init_list();
    getPkg = (isForcibly = false) => {
      return requireFile("package.json", { force: isForcibly });
    };
    checkPkgUpdate = async (name) => {
      const logger3 = global?.logger || console;
      try {
        const local = await getPkgVersion(name);
        const remote = await getRemotePkgVersion(name);
        if (local === remote) return { status: "no", local };
        return { status: "yes", local, remote };
      } catch (error) {
        logger3.error(error);
        return { status: "error", error };
      }
    };
    getPkgVersion = async (name) => {
      const { stdout, error } = await exec(`npm list ${name} --depth=0`);
      if (stdout) {
        const data = stdout.toString();
        if (data.includes("empty") || data.includes("extraneous")) {
          throw new Error(`\u83B7\u53D6\u5931\u8D25\uFF0C${name} \u672A\u5B89\u88C5`);
        }
        const reg = new RegExp(`${name}@(\\d+\\.\\d+\\.\\d+)`, "gm");
        const result = reg.exec(data);
        if (result?.[1]) return result[1];
      }
      if (error) {
        if (error?.stack?.toString().includes("empty") || error?.stack?.toString().includes("extraneous")) {
          throw new Error(`\u83B7\u53D6\u5931\u8D25\uFF0C${name} \u672A\u5B89\u88C5`);
        }
        throw error;
      }
      const pkg2 = await getPkg();
      return pkg2?.dependencies?.[name] || pkg2?.devDependencies?.[name] || pkg2?.peerDependencies?.[name];
    };
    getRemotePkgVersion = async (name, tag = "latest") => {
      const cmd = tag === "latest" ? `npm show ${name} version` : `npm show ${name} dist-tags.${tag}`;
      const { status, stdout, error } = await exec(cmd);
      if (!status) {
        if (error?.stack?.toString().includes("empty") || error?.stack?.toString().includes("extraneous")) {
          throw new Error(`\u83B7\u53D6\u5931\u8D25\uFF0C${name} \u672A\u5B89\u88C5`);
        }
        throw error;
      }
      return stdout.toString().trim();
    };
    updatePkg = async (name, tag = "latest") => {
      const logger3 = global?.logger || console;
      try {
        const local = await getPkgVersion(name);
        const remote = await getRemotePkgVersion(name, tag);
        if (local === remote) {
          return { status: "failed", data: `[${name}][\u65E0\u66F4\u65B0] ${local} => ${remote}` };
        }
        const shell = `pnpm up ${name}@${remote}`;
        const { error } = await exec(shell);
        if (error) {
          return { status: "failed", data: error };
        }
        const updatedVersion = await getPkgVersion(name);
        if (updatedVersion !== remote) {
          return { status: "failed", data: `[${name}][\u66F4\u65B0\u5931\u8D25] \u8BF7\u5C1D\u8BD5\u624B\u52A8\u66F4\u65B0 pnpm up ${name}@${remote}` };
        }
        return { status: "ok", data: `[${name}][\u66F4\u65B0\u6210\u529F] ${local} => ${remote}`, local, remote };
      } catch (error) {
        logger3.error(error);
        return { status: "failed", data: error };
      }
    };
    updateAllPkg = async () => {
      const logger3 = global?.logger || console;
      try {
        const list2 = await getPlugins("npm", false);
        list2.push("node-karin");
        const state = {};
        const tips2 = ["\n------- \u66F4\u65B0npm\u63D2\u4EF6 --------"];
        const cmd = ["pnpm up"];
        const pkg2 = await getPkg();
        const result = [];
        await Promise.all(list2.map(async (name) => {
          name = name.replace("npm:", "");
          const local = await getPkgVersion(name);
          const remote = await getRemotePkgVersion(name) || pkg2.dependencies[name];
          if (local === remote) {
            tips2.push(`[${name}][\u65E0\u66F4\u65B0] ${local} => ${remote}`);
            return;
          }
          tips2.push(`\u66F4\u65B0${name} ${local} => ${remote}`);
          cmd.push(`${name}@${remote}`);
          state[name] = { local, remote };
        }));
        if (cmd.length === 1) {
          tips2.push("\u6CA1\u6709\u53EF\u66F4\u65B0\u7684\u63D2\u4EF6~");
          tips2.push("---------------------------");
          logger3.info(tips2.join("\n"));
          return "\u6CA1\u6709\u53EF\u66F4\u65B0\u7684\u63D2\u4EF6~";
        } else {
          tips2.push("----------------------------");
          logger3.info(tips2.join("\n"));
        }
        const shell = cmd.join(" ");
        logger3.info(`\u5F00\u59CB\u66F4\u65B0: ${shell}`);
        const { error } = await exec(shell);
        if (error) {
          Object.keys(state).forEach((name) => {
            result.push(`[${name}][\u66F4\u65B0\u5931\u8D25] \u8BF7\u5C1D\u8BD5\u624B\u52A8\u66F4\u65B0 pnpm up ${name}@${state[name].remote}`);
          });
          result.unshift(`[\u66F4\u65B0\u5931\u8D25] \u66F4\u65B0\u6570\u91CF: ${result.length}`);
          logger3.error(result.join("\n"));
          logger3.error(error);
          return result.join("\n");
        }
        const updatedPkg = await getPkg(true);
        Object.keys(state).forEach((name) => {
          const updatedVersion = updatedPkg.dependencies?.[name] || updatedPkg.devDependencies?.[name] || updatedPkg.peerDependencies?.[name];
          if (updatedVersion !== state[name].remote) {
            result.push(`[${name}][\u66F4\u65B0\u5931\u8D25] \u8BF7\u5C1D\u8BD5\u624B\u52A8\u66F4\u65B0 pnpm up ${name}@${state[name].remote}`);
          } else {
            result.push(`[${name}][\u66F4\u65B0\u6210\u529F] ${state[name].local} => ${state[name].remote}`);
          }
        });
        result.sort((a) => a.includes("\u6210\u529F") ? -1 : 1);
        logger3.info(result.join("\n"));
        return result.join("\n");
      } catch (error) {
        logger3.error(error);
        return error.message || "\u66F4\u65B0\u5931\u8D25\uFF0C\u8BF7\u67E5\u770B\u65E5\u5FD7";
      }
    };
    checkGitPluginUpdate = async (filePath, time2 = 120) => {
      const logger3 = global?.logger || console;
      try {
        if (!fs5.existsSync(filePath)) return { status: "error", data: new Error("\u8DEF\u5F84\u4E0D\u5B58\u5728") };
        if (!fs5.existsSync(`${filePath}/.git`)) return { status: "error", data: new Error("\u8BE5\u8DEF\u5F84\u4E0D\u662F\u4E00\u4E2Agit\u4ED3\u5E93") };
        const timer = setTimeout(() => {
          return { status: "failed", data: "\u6267\u884C\u8D85\u65F6" };
        }, time2 * 1e3);
        const options = { cwd: filePath };
        const { error } = await exec("git fetch origin", options);
        if (error) return { status: "error", data: error };
        const { stdout } = await exec("git status -uno", options);
        clearTimeout(timer);
        if (stdout.includes("Your branch is up to date with")) {
          const time3 = await getTime(filePath);
          return { status: "no", data: `\u5F53\u524D\u7248\u672C\u5DF2\u662F\u6700\u65B0\u7248\u672C
\u6700\u540E\u66F4\u65B0\u65F6\u95F4\uFF1A${time3}` };
        }
        const count3 = Number(stdout.match(/Your branch is behind '.*' by (\d+) commits/)?.[1]) || 1;
        const data = await getCommit({ path: filePath, count: count3, branch: "origin" });
        clearTimeout(timer);
        return { status: "yes", data, count: count3 };
      } catch (error) {
        logger3.error(error);
        return { status: "error", data: error };
      }
    };
    getCommit = async (options) => {
      const { path: path36, count: count3 = 1, hash, branch } = options;
      let cmd = `git log -${count3} --format="[%ad]%s %n" --date="format:%m-%d %H:%M"`;
      if (hash) cmd = `git log ${hash}..HEAD --format="[%ad] %s %n" --date="format:%m-%d %H:%M"`;
      if (branch) cmd = `git log -${count3} ${branch} --format="[%ad] %s %n" --date="format:%m-%d %H:%M"`;
      const { stdout, error } = await exec(cmd, { cwd: path36 });
      if (error) {
        throw error;
      }
      return stdout;
    };
    getHash = async (filePath, short = true) => {
      const cmd = short ? "git rev-parse --short HEAD" : "git rev-parse HEAD";
      const { stdout, error } = await exec(cmd, { cwd: filePath });
      if (error) {
        throw error;
      }
      return stdout;
    };
    getTime = async (filePath) => {
      const cmd = 'git log -1 --format=%cd --date=format:"%Y-%m-%d %H:%M:%S"';
      const { stdout, error } = await exec(cmd, { cwd: filePath });
      if (error) return "\u83B7\u53D6\u6700\u540E\u4E00\u6B21\u63D0\u4EA4\u65F6\u95F4\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5\u6216\u66F4\u65B0Git~";
      return stdout;
    };
    updateGitPlugin = async (filePath, cmd = "git pull", time2 = 120) => {
      const logger3 = global?.logger || console;
      try {
        if (!fs5.existsSync(filePath)) return { status: "failed", data: "\u8DEF\u5F84\u4E0D\u5B58\u5728" };
        if (!fs5.existsSync(`${filePath}/.git`)) return { status: "failed", data: "\u8BE5\u8DEF\u5F84\u4E0D\u662F\u4E00\u4E2Agit\u4ED3\u5E93" };
        const timer = setTimeout(() => {
          return { status: "failed", data: "\u6267\u884C\u8D85\u65F6" };
        }, time2 * 1e3);
        const hash = await getHash(filePath);
        cmd = cmd || "git pull";
        const { error } = await exec(cmd, { cwd: filePath });
        if (error) {
          const data = `
\u66F4\u65B0\u5931\u8D25
\u9519\u8BEF\u4FE1\u606F\uFF1A${error?.stack || error?.message}
\u8BF7\u89E3\u51B3\u9519\u8BEF\u540E\u91CD\u8BD5\u6216\u6267\u884C\u3010#\u5F3A\u5236\u66F4\u65B0\u3011`;
          clearTimeout(timer);
          return { status: "failed", data };
        }
        const updatedHash = await getHash(filePath);
        if (hash === updatedHash) {
          clearTimeout(timer);
          const commit2 = await getCommit({ path: filePath, count: 1 });
          return { status: "failed", data: `
\u5F53\u524D\u7248\u672C\u5DF2\u662F\u6700\u65B0\u7248\u672C
\u6700\u540E\u66F4\u65B0\u65F6\u95F4\uFF1A${time2}
\u66F4\u65B0\u8BE6\u60C5\uFF1A${commit2}` };
        }
        clearTimeout(timer);
        const commit = await getCommit({ path: filePath, count: 1 });
        return { status: "ok", data: `
\u66F4\u65B0\u6210\u529F
\u66F4\u65B0\u65E5\u5FD7\uFF1A${getCommit({ path: filePath, count: 1 })}`, commit };
      } catch (error) {
        logger3.error(error);
        return { status: "failed", data: error };
      }
    };
    updateAllGitPlugin = async (cmd = "git pull", time2 = 120) => {
      try {
        const logger3 = global?.logger || console;
        const list2 = await getPlugins("git", false);
        const tips2 = ["\n------- \u66F4\u65B0git\u63D2\u4EF6 --------"];
        if (!list2.length) {
          tips2.push("\u6CA1\u6709\u53EF\u66F4\u65B0\u7684\u63D2\u4EF6~");
          tips2.push("----------------------------");
          logger3.info(tips2.join("\n"));
          return "\u6CA1\u6709\u53EF\u66F4\u65B0\u7684\u63D2\u4EF6~";
        }
        const result = [];
        await Promise.allSettled(list2.map(async (name) => {
          name = name.replace("git:", "");
          const filePath = `./plugins/${name}`;
          const { status, data } = await updateGitPlugin(filePath, cmd, time2);
          if (status === "ok") {
            tips2.push(`[${name}][\u66F4\u65B0\u6210\u529F] ${data}`);
            result.push(`[${name}][\u66F4\u65B0\u6210\u529F] ${data}`);
          } else {
            tips2.push(`[${name}][\u66F4\u65B0\u5931\u8D25] ${data}`);
            result.push(`[${name}][\u66F4\u65B0\u5931\u8D25] ${data}`);
          }
        }));
        tips2.push("----------------------------");
        logger3.info(tips2.join("\n"));
        return result.join("\n");
      } catch (error) {
        logger.error(error);
        return error.message || "\u66F4\u65B0\u5931\u8D25\uFF0C\u8BF7\u67E5\u770B\u65E5\u5FD7";
      }
    };
  }
});
var logPrefix, SQLiteWrapper;
var init_sqlite = __esm({
  "src/core/db/redis/mock/sqlite/index.ts"() {
    init_fsSync();
    logPrefix = (message2) => `[redis-mock] ${message2}`;
    SQLiteWrapper = class {
      db;
      #isClosing = false;
      #inTransaction = false;
      dbPath;
      /**
       * 构造函数
       * @param dbPath 数据库路径
       */
      constructor(dbPath2) {
        this.dbPath = dbPath2;
      }
      /**
       * 初始化数据库连接和表结构
       */
      async init() {
        mkdirSync(path4.dirname(this.dbPath));
        await new Promise((resolve, reject) => {
          this.db = new sqlite3.Database(
            this.dbPath,
            sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,
            (err) => {
              if (err) {
                logger.error(logPrefix("SQLite\u6570\u636E\u5E93\u8FDE\u63A5\u5931\u8D25:"));
                logger.error(err);
                reject(err);
                return;
              }
              resolve();
            }
          );
        });
        await new Promise((resolve) => {
          this.db.exec(
            `
          PRAGMA foreign_keys = ON;
          PRAGMA journal_mode = WAL;
          PRAGMA synchronous = NORMAL;
          `,
            (pragmaErr) => {
              if (pragmaErr) {
                logger.warn(logPrefix("\u8BBE\u7F6ESQLite PRAGMA\u5931\u8D25:"));
                logger.warn(pragmaErr);
              }
              resolve();
            }
          );
        });
        await new Promise((resolve, reject) => {
          this.db.run(
            `
          CREATE TABLE IF NOT EXISTS redis_data (
            key TEXT PRIMARY KEY,
            type TEXT NOT NULL,
            expire INTEGER NOT NULL,
            value TEXT NOT NULL
          )
          `,
            (err) => {
              if (err) {
                logger.error(logPrefix("\u521B\u5EFASQLite\u8868\u5931\u8D25:"));
                logger.error(err);
                reject(err);
                return;
              }
              resolve();
            }
          );
        });
        return this;
      }
      /**
       * 获取所有键
       * @returns 返回所有键的数组
       */
      async keys() {
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        return new Promise((resolve, reject) => {
          this.db.all(
            "SELECT key FROM redis_data",
            [],
            (err, rows) => {
              if (err) {
                logger.error(logPrefix("\u83B7\u53D6\u6240\u6709\u952E\u5931\u8D25:"));
                logger.error(err);
                reject(err);
                return;
              }
              resolve(rows ? rows.map((row) => row.key) : []);
            }
          );
        });
      }
      /**
       * 获取指定键的数据
       * @param key 键名
       * @returns 返回键的数据或null
       */
      async get(key) {
        if (!key) {
          return null;
        }
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        return await this.query(
          "SELECT type, expire, value FROM redis_data WHERE key = ?",
          [key]
        ).then((rows) => rows[0] || null).catch((err) => {
          logger.error(logPrefix(`\u83B7\u53D6\u952E${key}\u7684\u503C\u5931\u8D25:`));
          logger.error(err);
          return null;
        });
      }
      /**
       * 设置键值对
       * @param key 键名
       * @param type 类型
       * @param expire 过期时间
       * @param value 值
       * @returns 成功返回true
       */
      async set(key, value, type, expire = -1) {
        if (!key) {
          throw new Error("\u952E\u540D\u4E0D\u80FD\u4E3A\u7A7A");
        }
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        return await this.run(
          "INSERT OR REPLACE INTO redis_data (key, type, expire, value) VALUES (?, ?, ?, ?)",
          [key, type, expire, value]
        ).then((changes) => changes > 0).catch((err) => {
          logger.error(logPrefix(`\u8BBE\u7F6E\u952E${key}\u7684\u503C\u5931\u8D25:`));
          logger.error(err);
          return false;
        });
      }
      /**
       * 删除键
       * @param key 键名
       * @returns 成功返回true
       */
      async del(key) {
        if (!key) {
          return false;
        }
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        return await this.run(
          "DELETE FROM redis_data WHERE key = ?",
          [key]
        ).then((changes) => changes > 0).catch((err) => {
          logger.error(logPrefix(`\u5220\u9664\u952E${key}\u5931\u8D25:`));
          logger.error(err);
          return false;
        });
      }
      /**
       * 设置键的过期时间
       * @param key 键名
       * @param expire 过期时间
       * @returns 成功返回true
       */
      async expire(key, expire) {
        if (!key) {
          return false;
        }
        return await this.run("UPDATE redis_data SET expire = ? WHERE key = ?", [expire, key]).then((changes) => changes > 0).catch((err) => {
          logger.error(logPrefix(`\u8BBE\u7F6E\u952E${key}\u7684\u8FC7\u671F\u65F6\u95F4\u5931\u8D25:`));
          logger.error(err);
          return false;
        });
      }
      /**
       * 获取所有数据
       * @returns 返回所有数据的数组
       */
      async getAllData() {
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        return new Promise((resolve, reject) => {
          this.db.all(
            "SELECT key, type, expire, value FROM redis_data",
            [],
            (err, rows) => {
              if (err) {
                logger.error(logPrefix("\u83B7\u53D6\u6240\u6709\u6570\u636E\u5931\u8D25:"));
                logger.error(err);
                reject(err);
                return;
              }
              resolve(rows || []);
            }
          );
        });
      }
      /**
       * 关闭数据库连接
       */
      async close() {
        if (this.#isClosing) {
          return;
        }
        this.#isClosing = true;
        return new Promise((resolve, reject) => {
          this.db.close((err) => {
            if (err) {
              logger.error(logPrefix("\u5173\u95EDSQLite\u6570\u636E\u5E93\u5931\u8D25:"));
              logger.error(err);
              this.#isClosing = false;
              reject(err);
              return;
            }
            resolve();
          });
        });
      }
      /**
       * 开始事务
       */
      async beginTransaction() {
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        if (this.#inTransaction) {
          logger.warn(logPrefix("\u5DF2\u5728\u4E8B\u52A1\u4E2D\uFF0C\u8DF3\u8FC7\u5F00\u59CB\u65B0\u4E8B\u52A1"));
          return;
        }
        return new Promise((resolve, reject) => {
          this.db.run("BEGIN TRANSACTION", (err) => {
            if (err) {
              logger.error(logPrefix("\u5F00\u59CB\u4E8B\u52A1\u5931\u8D25:"));
              logger.error(err);
              reject(err);
              return;
            }
            this.#inTransaction = true;
            resolve();
          });
        });
      }
      /**
       * 提交事务
       */
      async commitTransaction() {
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        if (!this.#inTransaction) {
          logger.warn(logPrefix("\u6CA1\u6709\u6D3B\u52A8\u4E8B\u52A1\uFF0C\u8DF3\u8FC7\u63D0\u4EA4"));
          return;
        }
        return new Promise((resolve, reject) => {
          this.db.run("COMMIT", (err) => {
            if (err) {
              logger.error(logPrefix("\u63D0\u4EA4\u4E8B\u52A1\u5931\u8D25:"));
              logger.error(err);
              reject(err);
              return;
            }
            this.#inTransaction = false;
            resolve();
          });
        });
      }
      /**
       * 回滚事务
       */
      async rollbackTransaction() {
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D");
        }
        if (!this.#inTransaction) {
          logger.warn(logPrefix("\u6CA1\u6709\u6D3B\u52A8\u4E8B\u52A1\uFF0C\u8DF3\u8FC7\u56DE\u6EDA"));
          return;
        }
        return new Promise((resolve, reject) => {
          this.db.run("ROLLBACK", (err) => {
            if (err) {
              logger.error(logPrefix("\u56DE\u6EDA\u4E8B\u52A1\u5931\u8D25:"));
              logger.error(err);
              reject(err);
              return;
            }
            this.#inTransaction = false;
            resolve();
          });
        });
      }
      /**
       * 执行SQL查询并返回结果
       * @param sql SQL语句
       * @param params 参数
       * @returns 查询结果
       */
      async query(sql, params = []) {
        if (!this.db) throw new Error("\u6570\u636E\u5E93\u672A\u521D\u59CB\u5316");
        return new Promise((resolve, reject) => {
          this.db.all(sql, params, (err, rows) => {
            if (err) {
              logger.error(logPrefix(`\u67E5\u8BE2\u5931\u8D25: ${sql}`));
              logger.error(err);
              reject(err);
              return;
            }
            resolve(rows);
          });
        });
      }
      /**
       * 清理过期键
       */
      async cleanupExpiredKeys() {
        const now = Date.now();
        const expiredKeys = await this.query(
          "SELECT key FROM redis_data WHERE expire != -1 AND expire < ? LIMIT 500",
          [now]
        );
        return expiredKeys.length;
      }
      /**
       * 将db.run方法封装为Promise
       * @param sql SQL语句
       * @param params 参数数组
       * @returns 返回受影响的行数
       */
      async run(sql, params) {
        if (this.#isClosing) {
          throw new Error("\u6570\u636E\u5E93\u6B63\u5728\u5173\u95ED\u4E2D...");
        }
        return new Promise((resolve, reject) => {
          this.db.run(sql, params, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(this.changes);
          });
        });
      }
    };
  }
});
var SQLiteWrapper2;
var init_sqlite2 = __esm({
  "src/core/db/kv/sqlite.ts"() {
    init_fsSync();
    init_sqlite();
    SQLiteWrapper2 = class {
      dbPath;
      _db;
      constructor(dbPath2) {
        this.dbPath = dbPath2;
      }
      async _init() {
        mkdirSync(path4.dirname(this.dbPath));
        await new Promise((resolve, reject) => {
          this._db = new sqlite3.Database(
            this.dbPath,
            sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,
            (err) => {
              if (err) {
                logger.error(logPrefix("SQLite\u6570\u636E\u5E93\u8FDE\u63A5\u5931\u8D25:"));
                logger.error(err);
                reject(err);
                return;
              }
              resolve();
            }
          );
        });
        await new Promise((resolve) => {
          this._db.exec(
            `
          PRAGMA foreign_keys = ON;
          PRAGMA journal_mode = WAL;
          PRAGMA synchronous = NORMAL;
          `,
            (pragmaErr) => {
              if (pragmaErr) {
                logger.warn(logPrefix("\u8BBE\u7F6ESQLite PRAGMA\u5931\u8D25:"));
                logger.warn(pragmaErr);
              }
              resolve();
            }
          );
        });
        await new Promise((resolve, reject) => {
          this._db.run(
            `
          CREATE TABLE IF NOT EXISTS redis_data (
            key TEXT PRIMARY KEY,                        
            value TEXT NOT NULL DEFAULT ''
          )
          `,
            (err) => {
              if (err) {
                logger.error(logPrefix("\u521B\u5EFASQLite\u8868\u5931\u8D25:"));
                logger.error(err);
                reject(err);
                return;
              }
              resolve();
            }
          );
        });
        this._init = () => Promise.resolve(this);
        return this;
      }
      /**
       * 设置键值对
       * @param key 键名
       * @param value 值
       * @returns 操作是否成功
       */
      async set(key, value) {
        await this._init();
        return new Promise((resolve) => {
          this._db.run(
            "INSERT OR REPLACE INTO redis_data (key, value) VALUES (?, ?)",
            [key, JSON.stringify(value)],
            (err) => {
              if (err) {
                logger.error(logPrefix("\u8BBE\u7F6E\u952E\u503C\u5BF9\u5931\u8D25:"));
                logger.error(err);
                resolve(false);
                return;
              }
              resolve(true);
            }
          );
        });
      }
      /**
       * 获取所有匹配模式的键
       * @param pattern 匹配模式，支持SQL LIKE语法的通配符
       * @returns 匹配的键列表，失败时返回空数组
       */
      async keys(pattern = "*") {
        await this._init();
        const sqlPattern = pattern.replace(/\*/g, "%").replace(/\?/g, "_");
        return new Promise((resolve) => {
          this._db.all(
            "SELECT key FROM redis_data WHERE key LIKE ?",
            [sqlPattern],
            (err, rows) => {
              if (err) {
                logger.error(logPrefix("\u83B7\u53D6\u952E\u5217\u8868\u5931\u8D25:"));
                logger.error(err);
                resolve([]);
                return;
              }
              resolve(rows.map((row) => row.key));
            }
          );
        });
      }
      /**
       * 获取键对应的值
       * @param key 键名
       * @returns 值，如果键不存在或值损坏则返回null
       */
      async get(key) {
        await this._init();
        return new Promise((resolve) => {
          this._db.get(
            "SELECT value FROM redis_data WHERE key = ?",
            [key],
            async (err, row) => {
              if (err || !row) {
                resolve(null);
                return;
              }
              try {
                resolve(JSON.parse(row.value));
              } catch (e) {
                await this.del(key);
                resolve(null);
              }
            }
          );
        });
      }
      /**
       * 删除键
       * @param key 要删除的键
       * @returns 是否删除成功
       */
      async del(key) {
        await this._init();
        return new Promise((resolve) => {
          this._db.run(
            "DELETE FROM redis_data WHERE key = ?",
            [key],
            function(err) {
              if (err) {
                logger.error(logPrefix("\u5220\u9664\u952E\u5931\u8D25:"));
                logger.error(err);
                resolve(false);
                return;
              }
              resolve(this.changes > 0);
            }
          );
        });
      }
    };
  }
});

// src/core/db/kv/index.ts
var kv_exports = {};
__export(kv_exports, {
  createDB: () => createDB,
  db: () => db
});
var db, initialized, initializingPromise, init, createDB;
var init_kv = __esm({
  "src/core/db/kv/index.ts"() {
    init_root();
    init_sqlite2();
    initialized = false;
    initializingPromise = null;
    init = async (dbPath2) => {
      db = await new SQLiteWrapper2(dbPath2)._init();
      return db;
    };
    createDB = () => {
      if (initialized && db) {
        return Promise.resolve(db);
      }
      if (initializingPromise) {
        return initializingPromise;
      }
      initializingPromise = init(path4.join(kvPath, "kv.db")).then((result) => {
        initialized = true;
        initializingPromise = null;
        return result;
      }).catch((error) => {
        initializingPromise = null;
        throw error;
      });
      return initializingPromise;
    };
  }
});

// src/utils/system/restart.ts
var restart, restartDirect;
var init_restart = __esm({
  "src/utils/system/restart.ts"() {
    init_exec();
    restart = async (selfId, contact3, messageId, isFront = true, reloadDeps = false) => {
      const options = {
        selfId,
        contact: contact3,
        messageId,
        time: Date.now()
      };
      const { createDB: createDB2 } = await Promise.resolve().then(() => (init_kv(), kv_exports));
      const key = `karin:restart:${selfId}`;
      const db2 = await createDB2();
      await db2.set(key, options);
      if (isFront && process.send) {
        process.send(JSON.stringify({ type: "restart", reloadDeps }));
        return { status: "success", data: "\u5DF2\u53D1\u9001\u91CD\u542F\u4FE1\u53F7" };
      }
      if (process.env.PM2_RESTART !== "true") process.exit();
      if (process.env.pm_id) {
        const { error: error2 } = await exec("npx karin rs");
        if (error2) return { status: "failed", data: error2 };
        process.exit();
      }
      const { error } = await exec("npx karin pm2");
      if (error) return { status: "failed", data: error };
      process.exit();
    };
    restartDirect = async (options) => {
      const { isPm2 = false, reloadDeps = false } = options || {};
      logger.mark("\u6536\u5230\u91CD\u542F\u8BF7\u6C42\uFF0C\u6B63\u5728\u91CD\u542F...");
      if (!isPm2 && process?.send) {
        process.send(JSON.stringify({ type: "restart", reloadDeps }));
        logger.debug("\u6B63\u5728\u901A\u77E5\u7236\u8FDB\u7A0B\u91CD\u542F...");
        return;
      }
      if (process.env.RUNTIME === "pm2") {
        if (process.env.PM2_RESTART !== "true") process.exit();
        await exec("npx karin rs");
        return;
      }
      if (process.env.RUNTIME === "tsx") {
        throw new Error("tsx \u4E0D\u652F\u6301\u91CD\u542F");
      }
      if (process.env.PM2_RESTART !== "true") process.exit();
      const { error } = await exec("npx karin pm2");
      if (error) throw error;
    };
  }
});
var call, has, handler;
var init_handler = __esm({
  "src/service/handler.ts"() {
    init_cache();
    call = async (key, args) => {
      let result;
      for (const info of cache3.handler[key] || []) {
        try {
          let done = true;
          const next = () => {
            done = false;
          };
          const res = info.fnc(args, next);
          result = util5.types.isPromise(res) ? await res : res;
          if (done) {
            logger.mark(`[Handler][Done]: [${info.pkg.name}][${info.file.method}][${key}]`);
            return result;
          }
        } catch (error) {
          logger.error(`[Handler][Error]: [${info.pkg.name}][${info.file.method}][${key}]`);
          logger.error(error);
        }
      }
      return result;
    };
    has = (key) => !!cache3.handler[key];
    handler = Object.assign(call, { call, has });
  }
});

// src/utils/system/fileToUrl.ts
var fileToUrlHandlerKey, fileToUrl;
var init_fileToUrl = __esm({
  "src/utils/system/fileToUrl.ts"() {
    init_handler();
    fileToUrlHandlerKey = "fileToUrl";
    fileToUrl = async (type, file2, filename2, args) => {
      if (!handler.has(fileToUrlHandlerKey)) throw new Error("[Handler][Error]: \u6CA1\u6709\u914D\u7F6E\u6587\u4EF6\u8F6C\u6362\u4E3Aurl\u7684\u5904\u7406\u5668");
      return handler(fileToUrlHandlerKey, { file: file2, type, filename: filename2, args });
    };
  }
});

// src/utils/system/range.ts
var parseVersion, compareVersions, matchesPattern, parseRangeCondition, satisfiesCondition, satisfies;
var init_range = __esm({
  "src/utils/system/range.ts"() {
    parseVersion = (version2) => {
      const [versionPart, prerelease] = version2.split("-");
      const parts = versionPart.split(".");
      const isWildcard = (part) => part === "x" || part === "*" || part === "X";
      const majorWildcard = parts.length > 0 && isWildcard(parts[0]);
      const minorWildcard = parts.length > 1 && isWildcard(parts[1]);
      const patchWildcard = parts.length > 2 && isWildcard(parts[2]);
      const parseNumberOrNull = (part) => {
        if (!part || isWildcard(part)) return null;
        return Number(part) || 0;
      };
      return {
        major: parseNumberOrNull(parts[0]),
        minor: parseNumberOrNull(parts[1]),
        patch: parseNumberOrNull(parts[2]),
        prerelease: prerelease || null,
        majorWildcard,
        minorWildcard,
        patchWildcard
      };
    };
    compareVersions = (v1, v2) => {
      const version1 = parseVersion(v1);
      const version2 = parseVersion(v2);
      if (version1.major !== version2.major) {
        if (version1.major === null || version2.major === null) return 0;
        return version1.major > version2.major ? 1 : -1;
      }
      if (version1.minor !== version2.minor) {
        if (version1.minor === null || version2.minor === null) return 0;
        return version1.minor > version2.minor ? 1 : -1;
      }
      if (version1.patch !== version2.patch) {
        if (version1.patch === null || version2.patch === null) return 0;
        return version1.patch > version2.patch ? 1 : -1;
      }
      if (version1.prerelease === null && version2.prerelease !== null) {
        return 1;
      }
      if (version1.prerelease !== null && version2.prerelease === null) {
        return -1;
      }
      if (version1.prerelease !== null && version2.prerelease !== null) {
        const prereleaseOrder = {
          alpha: 1,
          beta: 2,
          rc: 3
        };
        const getPrereleaseOrder = (pre) => {
          const identifier = pre.split(".")[0];
          return prereleaseOrder[identifier] || 0;
        };
        const order1 = getPrereleaseOrder(version1.prerelease);
        const order2 = getPrereleaseOrder(version2.prerelease);
        if (order1 !== order2) {
          return order1 > order2 ? 1 : -1;
        }
        const getNumericSuffix = (pre) => {
          const parts = pre.split(".");
          return parts.length > 1 ? parseInt(parts[1], 10) || 0 : 0;
        };
        const num1 = getNumericSuffix(version1.prerelease);
        const num2 = getNumericSuffix(version2.prerelease);
        if (num1 !== num2) {
          return num1 > num2 ? 1 : -1;
        }
      }
      return 0;
    };
    matchesPattern = (version2, pattern) => {
      const versionObj = parseVersion(version2);
      const patternObj = parseVersion(pattern);
      if (!patternObj.majorWildcard && versionObj.major !== patternObj.major) {
        return false;
      }
      if (!patternObj.minorWildcard && versionObj.minor !== patternObj.minor) {
        return false;
      }
      if (!patternObj.patchWildcard && versionObj.patch !== patternObj.patch) {
        return false;
      }
      if (patternObj.prerelease === null) {
        return true;
      }
      if (patternObj.prerelease !== null && versionObj.prerelease === null) {
        return false;
      }
      if (patternObj.prerelease !== null && versionObj.prerelease !== null) {
        return compareVersions(version2, pattern) === 0;
      }
      return true;
    };
    parseRangeCondition = (condition) => {
      const operators = [">=", "<=", ">", "<", "^"];
      let operator = "";
      let version2 = condition;
      for (const op of operators) {
        if (condition.startsWith(op)) {
          operator = op;
          version2 = condition.substring(op.length);
          break;
        }
      }
      return { operator, version: version2 };
    };
    satisfiesCondition = (version2, condition) => {
      const { operator, version: rangeVersion } = parseRangeCondition(condition);
      if (rangeVersion.includes("x") || rangeVersion.includes("*") || rangeVersion.includes("X")) {
        if (operator === "") {
          return matchesPattern(version2, rangeVersion);
        }
        return false;
      }
      const comparison = compareVersions(version2, rangeVersion);
      const parsedRange = parseVersion(rangeVersion);
      let upperBound;
      switch (operator) {
        case ">":
          return comparison > 0;
        case ">=":
          return comparison >= 0;
        case "<":
          return comparison < 0;
        case "<=":
          return comparison <= 0;
        case "^":
          if (compareVersions(version2, rangeVersion) < 0) {
            return false;
          }
          if (parsedRange.major === 0) {
            upperBound = `0.${parsedRange.minor + 1}.0`;
          } else {
            upperBound = `${parsedRange.major + 1}.0.0`;
          }
          return compareVersions(version2, upperBound) < 0;
        default:
          return comparison === 0;
      }
    };
    satisfies = (satisfies2, version2) => {
      const conditions = satisfies2.split(" ");
      return conditions.every((condition) => satisfiesCondition(version2, condition));
    };
  }
});

// src/utils/system/index.ts
var system_exports = {};
__export(system_exports, {
  checkGitPluginUpdate: () => checkGitPluginUpdate,
  checkPkgUpdate: () => checkPkgUpdate,
  checkPort: () => checkPort,
  errorToString: () => errorToString,
  exec: () => exec,
  ffmpeg: () => ffmpeg,
  ffplay: () => ffplay,
  ffprobe: () => ffprobe,
  fileToUrl: () => fileToUrl,
  fileToUrlHandlerKey: () => fileToUrlHandlerKey,
  formatTime: () => formatTime,
  getCommit: () => getCommit,
  getHash: () => getHash,
  getPid: () => getPid,
  getPkgVersion: () => getPkgVersion,
  getRemotePkgVersion: () => getRemotePkgVersion,
  getRequestIp: () => getRequestIp,
  getTime: () => getTime,
  importModule: () => importModule,
  imports: () => imports,
  isClass: () => isClass,
  isDocker: () => isDocker,
  isIPv4Loop: () => isIPv4Loop,
  isIPv6Loop: () => isIPv6Loop,
  isLinux: () => isLinux,
  isLocalRequest: () => isLocalRequest,
  isLoopback: () => isLoopback,
  isMac: () => isMac,
  isRoot: () => isRoot,
  isWin: () => isWin2,
  killApp: () => killApp,
  lock: () => lock,
  lockMethod: () => lockMethod,
  lockProp: () => lockProp,
  restart: () => restart,
  restartDirect: () => restartDirect,
  satisfies: () => satisfies,
  stringifyError: () => stringifyError,
  updateAllGitPlugin: () => updateAllGitPlugin,
  updateAllPkg: () => updateAllPkg,
  updateGitPlugin: () => updateGitPlugin,
  updatePkg: () => updatePkg,
  uptime: () => uptime,
  waitPort: () => waitPort
});
var init_system2 = __esm({
  "src/utils/system/index.ts"() {
    init_ip();
    init_pid();
    init_exec();
    init_time();
    init_class();
    init_error2();
    init_port();
    init_ffmpeg();
    init_import();
    init_lock();
    init_system();
    init_update();
    init_restart();
    init_fileToUrl();
    init_range();
  }
});
var isInit, cache5, resetCache, initCache, setCachedList, setCachedInfo, getCachedData, createPkg, getAppInfo, getGitInfo, getNpmInfo, getPluginsInfo, collectAppPlugins, collectGitPlugins, NPM_EXCLUDE_LIST, collectNpmPlugins, collectAllPlugins, getPlugins;
var init_list = __esm({
  "src/plugin/system/list.ts"() {
    init_env2();
    init_env4();
    init_system2();
    init_root();
    init_path();
    init_env3();
    init_require();
    isInit = true;
    cache5 = {
      list: void 0,
      info: void 0
    };
    resetCache = () => {
      delete cache5.list;
      delete cache5.info;
    };
    initCache = () => {
      if (!cache5.list) {
        cache5.list = {};
      }
      if (!cache5.info) {
        cache5.info = {};
      }
    };
    setCachedList = (type, list2) => {
      cache5.list[type] = list2;
      setTimeout(() => delete cache5?.list?.[type], 60 * 1e3);
    };
    setCachedInfo = (type, info) => {
      cache5.info[type] = info;
      setTimeout(() => delete cache5?.info?.[type], 60 * 1e3);
    };
    getCachedData = (type, isInfo) => {
      if (isInfo) {
        if (cache5?.info?.[type] && !lodash3.isEqual(cache5.info[type], cache5.info[type])) {
          return cache5.info[type];
        }
      } else {
        if (cache5?.list?.[type] && !lodash3.isEqual(cache5.list[type], cache5.list[type])) {
          return cache5.list[type];
        }
      }
      return void 0;
    };
    createPkg = (type, name, dir, apps, allApps, isForce) => ({
      type,
      name,
      apps,
      allApps,
      dir,
      id: -1,
      get pkgPath() {
        const file2 = path4.join(this.dir, "package.json");
        return fs5.existsSync(file2) ? file2 : "";
      },
      get pkgData() {
        if (!this.pkgPath) return {};
        return requireFileSync(this.pkgPath, { force: isForce });
      }
    });
    getAppInfo = async (info, dir, name, ext, isForce) => {
      const apps = filesByExt(dir, ext, "abs");
      info.push(createPkg("app", name, dir, apps, [dir], isForce));
    };
    getGitInfo = async (info, dir, name, ext, isForce, env3) => {
      const pkg2 = await requireFile(path4.join(dir, "package.json"));
      if (!pkg2 || !pkg2.karin) {
        info.push(createPkg("git", name, dir, [], [], isForce));
        return;
      }
      if (Array.isArray(pkg2.env)) {
        createAddEnv(env3)(pkg2.name, pkg2.env);
      }
      const apps = [];
      const files = [];
      const allApps = [];
      const pushApps = (app5) => {
        if (typeof app5 === "string") {
          files.push(app5);
        } else if (Array.isArray(app5)) {
          files.push(...app5);
        }
      };
      if (isTs()) {
        pkg2.karin["ts-apps"] && pushApps(pkg2.karin["ts-apps"]);
      } else {
        pkg2.karin.apps && pushApps(pkg2.karin.apps);
      }
      await Promise.allSettled(
        files.map(async (app5) => {
          const appPath = path4.join(dir, app5);
          if (!fs5.existsSync(appPath)) return;
          apps.push(...filesByExt(appPath, ext, "abs"));
          allApps.push(appPath);
        })
      );
      info.push(createPkg("git", name, dir, apps, allApps, isForce));
    };
    getNpmInfo = async (info, dir, name, isForce, env3) => {
      const ext = ".js";
      let apps = [];
      let allApps = [];
      const pkg2 = await requireFile(path4.join(dir, "package.json"));
      if (!pkg2.karin?.apps?.length) {
        info.push(createPkg("npm", name, dir, [], [], isForce));
        return;
      }
      if (Array.isArray(pkg2.env)) {
        createAddEnv(env3)(pkg2.name, pkg2.env);
      }
      const files = [];
      if (typeof pkg2.karin.apps === "string") {
        files.push(pkg2.karin.apps);
      } else if (Array.isArray(pkg2.karin.apps)) {
        files.push(...pkg2.karin.apps);
      }
      await Promise.allSettled(
        files.map(async (app5) => {
          const appPath = path4.join(dir, app5);
          if (!fs5.existsSync(appPath)) return;
          apps.push(...filesByExt(appPath, ext, "abs"));
          allApps.push(appPath);
        })
      );
      apps = apps.map(formatPath);
      allApps = allApps.map(formatPath);
      info.push(createPkg("npm", name, dir, apps, allApps, isForce));
    };
    getPluginsInfo = async (list2, isForce, isFirst) => {
      const info = [];
      const ext = isTs() ? [".ts", ".js"] : [".js"];
      const env3 = isFirst ? [] : null;
      await Promise.allSettled(
        list2.map(async (v) => {
          const [type, name] = v.split(":");
          if (type === "app") {
            const file2 = path4.join(karinPathPlugins, name);
            await getAppInfo(info, file2, name, ext, isForce);
            return;
          }
          if (type === "git" || type === "root") {
            const file2 = type === "root" ? process.cwd() : path4.join(karinPathPlugins, name);
            await getGitInfo(info, file2, name, ext, isForce, env3);
            return;
          }
          if (type === "npm") {
            const file2 = path4.join(process.cwd(), "node_modules", name);
            await getNpmInfo(info, file2, name, isForce, env3);
          }
        })
      );
      if (env3 && env3.length) {
        logger.debug("[getPluginsInfo] \u5904\u7406\u73AF\u5883\u53D8\u91CF \u540C\u6B65\u5199\u5165", JSON.stringify(env3, null, 2));
        writeEnv(env3);
      } else {
        logger.debug("[getPluginsInfo] \u5904\u7406\u73AF\u5883\u53D8\u91CF \u672A\u6536\u96C6\u5230\u73AF\u5883\u53D8\u91CF \u8DF3\u8FC7\u5199\u5165");
      }
      return info;
    };
    collectAppPlugins = async (files, list2) => {
      await Promise.all(
        files.map(async (v) => {
          if (!v.isDirectory()) return;
          if (!v.name.startsWith("karin-plugin-")) return;
          if (fs5.existsSync(`${karinPathPlugins}/${v.name}/package.json`)) return;
          list2.push(`app:${v.name}`);
        })
      );
    };
    collectGitPlugins = async (files, list2) => {
      await Promise.all(
        files.map(async (v) => {
          if (!v.isDirectory()) return;
          if (!v.name.startsWith("karin-plugin-")) return;
          if (!fs5.existsSync(path4.join(karinPathPlugins, v.name, "package.json"))) return;
          const pkg2 = await requireFile(path4.join(karinPathPlugins, v.name, "package.json"));
          const engines = pkg2?.karin?.engines?.karin || pkg2?.engines?.karin;
          if (engines && !satisfies(engines, process.env.KARIN_VERSION)) {
            const msg = `[getPlugins][git] ${v.name} \u8981\u6C42 node-karin \u7248\u672C\u4E3A ${engines}\uFF0C\u5F53\u524D\u4E0D\u7B26\u5408\u8981\u6C42\uFF0C\u8DF3\u8FC7\u52A0\u8F7D\u63D2\u4EF6`;
            isInit && setTimeout(() => logger.error(msg), 1e3);
            return;
          }
          list2.push(`git:${v.name}`);
        })
      );
      const root = await requireFile("./package.json");
      if (root.name && root.karin) list2.push(`root:${root.name}`);
    };
    NPM_EXCLUDE_LIST = [
      "@karinjs/node-pty",
      "@karinjs/plugin-webui-network-monitor",
      "@karinjs/plugins-list",
      "@types/express",
      "@types/lodash",
      "@types/node-schedule",
      "@types/ws",
      "art-template",
      "axios",
      "chalk",
      "chokidar",
      "commander",
      "dotenv",
      "express",
      "level",
      "lodash",
      "log4js",
      "moment",
      "node-schedule",
      "redis",
      "ws",
      "yaml",
      "sqlite3"
    ];
    collectNpmPlugins = async (list2) => {
      logger.debug("[collectNpmPlugins] \u5F00\u59CB\u6536\u96C6NPM\u63D2\u4EF6");
      const pkg2 = await requireFile("./package.json", { force: true });
      const dependencies = [
        ...Object.keys(pkg2.dependencies || {}),
        ...Object.keys(pkg2.devDependencies || {})
      ].filter((name) => !NPM_EXCLUDE_LIST.includes(name) && !name.startsWith("@types"));
      await Promise.allSettled(
        dependencies.map(async (name) => {
          const file2 = path4.join(process.cwd(), "node_modules", name, "package.json");
          const pkg3 = await requireFile(file2);
          if (!pkg3.karin) return;
          const engines = pkg3.karin?.engines?.karin || pkg3.engines?.karin;
          if (engines) {
            if (!satisfies(engines, process.env.KARIN_VERSION)) {
              isInit && logger.error(
                `[getPlugins][npm] ${name} \u8981\u6C42 node-karin \u7248\u672C\u4E3A ${engines}\uFF0C\u5F53\u524D\u4E0D\u7B26\u5408\u8981\u6C42\uFF0C\u8DF3\u8FC7\u52A0\u8F7D\u63D2\u4EF6`
              );
              return;
            }
          }
          list2.push(`npm:${name}`);
        })
      );
    };
    collectAllPlugins = async (files, list2) => {
      await Promise.all([
        collectAppPlugins(files, list2),
        collectGitPlugins(files, list2),
        collectNpmPlugins(list2)
      ]);
    };
    getPlugins = async (type, isInfo, isForce = false, _isFirst = false) => {
      if (isForce) {
        resetCache();
      }
      const cachedData = getCachedData(type, isInfo);
      if (cachedData) {
        return cachedData;
      }
      initCache();
      if (!["npm", "all", "git", "app"].includes(type)) return [];
      const list2 = [];
      const files = type === "npm" ? [] : fs5.existsSync(karinPathPlugins) ? await fs5.promises.readdir(karinPathPlugins, { withFileTypes: true }) : [];
      switch (type) {
        case "app":
          await collectAppPlugins(files, list2);
          break;
        case "git":
          await collectGitPlugins(files, list2);
          break;
        case "npm":
          await collectNpmPlugins(list2);
          break;
        case "all":
          await collectAllPlugins(files, list2);
          break;
      }
      setCachedList(type, list2);
      if (!isInfo) {
        return list2;
      }
      const info = await getPluginsInfo(list2, isForce, _isFirst);
      setCachedInfo(type, info);
      if (isInit) isInit = false;
      return info;
    };
  }
});

// src/utils/common/string.ts
var strToBool;
var init_string = __esm({
  "src/utils/common/string.ts"() {
    strToBool = {
      /**
       * 将数组中的所有元素转换为字符串 使用`String`转换
       * @param arr 需要转换的数组
       * @returns 转换后的字符串
       * @example strToBool.array([1, '2']) // ['1', '2']
       *          strToBool.array(['3', null, undefined, NaN, '']) // ['3']
       */
      array: (arr) => arr.map(String).filter((item) => item.length > 0),
      /**
       * 排除数组中所有非字符串的元素
       * @param arr 需要转换的数组
       * @returns 转换后的字符串
       * @example strToBool.arrayExcludeNonString(['1', '2', '3']) // ['1', '2', '3']
       *          strToBool.arrayExcludeNonString(['1', '2', '3', null, undefined, NaN, '']) // ['1', '2', '3']
       */
      arrayExcludeNonString: (arr) => arr.filter((item) => typeof item === "string" && item.length > 0),
      /**
       * 将字符串转换为布尔值
       * @param str 需要转换的字符串
       * @returns 转换后的布尔值
       * @example strToBool.string('true') // true
       *          strToBool.string('1') // true
       *          strToBool.string('yes') // true
       *          strToBool.string('on') // true
       *          strToBool.string('false') // false
       *          strToBool.string('0') // false
       *          strToBool.string('no') // false
       */
      string: (str) => str === "true" || str === "1" || str === "yes" || str === "on",
      /**
       * 将字符串转换为数字
       * @param str 需要转换的字符串
       * @param defaultValue 默认值 如果非数字 返回默认值
       * @returns 转换后的数字
       * @example strToBool.number('1') // 1
       *          strToBool.number('2') // 2
       *          strToBool.number('3') // 3
       *          strToBool.number('abc', 123) // 123
       */
      number: (str, defaultValue = 0) => {
        const num = Number(str);
        if (typeof num === "number") return num;
        return defaultValue;
      },
      /**
       * 将字符串数组转换为数字数组
       * @param arr 需要转换的数组
       * @returns 转换后的数字数组
       * @example strToBool.arrayNumber(['1', '2', '3']) // [1, 2, 3]
       */
      arrayNumber: (arr) => {
        const list2 = [];
        for (const str of arr) {
          const num = Number(str);
          if (typeof num === "number") list2.push(num);
        }
        return list2;
      },
      /**
       * 传入一个数组 按照索引返回数组 并且将这个数组转换为字符串数组 去掉重复、非字符串的元素
       * @param arr 需要转换的数组
       * @param index 需要返回的索引
       * @returns 转换后的字符串数组
       * @example strToBool.arrayString(['1', '2', '3'], 0) // ['1']
       */
      arrayString: (arr) => {
        for (const item of arr) {
          if (!Array.isArray(item)) continue;
          return strToBool.arrayExcludeNonString(item);
        }
        return [];
      },
      /**
       * 合并多个数组为一个并去重 如果不是数组将会跳过
       * @param arr 需要合并的数组
       * @returns 合并后的数组
       * @example strToBool.mergeArray(['1', '2', '3'], ['4', '5', '6']) // ['1', '2', '3', '4', '5', '6']
       *          strToBool.mergeArray(['4', '5', '6'], ['4', '5', '6']) // ['4', '5', '6']
       */
      mergeArray: (...arr) => {
        const list2 = [];
        for (const item of arr) {
          if (!Array.isArray(item)) continue;
          list2.push(...item);
        }
        return [...new Set(list2)];
      }
    };
  }
});

// src/utils/common/uptime.ts
var uptime2;
var init_uptime = __esm({
  "src/utils/common/uptime.ts"() {
    uptime2 = () => {
      const time2 = process.uptime();
      const day = Math.floor(time2 / 86400);
      const hour = Math.floor(time2 % 86400 / 3600);
      const min = Math.floor(time2 % 3600 / 60);
      const sec = Math.floor(time2 % 60);
      const parts = [day ? `${day}\u5929` : "", hour ? `${hour}\u5C0F\u65F6` : "", min ? `${min}\u5206\u949F` : "", !day && sec ? `${sec}\u79D2` : ""];
      return parts.filter(Boolean).join("");
    };
  }
});

// src/utils/button/convert.ts
var karinToQQBot, qqbotToKarin;
var init_convert2 = __esm({
  "src/utils/button/convert.ts"() {
    karinToQQBot = (button3) => {
      let id = 0;
      const rows = [];
      const list2 = [];
      button3.type === "button" ? list2.push(button3.data) : list2.push(...button3.rows);
      for (const row of list2) {
        const buttons = [];
        for (const i of row) {
          const type = i.link ? 0 : i.callback ? 1 : i.type ?? 2;
          const data = {
            id: String(id),
            render_data: {
              label: i.text || i.link || "",
              style: i.style ?? 0,
              visited_label: i.show || i.text || i.link || ""
            },
            action: {
              type,
              data: i.data || i.link || i.text,
              unsupport_tips: i.tips || ".",
              permission: { type: 2 }
            }
          };
          if (i.enter) data.action.enter = true;
          if (i.reply) data.action.reply = true;
          if (i.admin) data.action.permission.type = 1;
          if (i.list) {
            data.action.permission.type = 0;
            data.action.permission.specify_user_ids = i.list;
          } else if (i.role) {
            data.action.permission.type = 3;
            data.action.permission.specify_role_ids = i.role;
          }
          buttons.push(data);
          id++;
        }
        rows.push({ buttons });
      }
      return rows;
    };
    qqbotToKarin = (button3) => {
      const msg = [];
      const setPermission = (data, value) => {
        if (value.action.permission.type === 1) {
          data.admin = true;
        } else if (value.action.permission.type === 0) {
          data.list = value.action.permission.specify_user_ids || [];
        } else if (value.action.permission.type === 3) {
          data.role = value.action.permission.specify_role_ids || [];
        }
        const text2 = Object.entries(data).map(([key, value2]) => `${key}:${Array.isArray(value2) ? value2.toString() : value2}`).join(",");
        msg.push(`[button:${text2}]`);
      };
      for (const row of button3) {
        for (const i of row.buttons) {
          if (i.action.type === 0) {
            const obj2 = {
              link: i.action.data,
              text: i.render_data.label,
              show: i.render_data.visited_label,
              style: i.render_data.style,
              tips: i.action.unsupport_tips
            };
            setPermission(obj2, i);
            continue;
          }
          if (i.action.type === 1) {
            const obj2 = {
              text: i.render_data.label,
              show: i.render_data.visited_label,
              style: i.render_data.style,
              tips: i.action.unsupport_tips,
              callback: true
            };
            setPermission(obj2, i);
            continue;
          }
          const obj = {
            text: i.render_data.label,
            show: i.render_data.visited_label,
            style: i.render_data.style,
            tips: i.action.unsupport_tips
          };
          if (i.action.enter) obj.enter = true;
          if (i.action.reply) obj.reply = true;
          setPermission(obj, i);
        }
      }
      return msg.join("");
    };
  }
});

// src/utils/common/index.ts
var common_exports = {};
__export(common_exports, {
  absPath: () => absPath,
  average: () => average,
  axios: () => axios3,
  base64: () => base64,
  buffer: () => buffer,
  buttonToQQBot: () => karinToQQBot,
  clamp: () => clamp,
  createRawMessage: () => createRawMessage,
  diffArray: () => diffArray,
  diffSimpleArray: () => diffSimpleArray,
  downFile: () => downFile,
  exists: () => existToMkdir,
  formatNumber: () => formatNumber,
  formatTime: () => formatTime2,
  formatUnit: () => formatUnit,
  getAbsPath: () => getAbsPath,
  getGitPlugins: () => getGitPlugins,
  getNpmPlugins: () => getNpmPlugins,
  getPlugins: () => getPlugins2,
  getRelPath: () => getRelPath,
  isDir: () => isDir,
  isEven: () => isEven,
  isNumber: () => isNumber,
  isNumberInArray: () => isNumberInArray,
  isPlugin: () => isPlugin,
  karinToQQBot: () => karinToQQBot,
  makeForward: () => makeForward,
  makeMessage: () => makeMessage,
  makeMessageLog: () => createRawMessage,
  mergeImage: () => mergeImage,
  mkdir: () => mkdirSync,
  percentage: () => percentage,
  pkgJson: () => getPluginInfo,
  pkgroot: () => pkgRoot,
  qqbotToKarin: () => qqbotToKarin,
  random: () => random,
  readJson: () => readJsonSync,
  readYaml: () => read,
  round: () => round,
  sleep: () => sleep,
  splitPath: () => splitPath,
  strToBool: () => strToBool,
  stream: () => stream,
  updateYaml: () => updateYaml,
  uptime: () => uptime2,
  urlToPath: () => urlToPath,
  writeJson: () => writeJsonSync,
  writeYaml: () => write
});
var axios3, formatTime2, updateYaml, getNpmPlugins, getPlugins2, getGitPlugins, mergeImage, getAbsPath, getImageSize, generateLayout, buildFilterComplex;
var init_common = __esm({
  "src/utils/common/index.ts"() {
    init_root();
    init_yaml();
    init_ffmpeg();
    init_list();
    init_time();
    init_number();
    init_string();
    init_sleep();
    init_uptime();
    init_file();
    init_fsSync();
    init_data();
    init_path();
    init_fsPromises();
    init_yaml();
    init_json();
    init_pkg2();
    init_convert2();
    init_message();
    axios3 = async (paramOrUrl, type, param) => {
      try {
        const config3 = typeof paramOrUrl === "string" ? { ...param, url: paramOrUrl, method: type } : paramOrUrl;
        return await axios8(config3);
      } catch (error) {
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) return void 0;
        }
        logger.debug("[common] axios\u8BF7\u6C42\u5931\u8D25:");
        logger.debug(error.stack || error);
        return null;
      }
    };
    formatTime2 = formatTime;
    updateYaml = (filePath, settings) => {
      let yaml4 = new YamlEditor(filePath);
      settings.forEach(({ key, val }) => {
        try {
          if (!yaml4.has(key)) yaml4.set(key, val);
        } catch (error) {
          logger.error(`[common] \u66F4\u65B0yaml\u6587\u4EF6\u65F6\u51FA\u9519\uFF1A${error.stack || error.message || error}`);
        }
      });
      yaml4.save();
      yaml4 = new YamlEditor(filePath);
      settings.forEach(({ key, comment: comment2, type }) => {
        try {
          yaml4.comment(key, comment2, type === "top");
        } catch (error) {
          logger.error(`[common] \u66F4\u65B0yaml\u6587\u4EF6\u65F6\u51FA\u9519\uFF1A${error.stack || error.message || error}`);
        }
      });
      yaml4.save();
    };
    getNpmPlugins = async (showDetails = false) => getPlugins("npm", showDetails);
    getPlugins2 = async (_ = false) => getPlugins("git", false);
    getGitPlugins = async (isPack = false) => getPlugins("git", isPack);
    mergeImage = async (images, perRow = 3) => {
      if (images.length < 2) throw Error("\u56FE\u7247\u6570\u91CF\u5FC5\u987B\u5927\u4E8E1");
      const root = path4.join(tempPath, "mergeImage");
      const rootTemp = path4.join(root, Date.now().toString());
      fs5.mkdirSync(rootTemp, { recursive: true });
      const files = getAbsPath(images, rootTemp);
      const filterComplex = await buildFilterComplex(files, perRow);
      const inputImages = files.map((file2) => `-i "${file2}"`).join(" ");
      const output = path4.join(rootTemp, "output.png");
      const ffmpegCmd = `${inputImages} -filter_complex "${filterComplex}" -map "[out]" ${output}`;
      const result = await ffmpeg(ffmpegCmd);
      if (!result.status) {
        logger.error("[common] \u5408\u5E76\u56FE\u7247\u5931\u8D25:");
        throw result.error;
      }
      const { height, width } = await getImageSize(output);
      const base642 = await fs5.promises.readFile(output, "base64");
      setTimeout(() => fs5.promises.rm(rootTemp, { recursive: true, force: true }), 100);
      return { base64: base642, height, width };
    };
    getAbsPath = (images, root) => {
      const files = [];
      images.forEach((image2, index6) => {
        if (typeof image2 !== "string") throw TypeError("\u4F20\u5165\u7684\u56FE\u7247\u53EA\u652F\u6301\u672C\u5730\u8DEF\u5F84 \u6216 \u5E26\u524D\u7F00base64://\u5B57\u7B26\u4E32");
        if (image2.startsWith("base64://")) {
          const base642 = image2.replace(/^base64:\/\//, "");
          const buffer2 = Buffer.from(base642, "base64");
          const file3 = path4.join(root, `${index6}.png`);
          fs5.writeFileSync(file3, buffer2);
          files.push(file3);
          return;
        }
        if (!fs5.existsSync(image2)) throw Error(`\u56FE\u7247\u8DEF\u5F84\u4E0D\u5B58\u5728: ${image2}`);
        const file2 = path4.join(root, path4.basename(image2));
        fs5.copyFileSync(image2, file2);
        files.push(file2);
      });
      return files;
    };
    getImageSize = async (file2) => {
      const { stdout } = await ffprobe(`-v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "${file2}"`);
      const [width, height] = stdout.trim().split(",").map(Number);
      return { width, height };
    };
    generateLayout = (dimensions, perRow, maxWidth, maxHeight) => {
      const layouts = dimensions.map((_, index6) => {
        const row = Math.floor(index6 / perRow);
        const col = index6 % perRow;
        return `${col * maxWidth}_${row * maxHeight}`;
      }).join("|");
      return layouts;
    };
    buildFilterComplex = async (files, perRow) => {
      const list2 = await Promise.all(
        files.map(async (file2) => {
          const { width, height } = await getImageSize(file2);
          return { file: file2, width, height };
        })
      );
      const maxWidth = Math.max(...list2.map((d) => d.width));
      const maxHeight = Math.max(...list2.map((d) => d.height));
      let cmd = "";
      list2.forEach((_, index6) => {
        cmd += `[${index6}:v]pad=${maxWidth}:${maxHeight}:(ow-iw)/2:(oh-ih)/2[p${index6}]; `;
      });
      const layouts = generateLayout(list2, perRow, maxWidth, maxHeight);
      cmd += `${list2.map((_, index6) => `[p${index6}]`).join("")}xstack=inputs=${list2.length}:layout=${layouts}[out]`;
      return cmd;
    };
  }
});

// src/event/handler/other/handler.ts
var log2, initMsg, initRole, initAlias, initEmit, disableViaAdapter, disableViaPluginWhitelist, disableViaPluginBlacklist, privateFilterEvent, groupFilterEvent, groupPrint, guildPrint;
var init_handler2 = __esm({
  "src/event/handler/other/handler.ts"() {
    init_key2();
    init_lock();
    init_internal();
    init_common();
    log2 = (logText, text2) => logger.debug(`[\u6D88\u606F\u8FC7\u6EE4]${logText} ${text2}`);
    initMsg = (ctx3) => {
      const { msg, raw: raw2 } = createRawMessage(ctx3.elements);
      ctx3.msg = msg;
      ctx3.rawMessage = raw2;
    };
    initRole = (ctx3, config3) => {
      if (config3.master.includes(`${ctx3.selfId}@${ctx3.userId}`) || config3.master.includes(ctx3.userId)) {
        ctx3.isMaster = true;
        ctx3.isAdmin = true;
      } else if (config3.admin.includes(`${ctx3.selfId}@${ctx3.userId}`) || config3.admin.includes(ctx3.userId)) {
        ctx3.isAdmin = true;
        ctx3.isMaster = false;
      } else {
        ctx3.isAdmin = false;
        ctx3.isMaster = false;
      }
      lock.prop(ctx3, "isMaster");
      lock.prop(ctx3, "isAdmin");
    };
    initAlias = (ctx3, alias) => {
      const aliasRegex = new RegExp(`^(${alias.join("|")})`);
      const match = ctx3.msg.match(aliasRegex);
      if (!match) {
        ctx3.alias = "";
        return;
      }
      ctx3.msg = ctx3.msg.replace(aliasRegex, "").trim();
      ctx3.alias = match[1] || "";
    };
    initEmit = (ctx3) => {
      listeners.emit(RECV_MSG, ctx3.contact);
    };
    disableViaAdapter = (plugin, protocol) => {
      if (plugin.adapter.length && !plugin.adapter.includes(protocol)) {
        return false;
      }
      if (plugin.dsbAdapter.length && plugin.dsbAdapter.includes(protocol)) {
        return false;
      }
      return true;
    };
    disableViaPluginWhitelist = (plugin, config3) => {
      if (!config3.enable.length) return true;
      const list2 = [
        plugin.pkg.name,
        `${plugin.pkg.name}:${plugin.file.basename}`,
        `${plugin.pkg.name}:${plugin.file.method}`
      ];
      for (const item of list2) {
        if (config3.enable.includes(item)) {
          return true;
        }
      }
      return false;
    };
    disableViaPluginBlacklist = (plugin, config3) => {
      if (!config3.disable.length) return true;
      const list2 = [
        plugin.pkg.name,
        `${plugin.pkg.name}:${plugin.file.basename}`,
        `${plugin.pkg.name}:${plugin.file.method}`
      ];
      for (const item of list2) {
        if (config3.disable.includes(item)) {
          return false;
        }
      }
      return true;
    };
    privateFilterEvent = (ctx3, config3, friend, cd) => {
      const runLog = (text2) => log2(ctx3.logText, `${text2}: ${ctx3.eventId}`);
      if (ctx3.isFriend) {
        if (!config3?.friend?.enable) {
          runLog("\u5F53\u524D\u597D\u53CB\u4E8B\u4EF6\u672A\u542F\u7528");
          return false;
        }
      } else {
        if (!config3?.directs?.enable) {
          runLog("\u5F53\u524D\u9891\u9053\u79C1\u4FE1\u4E8B\u4EF6\u672A\u542F\u7528");
          return false;
        }
      }
      if (!cd) {
        runLog("\u5F53\u524D\u5904\u4E8ECD\u4E2D");
        return false;
      }
      if (config3?.user?.enable_list?.length && !config3?.user?.enable_list.includes(ctx3.userId)) {
        runLog("\u7528\u6237\u672A\u5904\u4E8E\u767D\u540D\u5355");
        return false;
      }
      if (config3?.user?.disable_list?.length && config3?.user?.disable_list.includes(ctx3.userId)) {
        runLog("\u7528\u6237\u5904\u4E8E\u9ED1\u540D\u5355");
        return false;
      }
      if (ctx3.event !== "message") {
        return true;
      }
      const modeMap = {
        0: () => true,
        2: () => {
          if (!ctx3.isAdmin && !ctx3.isMaster) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8\u7BA1\u7406\u5458\u4F7F\u7528");
            return false;
          }
          return true;
        },
        3: () => {
          if (!ctx3.alias) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8Bot\u522B\u540D\u89E6\u53D1\u4F7F\u7528");
            return false;
          }
          return true;
        },
        5: () => {
          if (!ctx3.isAdmin && !ctx3.isMaster && !ctx3.alias && !ctx3.atBot) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8@\u6216\u522B\u540D\u89E6\u53D1(\u7BA1\u7406\u5458\u4F8B\u5916)");
            return false;
          }
          return true;
        },
        6: () => {
          if (!ctx3.isMaster) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8\u4E3B\u4EBA\u4F7F\u7528");
            return false;
          }
          return true;
        },
        default: () => true
      };
      const mode = modeMap[friend.mode] || modeMap.default;
      return mode();
    };
    groupFilterEvent = (ctx3, config3, group, cd) => {
      const runLog = (text2) => log2(ctx3.logText, `${text2}: ${ctx3.eventId}`);
      if (ctx3.isGroup) {
        if (!config3?.group?.enable) {
          runLog("\u5F53\u524D\u7FA4\u4E8B\u4EF6\u672A\u542F\u7528");
          return false;
        }
      } else if (ctx3.isGuild) {
        if (!config3?.guilds?.enable) {
          runLog("\u5F53\u524D\u9891\u9053\u4E8B\u4EF6\u672A\u542F\u7528");
          return false;
        }
      }
      if (!cd) {
        runLog("\u5F53\u524D\u5904\u4E8ECD\u4E2D");
        return false;
      }
      if (config3?.user?.enable_list?.length) {
        if (!config3?.user?.enable_list.includes(ctx3.userId)) {
          runLog("\u7528\u6237\u672A\u5904\u4E8E\u767D\u540D\u5355");
          return false;
        }
      }
      if (config3?.user?.disable_list?.length) {
        if (config3?.user?.disable_list.includes(ctx3.userId)) {
          runLog("\u7528\u6237\u5904\u4E8E\u9ED1\u540D\u5355");
          return false;
        }
      }
      if (ctx3.isGroup) {
        if (config3?.group?.enable_list?.length && !config3?.group?.enable_list.includes(ctx3.groupId)) {
          runLog("\u7FA4\u672A\u5904\u4E8E\u767D\u540D\u5355");
          return false;
        }
        if (config3?.group?.disable_list?.length && config3?.group?.disable_list.includes(ctx3.groupId)) {
          runLog("\u7FA4\u5904\u4E8E\u9ED1\u540D\u5355");
          return false;
        }
        if (group.member_enable?.length && !group.member_enable.includes(ctx3.userId)) {
          runLog("\u7528\u6237\u672A\u5904\u4E8E\u7FA4\u6210\u5458\u767D\u540D\u5355");
          return false;
        }
        if (group.member_disable?.length && group.member_disable.includes(ctx3.userId)) {
          runLog("\u7528\u6237\u5904\u4E8E\u7FA4\u6210\u5458\u9ED1\u540D\u5355");
          return false;
        }
      }
      if (ctx3.isGuild) {
        if (config3?.guilds?.enable_list?.length && !config3?.guilds?.enable_list.includes(ctx3.guildId)) {
          runLog("\u9891\u9053\u672A\u5904\u4E8E\u767D\u540D\u5355");
          return false;
        }
        if (config3?.guilds?.disable_list?.length && config3?.guilds?.disable_list.includes(ctx3.guildId)) {
          runLog("\u9891\u9053\u5904\u4E8E\u9ED1\u540D\u5355");
          return false;
        }
        if (config3?.channels?.enable_list?.length && !config3?.channels?.enable_list.includes(ctx3.channelId)) {
          runLog("\u5B50\u9891\u9053\u672A\u5904\u4E8E\u767D\u540D\u5355");
          return false;
        }
        if (config3?.channels?.disable_list?.length && config3?.channels?.disable_list.includes(ctx3.channelId)) {
          runLog("\u5B50\u9891\u9053\u5904\u4E8E\u9ED1\u540D\u5355");
          return false;
        }
        if (group.member_enable?.length && !group.member_enable.includes(ctx3.userId)) {
          runLog("\u7528\u6237\u672A\u5904\u4E8E\u9891\u9053\u6210\u5458\u767D\u540D\u5355");
          return false;
        }
        if (group.member_disable?.length && group.member_disable.includes(ctx3.userId)) {
          runLog("\u7528\u6237\u5904\u4E8E\u9891\u9053\u6210\u5458\u9ED1\u540D\u5355");
          return false;
        }
      }
      if (ctx3.event !== "message") {
        return true;
      }
      const modeMap = {
        0: () => true,
        1: () => {
          if (!ctx3.atBot) {
            runLog("\u5F53\u524D\u54CD\u5E94\u6A21\u5F0F\u4EC5\u5141\u8BB8@\u673A\u5668\u4EBA\u4F7F\u7528");
            return false;
          }
          return true;
        },
        2: () => {
          if (!ctx3.isAdmin && !ctx3.isMaster) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8\u7BA1\u7406\u5458\u4F7F\u7528");
            return false;
          }
          return true;
        },
        3: () => {
          if (!ctx3.alias) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8Bot\u522B\u540D\u89E6\u53D1\u4F7F\u7528");
            return false;
          }
          return true;
        },
        4: () => {
          if (!ctx3.alias && !ctx3.atBot) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8Bot\u522B\u540D\u6216@\u673A\u5668\u4EBA\u89E6\u53D1\u4F7F\u7528");
            return false;
          }
          return true;
        },
        5: () => {
          if (!ctx3.isAdmin && !ctx3.isMaster && !ctx3.alias && !ctx3.atBot) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8@\u6216\u522B\u540D\u89E6\u53D1(\u7BA1\u7406\u5458\u4F8B\u5916)");
            return false;
          }
          return true;
        },
        6: () => {
          if (!ctx3.isMaster) {
            runLog("\u5F53\u524D\u4EC5\u5141\u8BB8\u4E3B\u4EBA\u4F7F\u7528");
            return false;
          }
          return true;
        },
        default: () => true
      };
      const mode = modeMap[group.mode] || modeMap.default;
      return mode();
    };
    groupPrint = (ctx3, config3) => {
      if (config3?.group?.log_enable_list?.length && !config3?.group?.log_enable_list.includes(ctx3.groupId)) {
        log2(ctx3.logText, `\u7FA4\u672A\u5904\u4E8E\u767D\u540D\u5355: ${ctx3.eventId}`);
        return false;
      }
      if (config3?.group?.log_disable_list?.length && config3?.group?.log_disable_list.includes(ctx3.groupId)) {
        log2(ctx3.logText, `\u7FA4\u5904\u4E8E\u9ED1\u540D\u5355: ${ctx3.eventId}`);
        return false;
      }
      return true;
    };
    guildPrint = (ctx3, config3) => {
      const runLog = (text2) => log2(ctx3.logText, `${text2}: ${ctx3.eventId}`);
      if (config3?.guilds?.log_enable_list?.length && !config3?.guilds?.log_enable_list.includes(ctx3.guildId)) {
        runLog("\u9891\u9053\u65E5\u5FD7\u672A\u5904\u4E8E\u767D\u540D\u5355");
        return false;
      }
      if (config3?.guilds?.log_disable_list?.length && config3?.guilds?.log_disable_list.includes(ctx3.guildId)) {
        runLog("\u9891\u9053\u65E5\u5FD7\u5904\u4E8E\u9ED1\u540D\u5355");
        return false;
      }
      if (config3?.channels?.log_enable_list?.length && !config3?.channels?.log_enable_list.includes(ctx3.channelId)) {
        runLog("\u5B50\u9891\u9053\u65E5\u5FD7\u672A\u5904\u4E8E\u767D\u540D\u5355");
        return false;
      }
      if (config3?.channels?.log_disable_list?.length && config3?.channels?.log_disable_list.includes(ctx3.channelId)) {
        runLog("\u5B50\u9891\u9053\u65E5\u5FD7\u5904\u4E8E\u9ED1\u540D\u5355");
        return false;
      }
      return true;
    };
  }
});

// src/event/handler/other/other.ts
var initTips, initPrint, deal, fnc;
var init_other = __esm({
  "src/event/handler/other/other.ts"() {
    init_cache();
    init_internal();
    init_eventCall();
    init_empty();
    init_handler2();
    initTips = (ctx3) => {
      switch (ctx3.subEvent) {
        case "friendPoke":
          ctx3.tips = `\u6233\u4E00\u6233: ${ctx3.content.operatorId} ${ctx3.content.action || "\u6233\u4E86\u6233"} ${ctx3.content.targetId}`;
          break;
        case "receiveLike":
          ctx3.tips = `\u6536\u5230\u70B9\u8D5E: ${ctx3.content.count}`;
          break;
        case "friendRecall":
          ctx3.tips = `\u64A4\u56DE\u6D88\u606F: ${ctx3.content.messageId}`;
          break;
        case "privateFileUploaded":
          ctx3.tips = `\u6587\u4EF6\u4E0A\u4F20: [fid:${ctx3.content.fid}] [fid:${ctx3.content.fid}] [name:${ctx3.content.name}]`;
          break;
        case "friendIncrease":
          ctx3.tips = `\u65B0\u589E\u597D\u53CB: ${ctx3.content.targetId}`;
          break;
        case "friendDecrease":
          ctx3.tips = `\u597D\u53CB\u51CF\u5C11: ${ctx3.content.targetId}`;
          break;
        case "groupPoke":
          ctx3.tips = `\u6233\u4E00\u6233: ${ctx3.content.operatorId} ${ctx3.content.action || "\u6233\u4E86\u6233"} ${ctx3.content.targetId}`;
          break;
        case "groupMessageReaction":
          ctx3.tips = `\u8868\u60C5\u52A8\u6001: \u7ED9\u6D88\u606F ${ctx3.content.messageId} ${ctx3.content.isSet ? "\u6DFB\u52A0" : "\u53D6\u6D88"}\u4E86\u8868\u60C5 ${ctx3.content.faceId}`;
          break;
        case "groupRecall":
          ctx3.tips = `\u64A4\u56DE\u6D88\u606F: ${ctx3.content.messageId}`;
          break;
        case "groupFileUploaded":
          ctx3.tips = `\u6587\u4EF6\u4E0A\u4F20: [fid:${ctx3.content.fid}] [fid:${ctx3.content.fid}] [name:${ctx3.content.name}]`;
          break;
        case "groupMemberAdd":
          ctx3.tips = `\u65B0\u589E\u6210\u5458: [\u64CD\u4F5C\u8005:${ctx3.content.operatorId}] [\u76EE\u6807\u6210\u5458:${ctx3.content.targetId}]`;
          break;
        case "groupMemberRemove":
          ctx3.tips = `\u79FB\u9664\u6210\u5458: [\u64CD\u4F5C\u8005:${ctx3.content.operatorId}] [\u76EE\u6807\u6210\u5458:${ctx3.content.targetId}]`;
          break;
        case "groupCardChanged":
          ctx3.tips = `\u540D\u7247\u53D8\u52A8: [\u64CD\u4F5C\u8005:${ctx3.content.operatorId}] [\u76EE\u6807\u6210\u5458:${ctx3.content.targetId}]`;
          break;
        case "groupAdminChanged":
          ctx3.tips = `\u7BA1\u7406\u5458\u53D8\u52A8: ${ctx3.content.targetId} \u88AB${ctx3.content.isAdmin ? "\u8BBE\u7F6E" : "\u53D6\u6D88"}\u7BA1\u7406\u5458`;
          break;
        case "groupSignIn":
          ctx3.tips = `\u7B7E\u5230: ${ctx3.content.targetId}`;
          break;
        case "groupMemberTitleUpdate":
          ctx3.tips = `\u5934\u8854\u53D8\u52A8: ${ctx3.content.title}`;
          break;
        case "groupHonorChange":
          ctx3.tips = `\u8363\u8A89\u53D8\u66F4: ${ctx3.userId} \u83B7\u5F97\u4E86 ${ctx3.content.honorType} \u8363\u8A89`;
          break;
        case "groupLuckyKing":
          ctx3.tips = `\u8FD0\u6C14\u738B: ${ctx3.content.userId} \u4ECE ${ctx3.content.userId} \u53D1\u7684\u7EA2\u5305\u4E2D\u83B7\u5F97\u4E86\u8FD0\u6C14\u738B`;
          break;
        case "groupHighlightsChange": {
          if (ctx3.content.isSet) {
            ctx3.tips = `\u8BBE\u7F6E\u7CBE\u534E: ${ctx3.content.operatorId} \u5C06 ${ctx3.content.messageId} \u8BBE\u7F6E\u4E3A\u7CBE\u534E\u6D88\u606F`;
          } else {
            ctx3.tips = `\u53D6\u6D88\u7CBE\u534E: ${ctx3.content.operatorId} \u5C06 ${ctx3.content.messageId} \u53D6\u6D88\u7CBE\u534E\u6D88\u606F`;
          }
          break;
        }
        case "groupMemberBan": {
          if (ctx3.content.isBan) {
            ctx3.tips = `\u7981\u8A00\u6210\u5458: ${ctx3.content.operatorId} \u5C06 ${ctx3.content.targetId} \u7981\u8A00 ${ctx3.content.duration}\u79D2`;
          } else {
            ctx3.tips = `\u89E3\u9664\u7981\u8A00: ${ctx3.content.operatorId} \u89E3\u9664\u4E86 ${ctx3.content.targetId} \u7684\u7981\u8A00`;
          }
          break;
        }
        case "groupWholeBan": {
          if (ctx3.content.isBan) {
            ctx3.tips = `\u5168\u5458\u7981\u8A00: ${ctx3.content.operatorId}`;
          } else {
            ctx3.tips = `\u89E3\u9664\u5168\u5458\u7981\u8A00: ${ctx3.content.operatorId}`;
          }
          break;
        }
      }
    };
    initPrint = (ctx3, type, prefix, level = "info") => {
      let idPath = "\u672A\u77E5";
      if (ctx3.isFriend) {
        idPath = ctx3.userId;
      } else if (ctx3.isGroup) {
        idPath = `${ctx3.groupId}-${ctx3.userId}`;
      }
      const nick = ctx3.sender.nick || "";
      ctx3.logText = `[${type}:${idPath}(${nick})]`;
      logger.bot(level, ctx3.selfId, `${prefix}: [${idPath}(${nick})] ${ctx3.tips}`);
    };
    deal = async (ctx3, config3) => {
      for (const plugin of cache3.accept) {
        if (plugin.event !== ctx3.event && plugin.event !== `${ctx3.event}.${ctx3.subEvent}`) {
          continue;
        }
        if (ctx3.event === "notice") {
          const result2 = await eventCallEmit.notice(ctx3, plugin);
          if (!result2) return;
        } else {
          const result2 = await eventCallEmit.request(ctx3, plugin);
          if (!result2) return;
        }
        const result = await fnc(ctx3, plugin, config3);
        if (!result) return;
      }
      log2(ctx3.userId, `\u672A\u627E\u5230\u5339\u914D\u5230\u76F8\u5E94\u63D2\u4EF6: ${ctx3.eventId}`);
      if (ctx3.event === "notice") {
        emptyEmit.notice(ctx3);
      } else {
        emptyEmit.request(ctx3);
      }
    };
    fnc = async (ctx3, plugin, config3) => {
      if (!disableViaAdapter(plugin, ctx3.bot.adapter.protocol)) return true;
      if (!disableViaPluginWhitelist(plugin, config3)) return true;
      if (!disableViaPluginBlacklist(plugin, config3)) return true;
      ctx3.logFnc = `[${plugin.pkg.name}][${plugin.file.name}]`;
      const logFnc = logger.fnc(ctx3.logFnc);
      plugin.log(ctx3.selfId, `${logFnc}${ctx3.logText}`);
      const start3 = Date.now();
      try {
        let next = false;
        const result = await plugin.fnc(ctx3, () => {
          next = true;
        });
        if (next === false && result === false) {
          next = true;
        }
        if (next === true) {
          logger.debug(`${ctx3.logFnc} \u7EE7\u7EED\u5339\u914D\u4E0B\u4E00\u4E2A\u63D2\u4EF6`);
          return true;
        }
        return false;
      } catch (cause) {
        listeners.emit("error", new Error(ctx3.logFnc, { cause }));
        return false;
      } finally {
        plugin.log(ctx3.selfId, `${logFnc} \u5904\u7406\u5B8C\u6210 ${logger.green(Date.now() - start3 + "ms")}`);
      }
    };
  }
});

// src/event/handler/notice/groups.ts
var groupNoticeHandler;
var init_groups = __esm({
  "src/event/handler/notice/groups.ts"() {
    init_cd();
    init_config();
    init_other();
    init_handler2();
    groupNoticeHandler = async (ctx3) => {
      const config3 = config2();
      const group = getGroupCfg(ctx3.groupId, ctx3.selfId);
      initRole(ctx3, config3);
      initEmit(ctx3);
      initTips(ctx3);
      initPrint(ctx3, "group", "\u7FA4\u901A\u77E5");
      const cd = noticeRequestCD(ctx3, group, ctx3.groupId);
      const filter = groupFilterEvent(ctx3, config3, group, cd);
      if (filter) deal(ctx3, group);
    };
  }
});

// src/event/handler/notice/private.ts
var friendNoticeHandler;
var init_private = __esm({
  "src/event/handler/notice/private.ts"() {
    init_other();
    init_cd();
    init_config();
    init_handler2();
    friendNoticeHandler = async (ctx3) => {
      const config3 = config2();
      const friend = getFriendCfg(ctx3.userId, ctx3.selfId);
      initRole(ctx3, config3);
      initEmit(ctx3);
      initTips(ctx3);
      initPrint(ctx3, "friend", "\u597D\u53CB\u901A\u77E5");
      const cd = noticeRequestCD(ctx3, friend, ctx3.userId);
      const filter = privateFilterEvent(ctx3, config3, friend, cd);
      if (filter) deal(ctx3, friend);
    };
  }
});

// src/event/handler/notice/index.ts
var init_notice = __esm({
  "src/event/handler/notice/index.ts"() {
    init_groups();
    init_private();
  }
});

// src/event/handler/request/groups.ts
var groupRequestHandler;
var init_groups2 = __esm({
  "src/event/handler/request/groups.ts"() {
    init_cd();
    init_config();
    init_other();
    init_handler2();
    groupRequestHandler = async (ctx3) => {
      const config3 = config2();
      const group = getGroupCfg(ctx3.groupId, ctx3.selfId);
      initRole(ctx3, config3);
      initEmit(ctx3);
      initTips(ctx3);
      initPrint(ctx3, "group", "\u7FA4\u8BF7\u6C42");
      const cd = noticeRequestCD(ctx3, group, ctx3.groupId);
      const filter = groupFilterEvent(ctx3, config3, group, cd);
      if (filter) deal(ctx3, group);
    };
  }
});

// src/event/handler/request/private.ts
var friendRequestHandler;
var init_private2 = __esm({
  "src/event/handler/request/private.ts"() {
    init_cd();
    init_other();
    init_config();
    init_handler2();
    friendRequestHandler = async (ctx3) => {
      const config3 = config2();
      const friend = getFriendCfg(ctx3.userId, ctx3.selfId);
      initRole(ctx3, config3);
      initEmit(ctx3);
      initTips(ctx3);
      initPrint(ctx3, "friend", "\u597D\u53CB\u8BF7\u6C42");
      const cd = noticeRequestCD(ctx3, friend, ctx3.userId);
      const filter = privateFilterEvent(ctx3, config3, friend, cd);
      if (filter) deal(ctx3, friend);
    };
  }
});

// src/event/handler/request/index.ts
var init_request = __esm({
  "src/event/handler/request/index.ts"() {
    init_groups2();
    init_private2();
  }
});

// src/event/handler/other/context.ts
var ctx, context;
var init_context = __esm({
  "src/event/handler/other/context.ts"() {
    init_internal();
    ctx = /* @__PURE__ */ new Map();
    context = (event) => {
      const key = event.contact.subPeer ? `${event.contact.peer}:${event.contact.subPeer}:${event.userId}` : `${event.contact.peer}:${event.userId}`;
      if (!ctx.has(key)) {
        return false;
      }
      listeners.emit(`ctx:${key}`, event);
      ctx.delete(key);
      return true;
    };
  }
});

// src/event/handler/other/permission.ts
var Permission;
var init_permission = __esm({
  "src/event/handler/other/permission.ts"() {
    Permission = class {
      static master = "\u6682\u65E0\u6743\u9650\uFF0C\u53EA\u6709\u4E3B\u4EBA\u624D\u80FD\u64CD\u4F5C";
      static admin = "\u6682\u65E0\u6743\u9650\uFF0C\u53EA\u6709\u7BA1\u7406\u5458\u624D\u80FD\u64CD\u4F5C";
      static owner = "\u6682\u65E0\u6743\u9650\uFF0C\u53EA\u6709\u7FA4\u4E3B\u624D\u80FD\u64CD\u4F5C";
      static groupAdmin = "\u6682\u65E0\u6743\u9650\uFF0C\u53EA\u6709\u7FA4\u7BA1\u7406\u5458\u624D\u80FD\u64CD\u4F5C";
      /**
       * 处理没有权限的情况
       * @param ctx 上下文
       * @param authFailMsg 没有权限时的回复消息
       * @param defaultMsg 默认回复消息
       */
      static handleNoPermission(ctx3, authFailMsg, defaultMsg) {
        if (authFailMsg === false) {
          ctx3.bot.logger("debug", `${defaultMsg}: ${ctx3.messageId}`);
          return false;
        }
        ctx3.reply(typeof authFailMsg === "string" ? authFailMsg : defaultMsg);
        return false;
      }
      /**
       * 私聊场景
       * @param ctx 上下文
       * @param plugin 插件缓存对象
       */
      static private(ctx3, plugin) {
        if (!plugin.permission || plugin.permission === "all") {
          return true;
        }
        if (plugin.permission === "master") {
          if (ctx3.isMaster) return true;
          return this.handleNoPermission(ctx3, plugin.authFailMsg, this.master);
        }
        if (plugin.permission === "admin") {
          if (ctx3.isMaster || ctx3.isAdmin) return true;
          return this.handleNoPermission(ctx3, plugin.authFailMsg, this.admin);
        }
        return true;
      }
      /**
       * 群聊场景
       * @param ctx 上下文
       * @param plugin 插件缓存对象
       */
      static groups(ctx3, plugin) {
        if (!plugin.permission || plugin.permission === "all") {
          return true;
        }
        if (plugin.permission === "master") {
          if (ctx3.isMaster) return true;
          return this.handleNoPermission(ctx3, plugin.authFailMsg, this.master);
        }
        if (plugin.permission === "admin") {
          if (ctx3.isMaster || ctx3.isAdmin) return true;
          return this.handleNoPermission(ctx3, plugin.authFailMsg, this.admin);
        }
        if (ctx3.isGroup) {
          if (plugin.permission === "group.owner") {
            if (ctx3.isMaster || ctx3.isAdmin || ctx3.sender?.role === "owner") return true;
            return this.handleNoPermission(ctx3, plugin.authFailMsg, this.owner);
          }
          if (plugin.permission === "group.admin") {
            if (ctx3.isMaster || ctx3.isAdmin || ctx3.sender?.role === "owner" || ctx3.sender?.role === "admin") return true;
            return this.handleNoPermission(ctx3, plugin.authFailMsg, this.groupAdmin);
          }
        } else if (ctx3.isGuild) {
          if (plugin.permission === "guild.owner") {
            if (ctx3.isMaster || ctx3.isAdmin || ctx3.sender?.role === "owner") return true;
            return this.handleNoPermission(ctx3, plugin.authFailMsg, this.owner);
          }
          if (plugin.permission === "guild.admin") {
            if (ctx3.isMaster || ctx3.isAdmin || ctx3.sender?.role === "owner" || ctx3.sender?.role === "admin") return true;
            return this.handleNoPermission(ctx3, plugin.authFailMsg, this.groupAdmin);
          }
        }
        return true;
      }
    };
  }
});
var addHook2, message, emitHooks2, hooksMessageEmit;
var init_messaeg = __esm({
  "src/hooks/messaeg.ts"() {
    init_cache3();
    addHook2 = (list2, callback, options = {}) => {
      const id = createHookId();
      list2.push({
        id,
        priority: options.priority ?? 1e4,
        callback
      });
      return { id, list: lodash3.orderBy(list2, ["priority"], ["asc"]) };
    };
    message = Object.assign(
      /**
       * 添加消息钩子
       * @param callback 消息处理回调函数
       * @param options 钩子配置项
       * @returns 钩子ID
       */
      (callback, options = {}) => {
        const { id, list: list2 } = addHook2(cache4.message.message, callback, options);
        logger.mark(`[hooks] \u6DFB\u52A0\u5168\u90E8\u6D88\u606F\u94A9\u5B50: ${id}`);
        cache4.message.message = list2;
        return id;
      },
      {
        /**
         * 添加好友消息钩子
         * @param callback 消息处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        friend(callback, options = {}) {
          const { id, list: list2 } = addHook2(cache4.message.friend, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u597D\u53CB\u6D88\u606F\u94A9\u5B50: ${id}`);
          cache4.message.friend = list2;
          return id;
        },
        /**
         * 添加群消息钩子
         * @param callback 消息处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        group(callback, options = {}) {
          const { id, list: list2 } = addHook2(cache4.message.group, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u7FA4\u6D88\u606F\u94A9\u5B50: ${id}`);
          cache4.message.group = list2;
          return id;
        },
        /**
         * 添加频道消息钩子
         * @param callback 消息处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        guild(callback, options = {}) {
          const { id, list: list2 } = addHook2(cache4.message.guild, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u9891\u9053\u6D88\u606F\u94A9\u5B50: ${id}`);
          cache4.message.guild = list2;
          return id;
        },
        /**
         * 添加临时消息钩子
         * @param callback 消息处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        direct(callback, options = {}) {
          const { id, list: list2 } = addHook2(cache4.message.direct, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u4E34\u65F6\u6D88\u606F\u94A9\u5B50: ${id}`);
          cache4.message.direct = list2;
          return id;
        },
        /**
         * 添加临时消息钩子
         * @param callback 消息处理回调函数
         * @param options 钩子配置项
         * @returns 钩子ID
         */
        groupTemp(callback, options = {}) {
          const { id, list: list2 } = addHook2(cache4.message.groupTemp, callback, options);
          logger.mark(`[hooks] \u6DFB\u52A0\u7FA4\u4E34\u65F6\u6D88\u606F\u94A9\u5B50: ${id}`);
          cache4.message.groupTemp = list2;
          return id;
        },
        /**
         * 删除钩子
         * @param id 钩子ID
         */
        remove(id) {
          logger.mark(`[hooks] \u79FB\u9664\u94A9\u5B50: ${id}`);
          cache4.message.message = cache4.message.message.filter((item) => item.id !== id);
          cache4.message.friend = cache4.message.friend.filter((item) => item.id !== id);
          cache4.message.group = cache4.message.group.filter((item) => item.id !== id);
          cache4.message.guild = cache4.message.guild.filter((item) => item.id !== id);
          cache4.message.direct = cache4.message.direct.filter((item) => item.id !== id);
          cache4.message.groupTemp = cache4.message.groupTemp.filter((item) => item.id !== id);
        }
      }
    );
    emitHooks2 = async (event, hooks2) => {
      let isNext = false;
      for (const hook of hooks2) {
        const result = hook.callback(event, () => {
          isNext = true;
        });
        if (isPromise(result)) await result;
        if (!isNext) return false;
        isNext = false;
      }
      return true;
    };
    hooksMessageEmit = {
      /**
       * 触发消息钩子
       * @param event 消息事件
       * @returns 是否继续正常流程
       */
      message: (event) => emitHooks2(event, cache4.message.message),
      /**
       * 触发好友消息钩子
       * @param event 好友消息事件
       * @returns 是否继续正常流程
       */
      friend: (event) => emitHooks2(event, cache4.message.friend),
      /**
       * 触发群消息钩子
       * @param event 群消息事件
       * @returns 是否继续正常流程
       */
      group: (event) => emitHooks2(event, cache4.message.group),
      /**
       * 触发频道消息钩子
       * @param event 频道消息事件
       * @returns 是否继续正常流程
       */
      guild: (event) => emitHooks2(event, cache4.message.guild),
      /**
       * 触发私聊消息钩子
       * @param event 私聊消息事件
       * @returns 是否继续正常流程
       */
      direct: (event) => emitHooks2(event, cache4.message.direct),
      /**
       * 触发群临时消息钩子
       * @param event 群临时消息事件
       * @returns 是否继续正常流程
       */
      groupTemp: (event) => emitHooks2(event, cache4.message.groupTemp)
    };
  }
});
var groupHandler, groupTempHandler, guildHandler, initPrint2, groupsDeal, groupsCmd;
var init_groups3 = __esm({
  "src/event/handler/message/groups.ts"() {
    init_cd();
    init_cache();
    init_context();
    init_internal();
    init_permission();
    init_messaeg();
    init_empty();
    init_eventCall();
    init_config();
    init_handler2();
    groupHandler = async (ctx3) => {
      const config3 = config2();
      const group = getGroupCfg(ctx3.groupId, ctx3.selfId);
      const isPrint = groupPrint(ctx3, config3);
      initMsg(ctx3);
      initRole(ctx3, config3);
      initAlias(ctx3, group.alias);
      initEmit(ctx3);
      initPrint2(ctx3, isPrint ? "info" : "debug");
      const hook = await hooksMessageEmit.group(ctx3);
      if (!hook) {
        logger.debug(`[${ctx3.logFnc}] \u7FA4\u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const hook2 = await hooksMessageEmit.message(ctx3);
      if (!hook2) {
        logger.debug(`[${ctx3.logFnc}] \u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const context2 = context(ctx3);
      if (context2) return ctx3;
      const cd = groupsCD(group, ctx3.groupId, ctx3.userId);
      const filter = groupFilterEvent(ctx3, config3, group, cd);
      if (filter) {
        groupsDeal(ctx3, group, isPrint, (plugin) => {
          if (plugin.event !== "message" && plugin.event !== "message.group") return false;
          if (![
            "all",
            "master",
            "admin",
            "group.owner",
            "group.admin"
          ].includes(plugin.permission)) return false;
          return true;
        });
      }
    };
    groupTempHandler = async (ctx3) => {
      const config3 = config2();
      const group = getGroupCfg(ctx3.groupId, ctx3.selfId);
      const isPrint = groupPrint(ctx3, config3);
      initMsg(ctx3);
      initRole(ctx3, config3);
      initAlias(ctx3, group.alias);
      initEmit(ctx3);
      initPrint2(ctx3);
      const hook = await hooksMessageEmit.groupTemp(ctx3);
      if (!hook) {
        logger.debug(`[${ctx3.logFnc}] \u7FA4\u4E34\u65F6\u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const hook2 = await hooksMessageEmit.message(ctx3);
      if (!hook2) {
        logger.debug(`[${ctx3.logFnc}] \u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const context2 = context(ctx3);
      if (context2) return ctx3;
      const cd = groupsCD(group, ctx3.groupId, ctx3.userId);
      const filter = groupFilterEvent(ctx3, config3, group, cd);
      if (filter) {
        groupsDeal(ctx3, group, isPrint, (plugin) => {
          if (plugin.event !== "message" && plugin.event !== "message.groupTemp") return false;
          if (!["all", "master", "admin"].includes(plugin.permission)) return false;
          return true;
        });
      }
    };
    guildHandler = async (ctx3) => {
      const config3 = config2();
      const group = getGuildCfg(ctx3.guildId, ctx3.channelId, ctx3.selfId);
      const isPrint = guildPrint(ctx3, config3);
      initMsg(ctx3);
      initRole(ctx3, config3);
      initAlias(ctx3, group.alias);
      initEmit(ctx3);
      initPrint2(ctx3);
      const context2 = context(ctx3);
      if (context2) return ctx3;
      hooksMessageEmit.guild(ctx3);
      hooksMessageEmit.message(ctx3);
      const cd = groupsCD(group, `${ctx3.guildId}:${ctx3.channelId}`, ctx3.userId);
      const filter = groupFilterEvent(ctx3, config3, group, cd);
      if (filter) {
        groupsDeal(ctx3, group, isPrint, (plugin) => {
          if (plugin.event !== "message" && plugin.event !== "message.guild") return false;
          if (![
            "all",
            "master",
            "admin",
            "guild.owner",
            "guild.admin"
          ].includes(plugin.permission)) return false;
          return true;
        });
      }
    };
    initPrint2 = (ctx3, level = "info") => {
      let idPath;
      let msgType;
      if (ctx3.isFriend) {
        msgType = "\u597D\u53CB\u6D88\u606F";
        idPath = ctx3.userId;
      } else if (ctx3.isGroup) {
        msgType = "\u7FA4\u6D88\u606F";
        idPath = `${ctx3.groupId}-${ctx3.userId}`;
      } else if (ctx3.isGuild) {
        msgType = "\u9891\u9053\u6D88\u606F";
        idPath = `${ctx3.guildId}-${ctx3.channelId}-${ctx3.userId}`;
      } else if (ctx3.isGroupTemp) {
        msgType = "\u7FA4\u4E34\u65F6\u6D88\u606F";
        idPath = `${ctx3.groupId}-${ctx3.userId}`;
      } else {
        msgType = "\u79C1\u4FE1\u6D88\u606F";
        idPath = ctx3.userId;
      }
      const nick = ctx3.sender.nick || "";
      ctx3.logText = `[${ctx3.contact.scene}:${idPath}(${nick})]`;
      logger.bot(level, ctx3.selfId, `${msgType}: [${idPath}(${nick})] ${ctx3.rawMessage}`);
    };
    groupsDeal = async (ctx3, config3, isPrint, filter) => {
      for (const plugin of cache3.command) {
        if (!filter(plugin)) continue;
        const result = await groupsCmd(ctx3, plugin, config3, isPrint);
        if (!result) return;
      }
      log2(ctx3.userId, `\u672A\u627E\u5230\u5339\u914D\u5230\u76F8\u5E94\u63D2\u4EF6: ${ctx3.messageId}`);
      emptyEmit.message(ctx3);
    };
    groupsCmd = async (ctx3, plugin, config3, isPrint) => {
      const reg = plugin.reg;
      if (reg && !reg.test(ctx3.msg)) return true;
      if (!disableViaAdapter(plugin, ctx3.bot.adapter.protocol)) return true;
      if (!disableViaPluginWhitelist(plugin, config3)) return true;
      if (!disableViaPluginBlacklist(plugin, config3)) return true;
      ctx3.logFnc = `[${plugin.pkg.name}][${plugin.file.name}]`;
      const logFnc = logger.fnc(ctx3.logFnc);
      isPrint && plugin.log(ctx3.selfId, `${logFnc}${ctx3.logText} ${lodash3.truncate(ctx3.msg, { length: 100 })}`);
      const start3 = Date.now();
      if (ctx3.isGroup) {
        const result = await eventCallEmit.group(ctx3, plugin);
        if (!result) return false;
      } else if (ctx3.isGuild) {
        const result = await eventCallEmit.guild(ctx3, plugin);
        if (!result) return false;
      } else if (ctx3.isGroupTemp) {
        const result = await eventCallEmit.groupTemp(ctx3, plugin);
        if (!result) return false;
      }
      const hookResult = await eventCallEmit.message(ctx3, plugin);
      if (!hookResult) return false;
      try {
        if (!Permission.groups(ctx3, plugin)) return false;
        let next = false;
        if (plugin.type === "fnc") {
          const result = await plugin.fnc(ctx3, () => {
            next = true;
          });
          if (next === false && result === false) next = true;
        } else {
          const App = new plugin.Cls();
          if (typeof App?.[plugin.file.method] !== "function") {
            return true;
          }
          App.e = ctx3;
          App.next = () => {
            next = true;
          };
          App.reply = App.e.reply.bind(App.e);
          const result = await App[plugin.file.method](App.e);
          if (next === false && result === false) next = true;
        }
        if (next === true) {
          logger.debug(`${ctx3.logFnc} \u7EE7\u7EED\u5339\u914D\u4E0B\u4E00\u4E2A\u63D2\u4EF6`);
          return true;
        }
        return false;
      } catch (cause) {
        listeners.emit("error", new Error(ctx3.logFnc, { cause }));
        return false;
      } finally {
        const time2 = logger.green(Date.now() - start3 + "ms");
        const msg = lodash3.truncate(ctx3.msg, { length: 100 });
        isPrint && plugin.log(ctx3.selfId, `${logFnc} ${msg} \u5904\u7406\u5B8C\u6210 ${time2}`);
      }
    };
  }
});
var hasMethod, friendHandler, directHandler, initPrint3, privateDeal, privateCmd;
var init_private3 = __esm({
  "src/event/handler/message/private.ts"() {
    init_cd();
    init_cache();
    init_internal();
    init_context();
    init_config();
    init_permission();
    init_messaeg();
    init_eventCall();
    init_empty();
    init_handler2();
    hasMethod = (obj, methodName) => {
      return typeof obj[methodName] === "function";
    };
    friendHandler = async (ctx3) => {
      const config3 = config2();
      const friend = getFriendCfg(ctx3.userId, ctx3.selfId);
      initMsg(ctx3);
      initRole(ctx3, config3);
      initAlias(ctx3, friend.alias);
      initEmit(ctx3);
      initPrint3(ctx3, "friend", "\u597D\u53CB\u6D88\u606F");
      const hook = await hooksMessageEmit.friend(ctx3);
      if (!hook) {
        logger.debug(`[${ctx3.logFnc}] \u597D\u53CB\u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const hook2 = await hooksMessageEmit.message(ctx3);
      if (!hook2) {
        logger.debug(`[${ctx3.logFnc}] \u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const context2 = context(ctx3);
      if (context2) return ctx3;
      const filter = privateFilterEvent(ctx3, config3, friend, privateCD(friend, ctx3.userId));
      if (filter) {
        privateDeal(ctx3, friend, (plugin) => {
          if (plugin.event !== "message" && plugin.event !== "message.friend") return false;
          if (!["all", "master", "admin"].includes(plugin.permission)) return false;
          return true;
        });
      }
    };
    directHandler = async (ctx3) => {
      const config3 = config2();
      const friend = getFriendCfg(ctx3.userId, ctx3.selfId);
      initMsg(ctx3);
      initRole(ctx3, config3);
      initAlias(ctx3, friend.alias);
      initEmit(ctx3);
      initPrint3(ctx3, "direct", "\u9891\u9053\u79C1\u4FE1");
      const hook = await hooksMessageEmit.direct(ctx3);
      if (!hook) {
        logger.debug(`[${ctx3.logFnc}] \u9891\u9053\u79C1\u4FE1\u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const hook2 = await hooksMessageEmit.message(ctx3);
      if (!hook2) {
        logger.debug(`[${ctx3.logFnc}] \u6D88\u606F\u94A9\u5B50\u8FD4\u56DEfalse \u8DF3\u8FC7\u5F53\u524D\u4E8B\u4EF6: ${ctx3.eventId}`);
        return;
      }
      const context2 = context(ctx3);
      if (context2) return ctx3;
      const cd = privateCD(friend, ctx3.userId);
      const filter = privateFilterEvent(ctx3, config3, friend, cd);
      if (filter) {
        privateDeal(ctx3, friend, (plugin) => {
          if (plugin.event !== "message" && plugin.event !== "message.direct") return false;
          if (!["all", "master", "admin"].includes(plugin.permission)) return false;
          return true;
        });
      }
    };
    initPrint3 = (ctx3, type, prefix, level = "info") => {
      ctx3.logText = `[${type}:${ctx3.userId}(${ctx3.sender.nick || ""})]`;
      logger.bot(level, ctx3.selfId, `${prefix}: [${ctx3.userId}(${ctx3.sender.nick || ""})] ${ctx3.rawMessage}`);
    };
    privateDeal = async (ctx3, config3, filter) => {
      for (const plugin of cache3.command) {
        if (!filter(plugin)) continue;
        const result = await privateCmd(ctx3, plugin, config3);
        if (!result) return;
      }
      log2(ctx3.userId, `\u672A\u627E\u5230\u5339\u914D\u5230\u76F8\u5E94\u63D2\u4EF6: ${ctx3.messageId}`);
      emptyEmit.message(ctx3);
    };
    privateCmd = async (ctx3, plugin, config3) => {
      const reg = plugin.reg;
      if (reg && !reg.test(ctx3.msg)) return true;
      if (!disableViaAdapter(plugin, ctx3.bot.adapter.protocol)) return true;
      if (!disableViaPluginWhitelist(plugin, config3)) return true;
      if (!disableViaPluginBlacklist(plugin, config3)) return true;
      ctx3.logFnc = `[${plugin.pkg.name}][${plugin.file.name}]`;
      const logFnc = logger.fnc(ctx3.logFnc);
      plugin.log(ctx3.selfId, `${logFnc}${ctx3.logText} ${lodash3.truncate(ctx3.msg, { length: 100 })}`);
      const start3 = Date.now();
      if (ctx3.isFriend) {
        const result = await eventCallEmit.friend(ctx3, plugin);
        if (!result) return false;
      } else if (ctx3.isDirect) {
        const result = await eventCallEmit.direct(ctx3, plugin);
        if (!result) return false;
      }
      const hookResult = await eventCallEmit.message(ctx3, plugin);
      if (!hookResult) return false;
      try {
        if (!Permission.private(ctx3, plugin)) return false;
        let next = false;
        if (plugin.type === "fnc") {
          const result = await plugin.fnc(ctx3, () => {
            next = true;
          });
          if (next === false && result === false) next = true;
        } else {
          const App = new plugin.Cls();
          if (!hasMethod(App, plugin.file.method)) {
            logger.debug(`[${plugin.pkg.name}][${plugin.file.method}] \u65B9\u6CD5\u4E0D\u5B58\u5728`);
            return true;
          }
          App.e = ctx3;
          App.next = () => {
            next = true;
          };
          App.reply = App.e.reply.bind(App.e);
          const result = await App[plugin.file.method](App.e);
          if (next === false && result === false) next = true;
        }
        if (next === true) {
          logger.debug(`${ctx3.logFnc} \u7EE7\u7EED\u5339\u914D\u4E0B\u4E00\u4E2A\u63D2\u4EF6`);
          return true;
        }
        return false;
      } catch (cause) {
        listeners.emit("error", new Error(ctx3.logFnc, { cause }));
        return false;
      } finally {
        const time2 = logger.green(Date.now() - start3 + "ms");
        const msg = lodash3.truncate(ctx3.msg, { length: 100 });
        plugin.log(ctx3.selfId, `${logFnc} ${msg} \u5904\u7406\u5B8C\u6210 ${time2}`);
      }
    };
  }
});

// src/event/handler/message/index.ts
var init_message3 = __esm({
  "src/event/handler/message/index.ts"() {
    init_groups3();
    init_private3();
  }
});
var BaseEvent;
var init_base2 = __esm({
  "src/event/base.ts"() {
    init_lock();
    init_message2();
    BaseEvent = class {
      #selfId;
      #event;
      #subEvent;
      #eventId;
      #rawEvent;
      #time;
      #contact;
      #sender;
      #srcReply;
      #bot;
      /** 快速回复 */
      reply;
      /** 存储器 由开发者自行调用 */
      store;
      /** 日志函数字符串 */
      logFnc;
      /** 日志用户字符串 */
      logText;
      /** 是否为主人 */
      isMaster;
      /** 是否为Bot管理员 */
      isAdmin;
      constructor({
        event,
        subEvent,
        eventId,
        rawEvent,
        time: time2,
        contact: contact3,
        sender: sender2,
        srcReply,
        bot
      }) {
        this.#selfId = bot.selfId;
        this.#event = event;
        this.#subEvent = subEvent;
        this.#eventId = eventId;
        this.#rawEvent = rawEvent;
        this.#time = time2;
        this.#contact = contact3;
        this.#sender = sender2;
        this.#srcReply = srcReply;
        this.#bot = bot;
        this.store = /* @__PURE__ */ new Map();
        this.logFnc = "";
        this.logText = "";
        this.isMaster = false;
        this.isAdmin = false;
        this.reply = async (elements, options) => {
          try {
            const message2 = makeMessage(elements);
            const at2 = options?.at ?? false;
            const reply2 = options?.reply ?? false;
            const recallMsg = options?.recallMsg ?? 0;
            if (at2 && !this.isPrivate) {
              message2.unshift(segment_exports.at(this.userId));
            }
            if (reply2 && "message_id" in this) {
              message2.unshift(segment_exports.reply(this.message_id));
            }
            let result = {
              messageId: "",
              time: 0,
              messageTime: 0,
              rawData: {},
              /** @deprecated 已废弃，请使用 messageId */
              message_id: ""
            };
            const request3 = this.#srcReply(message2);
            const { raw: raw2 } = createRawMessage(message2);
            if (this.isGroup) {
              this.selfId !== "console" && logger.bot("info", this.selfId, `${logger.green(`Send Group ${this.contact.peer}: `)}${raw2.replace(/\n/g, "\\n")}`);
            } else {
              this.selfId !== "console" && logger.bot("info", this.selfId, `${logger.green(`Send private ${this.contact.peer}: `)}${raw2.replace(/\n/g, "\\n")}`);
            }
            result = util5.types.isPromise(request3) ? await request3 : request3;
            result.message_id = result.messageId;
            if (recallMsg > 0 && result.messageId) {
              setTimeout(() => {
                this.bot.recallMsg(this.contact, result.messageId);
              }, recallMsg * 1e3);
            }
            return result;
          } catch (error) {
            const retryCount = options?.retryCount ?? 0;
            if (retryCount > 0) {
              return this.reply(elements, { ...options, retryCount: retryCount - 1 });
            }
            throw error;
          }
        };
        lockProp(this, "reply");
      }
      /**
       * @description 机器人ID
       * @deprecated 即将废弃，请使用 `selfId`
       */
      get self_id() {
        return this.#selfId;
      }
      /**
       * @description 用户ID
       * @deprecated 即将废弃，请使用 `userId`
       */
      get user_id() {
        return this.userId;
      }
      /** 机器人自身ID */
      get selfId() {
        return this.#selfId;
      }
      /** 用户ID */
      get userId() {
        return this.#sender.userId;
      }
      /** 事件父类型 */
      get event() {
        return this.#event;
      }
      /** 事件子类型 */
      get subEvent() {
        return this.#subEvent;
      }
      /** 事件ID */
      get eventId() {
        return this.#eventId;
      }
      /** 原始事件 */
      get rawEvent() {
        return this.#rawEvent;
      }
      /** 事件触发时间戳 */
      get time() {
        return this.#time;
      }
      /** 事件来源信息 */
      get contact() {
        return this.#contact;
      }
      /** 事件发送者信息 */
      get sender() {
        return this.#sender;
      }
      /** 快速回复源函数 */
      get srcReply() {
        return this.#srcReply;
      }
      /** 机器人实例 */
      get bot() {
        return this.#bot;
      }
      /**
       * 是否为私聊场景
       * - 在好友场景下为 `true`
       * - 在频道私信场景下为 `true`
       */
      get isPrivate() {
        return this.#contact.scene === "friend";
      }
      /** 是否为好友场景 */
      get isFriend() {
        return this.isPrivate;
      }
      /** 是否为群聊场景 */
      get isGroup() {
        return this.#contact.scene === "group";
      }
      /** 是否为频道场景 */
      get isGuild() {
        return this.#contact.scene === "guild";
      }
      /** 是否为群临时会话场景 */
      get isGroupTemp() {
        return this.#contact.scene === "groupTemp";
      }
      /** 是否为频道私信场景 */
      get isDirect() {
        return this.#contact.scene === "direct";
      }
      /**
       * 传入目标权限，返回当前事件触发者是否拥有该权限
       * @param role - 目标权限
       * @param isUpper - 是否向上检查 例如`group:admin`向上检查到`master` 默认`true`
       * @returns 是否拥有该权限
       */
      hasPermission(role, isUpper = true) {
        if (role === "all") return true;
        const levels = {
          master: 100,
          admin: 80,
          "group.owner": 60,
          "guild.owner": 60,
          "group.admin": 40,
          "guild.admin": 40,
          member: 20,
          all: 0
        };
        const userLevel = () => {
          if (this.isMaster) return levels.master;
          if (this.isAdmin) return levels.admin;
          if (this.isGroup || this.isGuild) {
            const senderRole = this.sender.role || "member";
            if (senderRole === "owner") {
              return this.isGroup ? levels["group.owner"] : levels["guild.owner"];
            }
            if (senderRole === "admin") {
              return this.isGroup ? levels["group.admin"] : levels["guild.admin"];
            }
          }
          return levels.member;
        };
        const requiredLevel = levels[role] || Number.MAX_SAFE_INTEGER;
        return isUpper ? userLevel() >= requiredLevel : userLevel() === requiredLevel;
      }
    };
  }
});

// src/event/message.ts
var MessageBase, FriendMessage, GroupMessage, DirectMessage, GuildMessage, GroupTempMessage;
var init_message4 = __esm({
  "src/event/message.ts"() {
    init_base2();
    MessageBase = class extends BaseEvent {
      #event;
      #subEvent;
      #messageId;
      #messageSeq;
      /** 消息段 */
      elements;
      /** 消息文本 */
      msg;
      /** 别名 */
      alias;
      /** 消息日志 */
      rawMessage;
      constructor({
        subEvent,
        eventId,
        rawEvent,
        time: time2,
        contact: contact3,
        sender: sender2,
        srcReply,
        bot,
        messageId,
        messageSeq,
        elements
      }) {
        super({
          subEvent,
          eventId,
          rawEvent,
          time: time2,
          contact: contact3,
          sender: sender2,
          srcReply,
          bot,
          event: "message"
        });
        this.#event = "message";
        this.#subEvent = subEvent;
        this.#messageId = messageId;
        this.#messageSeq = messageSeq;
        this.elements = elements;
        this.msg = "";
        this.alias = "";
        this.rawMessage = "";
      }
      /**
       * @deprecated 即将废弃 请使用 `rawMessage`
       */
      get raw_message() {
        return this.rawMessage;
      }
      /**
       * @description 消息ID
       * @deprecated 即将废弃 请使用 `messageId`
       */
      get message_id() {
        return this.messageId;
      }
      /**
       * @description 消息序列号
       * @deprecated 即将废弃 请使用 `messageSeq`
       */
      get message_seq() {
        return this.messageSeq;
      }
      get event() {
        return this.#event;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get messageId() {
        return this.#messageId;
      }
      get messageSeq() {
        return this.#messageSeq;
      }
      get at() {
        return this.elements.filter((element) => element.type === "at").map((element) => element.targetId).filter(Boolean);
      }
      get atBot() {
        return this.at.includes(this.selfId);
      }
      get atAll() {
        return this.at.includes("all");
      }
      get image() {
        return this.elements.filter((element) => element.type === "image").map((element) => element.file).filter(Boolean);
      }
      get record() {
        const record2 = this.elements.find((element) => element.type === "record");
        return record2 ? record2.file : "";
      }
      get replyId() {
        const reply2 = this.elements.find((element) => element.type === "reply");
        return reply2 ? reply2.messageId : "";
      }
      /**
       * @description 引用回复的消息id
       * @deprecated 即将废弃 请使用 `replyId`
       */
      get reply_id() {
        return this.replyId;
      }
    };
    FriendMessage = class extends MessageBase {
      #subEvent;
      #contact;
      #sender;
      constructor(options) {
        super(Object.assign(options, { subEvent: "friend" }));
        this.#subEvent = "friend";
        this.#contact = options.contact;
        this.#sender = options.sender;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupMessage = class extends MessageBase {
      #subEvent;
      #contact;
      #sender;
      constructor(options) {
        super(Object.assign(options, { subEvent: "group" }));
        this.#subEvent = "group";
        this.#contact = options.contact;
        this.#sender = options.sender;
      }
      /**
       * @description 群ID
       * @deprecated 即将废弃 请使用 `groupId`
       */
      get group_id() {
        return this.groupId;
      }
      /**
       * @description 群ID
       */
      get groupId() {
        return this.contact.peer;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    DirectMessage = class extends MessageBase {
      #subEvent;
      #contact;
      #sender;
      #srcGuildId;
      constructor(options) {
        super(Object.assign(options, { subEvent: "direct" }));
        this.#subEvent = "direct";
        this.#sender = options.sender;
        this.#contact = options.contact;
        this.#srcGuildId = options.srcGuildId;
      }
      /** 来源频道id */
      get srcGuildId() {
        return this.#srcGuildId;
      }
      get guildId() {
        return this.#contact.peer;
      }
      get channelId() {
        return this.#contact.subPeer;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return true;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GuildMessage = class extends MessageBase {
      #subEvent;
      #contact;
      #sender;
      constructor(options) {
        super(Object.assign(options, { subEvent: "guild" }));
        this.#subEvent = "guild";
        this.#contact = options.contact;
        this.#sender = options.sender;
      }
      /**
       * @description 频道ID
       * @deprecated 即将废弃 请使用 `guildId`
       */
      get guild_id() {
        return this.guildId;
      }
      /**
       * @description 子频道ID
       * @deprecated 即将废弃 请使用 `channelId`
       */
      get channel_id() {
        return this.channelId;
      }
      /**
       * @description 频道ID
       */
      get guildId() {
        return this.#contact.peer;
      }
      /**
       * @description 子频道ID
       */
      get channelId() {
        return this.#contact.subPeer;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return true;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupTempMessage = class extends MessageBase {
      #subEvent;
      #contact;
      #sender;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupTemp" }));
        this.#subEvent = "groupTemp";
        this.#contact = options.contact;
        this.#sender = options.sender;
      }
      /**
       * @description 群ID
       * @deprecated 即将废弃 请使用 `groupId`
       */
      get group_id() {
        return this.groupId;
      }
      /**
       * @description 群ID
       */
      get groupId() {
        return this.contact.peer;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return true;
      }
    };
  }
});

// src/event/notice.ts
var NoticeBase, ReceiveLikeNotice, FriendIncreaseNotice, FriendDecreaseNotice, PrivatePokeNotice, PrivateRecallNotice, PrivateFileUploadedNotice, GroupNotice, GroupPokeNotice, GroupRecallNotice, GroupFileUploadedNotice, GroupCardChangedNotice, GroupMemberTitleUpdatedNotice, GroupHlightsChangedNotice, GroupMemberIncreaseNotice, GroupMemberDecreaseNotice, GroupAdminChangedNotice, GroupSignInNotice, GroupMemberBanNotice, GroupWholeBanNotice, GroupMessageReactionNotice, GroupLuckKingNotice, GroupHonorChangedNotice;
var init_notice2 = __esm({
  "src/event/notice.ts"() {
    init_base2();
    NoticeBase = class extends BaseEvent {
      #event;
      #subEvent;
      /** 通知内容str */
      tips;
      /** 事件内容 */
      content;
      constructor({
        subEvent,
        eventId,
        rawEvent,
        time: time2,
        contact: contact3,
        sender: sender2,
        srcReply,
        bot
      }) {
        super({
          subEvent,
          eventId,
          rawEvent,
          time: time2,
          contact: contact3,
          sender: sender2,
          srcReply,
          bot,
          event: "notice"
        });
        this.#event = "notice";
        this.#subEvent = subEvent;
        this.tips = "";
      }
      get event() {
        return this.#event;
      }
      get subEvent() {
        return this.#subEvent;
      }
    };
    ReceiveLikeNotice = class extends NoticeBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "receiveLike" }));
        this.#subEvent = "receiveLike";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    FriendIncreaseNotice = class extends NoticeBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "friendIncrease" }));
        this.#subEvent = "friendIncrease";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    FriendDecreaseNotice = class extends NoticeBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "friendDecrease" }));
        this.#subEvent = "friendDecrease";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    PrivatePokeNotice = class extends NoticeBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "friendPoke" }));
        this.#subEvent = "friendPoke";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    PrivateRecallNotice = class extends NoticeBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "friendRecall" }));
        this.#subEvent = "friendRecall";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    PrivateFileUploadedNotice = class extends NoticeBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "privateFileUploaded" }));
        this.#subEvent = "privateFileUploaded";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupNotice = class extends NoticeBase {
      /**
       * @deprecated 已经弃用 请使用`groupId`
       */
      get group_id() {
        return this.contact.peer;
      }
      get groupId() {
        return this.contact.peer;
      }
    };
    GroupPokeNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupPoke" }));
        this.#subEvent = "groupPoke";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupRecallNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupRecall" }));
        this.#subEvent = "groupRecall";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupFileUploadedNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupFileUploaded" }));
        this.#subEvent = "groupFileUploaded";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupCardChangedNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupCardChanged" }));
        this.#subEvent = "groupCardChanged";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupMemberTitleUpdatedNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupMemberTitleUpdate" }));
        this.#subEvent = "groupMemberTitleUpdate";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupHlightsChangedNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupHighlightsChange" }));
        this.#subEvent = "groupHighlightsChange";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupMemberIncreaseNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupMemberAdd" }));
        this.#subEvent = "groupMemberAdd";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupMemberDecreaseNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupMemberRemove" }));
        this.#subEvent = "groupMemberRemove";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupAdminChangedNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupAdminChanged" }));
        this.#subEvent = "groupAdminChanged";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupSignInNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupSignIn" }));
        this.#subEvent = "groupSignIn";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupMemberBanNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupMemberBan" }));
        this.#subEvent = "groupMemberBan";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupWholeBanNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupWholeBan" }));
        this.#subEvent = "groupWholeBan";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupMessageReactionNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupMessageReaction" }));
        this.#subEvent = "groupMessageReaction";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupLuckKingNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupLuckyKing" }));
        this.#subEvent = "groupLuckyKing";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupHonorChangedNotice = class extends GroupNotice {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupHonorChange" }));
        this.#subEvent = "groupHonorChange";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
  }
});

// src/event/request.ts
var RequestBase, PrivateApplyRequest, GroupApplyRequest, GroupInviteRequest;
var init_request2 = __esm({
  "src/event/request.ts"() {
    init_base2();
    RequestBase = class extends BaseEvent {
      #event;
      #subEvent;
      /** 通知内容str */
      tips;
      /** 事件内容 */
      content;
      constructor({
        subEvent,
        eventId,
        rawEvent,
        time: time2,
        contact: contact3,
        sender: sender2,
        srcReply,
        bot
      }) {
        super({
          subEvent,
          eventId,
          rawEvent,
          time: time2,
          contact: contact3,
          sender: sender2,
          srcReply,
          bot,
          event: "request"
        });
        this.#event = "request";
        this.#subEvent = subEvent;
        this.tips = "";
      }
      get event() {
        return this.#event;
      }
      get subEvent() {
        return this.#subEvent;
      }
    };
    PrivateApplyRequest = class extends RequestBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "friendApply" }));
        this.#subEvent = "friendApply";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return true;
      }
      get isFriend() {
        return true;
      }
      get isGroup() {
        return false;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupApplyRequest = class extends RequestBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupApply" }));
        this.#subEvent = "groupApply";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      /**
       * @deprecated 已经弃用 请使用`groupId`
       */
      get group_id() {
        return this.contact.peer;
      }
      get groupId() {
        return this.contact.peer;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
    GroupInviteRequest = class extends RequestBase {
      #subEvent;
      #contact;
      #sender;
      content;
      constructor(options) {
        super(Object.assign(options, { subEvent: "groupInvite" }));
        this.#subEvent = "groupInvite";
        this.#contact = options.contact;
        this.#sender = options.sender;
        this.content = options.content;
      }
      /**
       * @deprecated 已经弃用 请使用`groupId`
       */
      get group_id() {
        return this.contact.peer;
      }
      get groupId() {
        return this.contact.peer;
      }
      get subEvent() {
        return this.#subEvent;
      }
      get contact() {
        return this.#contact;
      }
      get sender() {
        return this.#sender;
      }
      get isPrivate() {
        return false;
      }
      get isFriend() {
        return false;
      }
      get isGroup() {
        return true;
      }
      get isGuild() {
        return false;
      }
      get isDirect() {
        return false;
      }
      get isGroupTemp() {
        return false;
      }
    };
  }
});

// src/event/create/index.ts
var createFriendMessage, createGroupMessage, createGuildMessage, createDirectMessage, createGroupTempMessage, createReceiveLikeNotice, createFriendIncreaseNotice, createFriendDecreaseNotice, createPrivatePokeNotice, createPrivateRecallNotice, createPrivateFileUploadedNotice, createGroupPokeNotice, createGroupRecallNotice, createGroupFileUploadedNotice, createGroupCardChangedNotice, createGroupMemberTitleUpdatedNotice, createGroupHlightsChangedNotice, createGroupMemberAddNotice, createGroupMemberDelNotice, createGroupAdminChangedNotice, createGroupSignInNotice, createGroupMemberBanNotice, createGroupWholeBanNotice, createGroupMessageReactionNotice, createGroupLuckKingNotice, createGroupHonorChangedNotice, createGroupApplyRequest, createGroupInviteRequest, createPrivateApplyRequest;
var init_create = __esm({
  "src/event/create/index.ts"() {
    init_notice();
    init_request();
    init_message3();
    init_message4();
    init_notice2();
    init_request2();
    createFriendMessage = (options) => {
      const event = new FriendMessage(options);
      friendHandler(event);
      return event;
    };
    createGroupMessage = (options) => {
      const event = new GroupMessage(options);
      groupHandler(event);
      return event;
    };
    createGuildMessage = (options) => {
      const event = new GuildMessage(options);
      guildHandler(event);
      return event;
    };
    createDirectMessage = (options) => {
      const event = new DirectMessage(options);
      directHandler(event);
      return event;
    };
    createGroupTempMessage = (options) => {
      const event = new GroupTempMessage(options);
      groupTempHandler(event);
      return event;
    };
    createReceiveLikeNotice = (options) => {
      const event = new ReceiveLikeNotice(options);
      friendNoticeHandler(event);
      return event;
    };
    createFriendIncreaseNotice = (options) => {
      const event = new FriendIncreaseNotice(options);
      friendNoticeHandler(event);
      return event;
    };
    createFriendDecreaseNotice = (options) => {
      const event = new FriendDecreaseNotice(options);
      friendNoticeHandler(event);
      return event;
    };
    createPrivatePokeNotice = (options) => {
      const event = new PrivatePokeNotice(options);
      friendNoticeHandler(event);
      return event;
    };
    createPrivateRecallNotice = (options) => {
      const event = new PrivateRecallNotice(options);
      friendNoticeHandler(event);
      return event;
    };
    createPrivateFileUploadedNotice = (options) => {
      const event = new PrivateFileUploadedNotice(options);
      friendNoticeHandler(event);
      return event;
    };
    createGroupPokeNotice = (options) => {
      const event = new GroupPokeNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupRecallNotice = (options) => {
      const event = new GroupRecallNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupFileUploadedNotice = (options) => {
      const event = new GroupFileUploadedNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupCardChangedNotice = (options) => {
      const event = new GroupCardChangedNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupMemberTitleUpdatedNotice = (options) => {
      const event = new GroupMemberTitleUpdatedNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupHlightsChangedNotice = (options) => {
      const event = new GroupHlightsChangedNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupMemberAddNotice = (options) => {
      const event = new GroupMemberIncreaseNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupMemberDelNotice = (options) => {
      const event = new GroupMemberDecreaseNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupAdminChangedNotice = (options) => {
      const event = new GroupAdminChangedNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupSignInNotice = (options) => {
      const event = new GroupSignInNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupMemberBanNotice = (options) => {
      const event = new GroupMemberBanNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupWholeBanNotice = (options) => {
      const event = new GroupWholeBanNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupMessageReactionNotice = (options) => {
      const event = new GroupMessageReactionNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupLuckKingNotice = (options) => {
      const event = new GroupLuckKingNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupHonorChangedNotice = (options) => {
      const event = new GroupHonorChangedNotice(options);
      groupNoticeHandler(event);
      return event;
    };
    createGroupApplyRequest = (options) => {
      const event = new GroupApplyRequest(options);
      groupRequestHandler(event);
      return event;
    };
    createGroupInviteRequest = (options) => {
      const event = new GroupInviteRequest(options);
      groupRequestHandler(event);
      return event;
    };
    createPrivateApplyRequest = (options) => {
      const event = new PrivateApplyRequest(options);
      friendRequestHandler(event);
      return event;
    };
  }
});

// src/event/sender.ts
var senderFriend, senderGroup, senderGuild, senderDirect, senderGroupTemp, sender;
var init_sender = __esm({
  "src/event/sender.ts"() {
    senderFriend = (userId, name = "", sex, age, uid, uin) => {
      if (!name) name = "";
      return {
        userId,
        nick: name,
        name: name || "",
        sex: sex || "unknown",
        age: age || 0,
        uid: uid || "",
        uin: uin || 0
      };
    };
    senderGroup = (userId, role, name, sex, age, card, area, level, title, uid, uin) => {
      if (typeof userId === "object") {
        const name2 = userId.name || "";
        return {
          userId: userId.userId,
          nick: name2,
          name: name2,
          role: userId.role || "unknown",
          card: userId.card || "",
          area: userId.area || "",
          level: userId.level || 0,
          title: userId.title || "",
          sex: userId.sex || "unknown",
          age: userId.age || 0,
          uid: userId.uid || "",
          uin: userId.uin || 0
        };
      }
      if (typeof userId === "string") {
        return {
          userId,
          nick: name || "",
          name: name || "",
          role: role || "unknown",
          card: card || "",
          area: area || "",
          level: level || 0,
          title: title || "",
          sex: sex || "unknown",
          age: age || 0,
          uid: uid || "",
          uin: uin || 0
        };
      }
      throw TypeError("\u63D0\u4F9B\u7684\u53C2\u6570\u7C7B\u578B\u9519\u8BEF");
    };
    senderGuild = (userId, role, name = "", sex, age) => {
      if (!name) name = "";
      return {
        userId,
        nick: name,
        name: name || "",
        role: role || "unknown",
        sex: sex || "unknown",
        age: age || 0
      };
    };
    senderDirect = senderFriend;
    senderGroupTemp = senderFriend;
    sender = {
      /** 好友场景 */
      friend: senderFriend,
      /** 群聊场景 */
      group: senderGroup,
      /** 频道场景 */
      guild: senderGuild,
      /** 频道私信场景 */
      direct: senderDirect,
      /** 群聊临时会话场景 */
      groupTemp: senderGroupTemp
    };
  }
});

// src/event/contact.ts
var contactFriend, contactGroup, contactDirect, contactGuild, contactGroupTemp, contact2;
var init_contact = __esm({
  "src/event/contact.ts"() {
    contactFriend = (peer, name = "") => {
      return {
        scene: "friend",
        peer,
        name
      };
    };
    contactGroup = (peer, name = "") => {
      return {
        scene: "group",
        peer,
        name
      };
    };
    contactDirect = (peer, subId, name = "", subName = "") => {
      return {
        scene: "direct",
        peer,
        subPeer: subId,
        name,
        subName
      };
    };
    contactGuild = (peer, subPeer, name = "", subName = "") => {
      return {
        scene: "guild",
        peer,
        subPeer,
        name,
        subName
      };
    };
    contactGroupTemp = (peer, subPeer, name = "") => {
      return {
        scene: "groupTemp",
        peer,
        subPeer,
        name
      };
    };
    contact2 = {
      /** 好友场景 */
      friend: contactFriend,
      /** 群聊场景 */
      group: contactGroup,
      /** 频道场景 */
      guild: contactGuild,
      /** 频道私信场景 */
      direct: contactDirect,
      /** 群聊临时会话场景 */
      groupTemp: contactGroupTemp
    };
  }
});

// src/event/index.ts
var init_event2 = __esm({
  "src/event/index.ts"() {
    init_base2();
    init_notice2();
    init_sender();
    init_contact();
    init_message4();
    init_request2();
    init_create();
  }
});

// src/adapter/onebot/create/message.ts
var createMessage;
var init_message5 = __esm({
  "src/adapter/onebot/create/message.ts"() {
    init_convert();
    init_create();
    init_event2();
    createMessage = async (event, bot) => {
      const time2 = event.time;
      if (event.message_type === "private") {
        if (event.sub_type === "friend" || event.sub_type === "other") {
          const userId = event.sender.user_id + "";
          const contact3 = contactFriend(userId);
          const sender2 = senderFriend(
            userId,
            event.sender.nickname,
            event.sender.sex,
            event.sender.age
          );
          createFriendMessage({
            bot,
            time: time2,
            contact: contact3,
            sender: sender2,
            rawEvent: event,
            messageId: event.message_id + "",
            messageSeq: event.message_id,
            eventId: `message:${event.message_id}`,
            elements: await AdapterConvertKarin(event.message, bot),
            srcReply: (elements) => bot.sendMsg(contact3, elements)
          });
          return;
        }
        if (event.sub_type === "group") {
          const groupId = event.sender.group_id + "" || event.temp_source + "" || event.group_id + "";
          const userId = event.sender.user_id + "";
          const contact3 = contactGroupTemp(groupId, userId);
          const sender2 = senderFriend(userId, event.sender.nickname);
          createGroupTempMessage({
            bot,
            contact: contact3,
            elements: await AdapterConvertKarin(event.message, bot),
            eventId: `message:${event.message_id}`,
            messageId: event.message_id + "",
            messageSeq: event.message_id,
            rawEvent: event,
            sender: sender2,
            time: time2,
            srcReply: (elements) => bot.sendMsg(contact3, elements)
          });
          return;
        }
        logger.warn(`[OneBot] \u6536\u5230\u672A\u77E5\u7684\u79C1\u804A\u4E8B\u4EF6: ${JSON.stringify(event)}`);
        return;
      }
      if (event.message_type === "group" && event.sub_type === "normal") {
        const groupId = event.group_id + "";
        const userId = event.sender.user_id + "";
        const { nickname, role, sex, age, card, area, level, title } = event.sender;
        const contact3 = contactGroup(groupId);
        const sender2 = senderGroup({
          userId,
          role,
          nick: nickname,
          name: nickname,
          sex,
          age,
          card,
          area,
          level: +level,
          title
        });
        createGroupMessage({
          bot,
          contact: contact3,
          elements: await AdapterConvertKarin(event.message, bot),
          eventId: `message:${event.message_id}`,
          messageId: event.message_id + "",
          messageSeq: event.message_id,
          rawEvent: event,
          sender: sender2,
          time: time2,
          srcReply: (elements) => bot.sendMsg(contact3, elements)
        });
        return;
      }
      logger.warn(`[OneBot] \u6536\u5230\u672A\u77E5\u4E8B\u4EF6: ${JSON.stringify(event)}`);
    };
  }
});

// src/adapter/onebot/create/notice.ts
var createNotice;
var init_notice3 = __esm({
  "src/adapter/onebot/create/notice.ts"() {
    init_event2();
    init_create();
    init_convert();
    init_dist2();
    createNotice = (event, bot) => {
      const time2 = event.time;
      if (event.notice_type === NoticeType.FriendRecall) {
        const userId = event.user_id + "";
        const messageId = event.message_id + "";
        const contact3 = contactFriend(userId);
        createPrivateRecallNotice({
          bot,
          eventId: `notice:${userId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderFriend(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            messageId,
            operatorId: userId,
            tips: ""
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.FriendAdd) {
        const userId = event.user_id + "";
        const contact3 = contactFriend(userId);
        createFriendIncreaseNotice({
          bot,
          eventId: `notice:${userId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderFriend(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            targetId: userId
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.Notify && event.sub_type === "poke" && event.group_id) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupPokeNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            operatorId: userId,
            targetId: event.target_id + "",
            action: "",
            actionImage: "",
            suffix: ""
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.Notify && event.sub_type === "poke") {
        const userId = event.user_id + "";
        const contact3 = contactFriend(userId);
        createPrivatePokeNotice({
          bot,
          eventId: `notice:${userId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderFriend(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            operatorId: userId,
            targetId: event.target_id + "",
            action: "",
            actionImage: "",
            suffix: ""
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.Notify && event.sub_type === "lucky_king") {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupLuckKingNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            userId,
            targetId: event.target_id + ""
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.Notify && event.sub_type === "honor") {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupHonorChangedNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            honorType: event.honor_type
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupRecall) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const messageId = event.message_id + "";
        const operatorId = event.operator_id + "";
        const contact3 = contactGroup(groupId);
        createGroupRecallNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            messageId,
            operatorId,
            targetId: userId,
            tip: ""
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupIncrease) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupMemberAddNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            operatorId: event.operator_id + "",
            targetId: userId,
            type: event.sub_type
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupDecrease) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupMemberDelNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            operatorId: event.operator_id + "",
            targetId: userId,
            type: event.sub_type === "kick_me" ? "kickBot" : event.sub_type
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupUpload) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupFileUploadedNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            fid: event.file.id,
            name: event.file.name,
            size: event.file.size,
            subId: event.file.busid,
            url: async () => {
              const { file: file2 } = await getFileMessage(event.file, bot);
              return file2;
            }
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupAdmin) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupAdminChangedNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            targetId: userId,
            isAdmin: event.sub_type === "set"
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupBan) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupMemberBanNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            operatorId: event.operator_id + "",
            targetId: userId,
            duration: event.duration,
            isBan: event.sub_type === "ban"
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.Nc_EmojiLike) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupMessageReactionNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            count: event.likes[0].count,
            faceId: event.likes[0].emoji_id,
            isSet: true,
            messageId: event.message_id + ""
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.Lgl_EmojiLike) {
        const userId = event.operator_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupMessageReactionNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            count: event.count,
            faceId: Number(event.code),
            isSet: event.sub_type === "add",
            messageId: event.message_id + ""
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupEssence) {
        const userId = event.sender_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupHlightsChangedNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            isSet: event.sub_type === "add",
            messageId: event.message_id + "",
            operatorId: event.operator_id + "",
            senderId: userId
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.GroupCard) {
        const userId = event.user_id + "";
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupCardChangedNotice({
          bot,
          eventId: `notice:${groupId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderGroup(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            newCard: event.card_new,
            operatorId: "",
            targetId: userId
          }
        });
        return;
      }
      if (event.notice_type === NoticeType.Lgl_FriendOfflineFile) {
        const userId = event.user_id + "";
        const contact3 = contactFriend(userId);
        createPrivateFileUploadedNotice({
          bot,
          eventId: `notice:${userId}.${event.time}`,
          rawEvent: event,
          time: time2,
          contact: contact3,
          sender: senderFriend(userId),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            operatorId: userId,
            subId: 0,
            fid: event.file.id,
            name: event.file.name,
            size: event.file.size,
            expireTime: 0,
            url: async () => {
              const { file: file2 } = await getFileMessage(event.file, bot);
              return file2;
            }
          }
        });
        return;
      }
      logger.warn(`[AdapterOneBot] \u6536\u5230\u672A\u77E5\u4E8B\u4EF6: ${JSON.stringify(event)}`);
    };
  }
});

// src/adapter/onebot/create/request.ts
var createRequest;
var init_request3 = __esm({
  "src/adapter/onebot/create/request.ts"() {
    init_dist2();
    init_event2();
    init_create();
    createRequest = (event, bot) => {
      const time2 = event.time;
      const userId = event.user_id + "";
      if (event.request_type === RequestType.Friend) {
        const contact3 = contactFriend(userId);
        createPrivateApplyRequest({
          bot,
          time: time2,
          contact: contact3,
          rawEvent: event,
          subEvent: "friendApply",
          eventId: `request:${event.flag}`,
          sender: senderFriend(userId, ""),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            applierId: userId,
            message: event.comment,
            flag: event.flag
          }
        });
        return;
      }
      if (event.request_type === RequestType.Group && event.sub_type === "add") {
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupApplyRequest({
          bot,
          time: time2,
          contact: contact3,
          rawEvent: event,
          subEvent: "groupApply",
          eventId: `request:${event.flag}`,
          sender: senderGroup(userId, "member"),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            applierId: userId,
            inviterId: "",
            reason: event.comment,
            flag: event.flag,
            groupId
          }
        });
        return;
      }
      if (event.request_type === RequestType.Group && event.sub_type === "invite") {
        const groupId = event.group_id + "";
        const contact3 = contactGroup(groupId);
        createGroupInviteRequest({
          bot,
          time: time2,
          contact: contact3,
          rawEvent: event,
          subEvent: "groupInvite",
          eventId: `request:${event.flag}`,
          sender: senderGroup(userId, "member"),
          srcReply: (elements) => bot.sendMsg(contact3, elements),
          content: {
            inviterId: userId,
            flag: event.flag
          }
        });
        return;
      }
      logger.warn(`[AdapterOneBot] \u6536\u5230\u672A\u77E5\u4E8B\u4EF6: ${JSON.stringify(event)}`);
    };
  }
});
var addHook3, sendMsg, emitHooks3, hooksSendMsgEmit;
var init_sendMsg = __esm({
  "src/hooks/sendMsg.ts"() {
    init_cache3();
    addHook3 = (list2, callback, options = {}) => {
      const id = createHookId();
      list2.push({
        id,
        priority: options.priority ?? 1e4,
        callback
      });
      return { id, list: lodash3.orderBy(list2, ["priority"], ["asc"]) };
    };
    sendMsg = {
      /**
       * 添加普通消息钩子 `也就是调用 bot.sendMsg 时触发 此时会先进入这个 hook 才会到 bot.sendMsg`
       * @param callback 消息处理回调函数
       * @param options 钩子配置项
       * @returns 钩子ID
       */
      message: (callback, options = {}) => {
        const { id, list: list2 } = addHook3(cache4.sendMsg.message, callback, options);
        logger.mark(`[hooks] \u6DFB\u52A0\u53D1\u9001\u6D88\u606F\u94A9\u5B50: ${id}`);
        cache4.sendMsg.message = list2;
        return id;
      },
      /**
       * 添加转发消息钩子 `也就是调用 bot.sendForwardMsg 时触发 此时会先进入这个 hook 才会到 bot.sendForwardMsg`
       * @param callback 消息处理回调函数
       * @param options 钩子配置项
       * @returns 钩子ID
       */
      forward: (callback, options = {}) => {
        const { id, list: list2 } = addHook3(cache4.sendMsg.forward, callback, options);
        logger.mark(`[hooks] \u6DFB\u52A0\u53D1\u9001\u6D88\u606F\u94A9\u5B50: ${id}`);
        cache4.sendMsg.forward = list2;
        return id;
      },
      /**
       * 添加普通消息发送后钩子 `也就是调用 bot.sendMsg 处理完成返回结果前触发 此时会先进入这个 hook 才会正常返回结果`
       * @param callback 消息处理回调函数
       * @param options 钩子配置项
       * @returns 钩子ID
       */
      afterMessage: (callback, options = {}) => {
        const { id, list: list2 } = addHook3(cache4.sendMsg.afterMessage, callback, options);
        logger.mark(`[hooks] \u6DFB\u52A0\u53D1\u9001\u6D88\u606F\u540E\u94A9\u5B50: ${id}`);
        cache4.sendMsg.afterMessage = list2;
        return id;
      },
      /**
       * 添加转发消息发送后钩子 `也就是调用 bot.sendForwardMsg 处理完成返回结果前触发 此时会先进入这个 hook 才会正常返回结果`
       * @param callback 消息处理回调函数
       * @param options 钩子配置项
       * @returns 钩子ID
       */
      afterForward: (callback, options = {}) => {
        const { id, list: list2 } = addHook3(cache4.sendMsg.afterForward, callback, options);
        logger.mark(`[hooks] \u6DFB\u52A0\u53D1\u9001\u8F6C\u53D1\u6D88\u606F\u540E\u94A9\u5B50: ${id}`);
        cache4.sendMsg.afterForward = list2;
        return id;
      },
      /**
       * 删除钩子
       * @param id 钩子ID
       */
      remove: (id) => {
        logger.mark(`[hooks] \u79FB\u9664\u53D1\u9001\u6D88\u606F\u94A9\u5B50: ${id}`);
        cache4.sendMsg.message = cache4.sendMsg.message.filter((item) => item.id !== id);
        cache4.sendMsg.forward = cache4.sendMsg.forward.filter((item) => item.id !== id);
        cache4.sendMsg.afterMessage = cache4.sendMsg.afterMessage.filter((item) => item.id !== id);
        cache4.sendMsg.afterForward = cache4.sendMsg.afterForward.filter((item) => item.id !== id);
      }
    };
    emitHooks3 = async (hooks2, callback) => {
      let shouldContinue = false;
      for (const hook of hooks2) {
        const next = () => {
          shouldContinue = true;
        };
        const result = callback(hook, next);
        if (isPromise(result)) await result;
        if (!shouldContinue) return false;
        shouldContinue = false;
      }
      return true;
    };
    hooksSendMsgEmit = {
      /**
       * 触发普通消息钩子
       * @param contact 联系人
       * @param elements 消息元素
       * @param retryCount 重试次数
       * @returns 是否继续正常流程
       */
      message: async (contact3, elements, retryCount = 0) => {
        return emitHooks3(
          cache4.sendMsg.message,
          (hook, next) => hook.callback(contact3, elements, retryCount, next)
        );
      },
      /**
       * 触发转发消息钩子
       * @param contact 联系人
       * @param elements 消息元素
       * @param options 转发选项
       * @returns 是否继续正常流程
       */
      forward: async (contact3, elements, options) => {
        return emitHooks3(
          cache4.sendMsg.forward,
          (hook, next) => hook.callback(contact3, elements, options, next)
        );
      },
      /**
       * 触发普通消息发送后钩子
       * @param contact 联系人
       * @param elements 消息元素
       * @param result 消息发送结果
       */
      afterMessage: async (contact3, elements, result) => {
        await emitHooks3(
          cache4.sendMsg.afterMessage,
          (hook, next) => hook.callback(contact3, elements, result, next)
        );
      },
      /**
       * 触发转发消息发送后钩子
       * @param contact 联系人
       * @param elements 消息元素
       * @param result 转发消息发送结果
       * @param options 转发选项
       */
      afterForward: async (contact3, elements, result, options) => {
        await emitHooks3(
          cache4.sendMsg.afterForward,
          (hook, next) => hook.callback(contact3, elements, result, options, next)
        );
      }
    };
  }
});

// src/service/bot.ts
var index2, list, getBot, getAllBot, getAllBotList, getAllBotID, getBotCount, unregisterBot, registerBot, sendMsg2;
var init_bot = __esm({
  "src/service/bot.ts"() {
    init_message2();
    init_key2();
    init_sendMsg();
    init_listeners();
    init_common();
    index2 = 0;
    list = [];
    getBot = (id, isProtocol = false) => {
      try {
        if (typeof id === "number") {
          return list.find((item) => item.index === id)?.bot || null;
        }
        if (isProtocol) {
          return list.find((item) => item.bot.adapter.protocol === id)?.bot || null;
        }
        return list.find((item) => item.bot.selfId === id)?.bot || null;
      } catch {
        return null;
      }
    };
    getAllBot = () => {
      return list.map((item) => item.bot);
    };
    getAllBotList = () => {
      return list;
    };
    getAllBotID = () => {
      return list.map((item) => item.bot.selfId);
    };
    getBotCount = () => {
      return list.length;
    };
    unregisterBot = (type, idOrIndex, address) => {
      const findIndexAndRemove = (predicate) => {
        const index6 = list.findIndex(predicate);
        if (index6 !== -1) {
          const [removed] = list.splice(index6, 1);
          logger.bot("info", removed.bot.selfId, `${logger.red("[service][\u5378\u8F7DBot]")} ${removed.bot.adapter.name}`);
          return true;
        }
        logger.warn(`[service][\u5378\u8F7DBot] \u672A\u627E\u5230\u6307\u5B9ABot: ${JSON.stringify({ type, idOrIndex, address })}`);
        return false;
      };
      if (type === "index") {
        return findIndexAndRemove((item) => item.index === idOrIndex);
      }
      if (type === "selfId") {
        return findIndexAndRemove(({ bot }) => bot.selfId === idOrIndex);
      }
      if (type === "address") {
        return findIndexAndRemove(({ bot }) => bot.selfId === idOrIndex && bot.adapter.address === address);
      }
      logger.warn(`[service][\u5378\u8F7DBot] \u672A\u77E5\u7684\u5378\u8F7D\u65B9\u5F0F: ${type}`);
      return false;
    };
    registerBot = (_, bot) => {
      const id = ++index2;
      list.push({ index: id, bot });
      const originSendMsg = bot.sendMsg;
      const originSendForwardMsg = bot.sendForwardMsg;
      bot.sendMsg = async (contact3, elements, retryCount) => {
        const hook = await hooksSendMsgEmit.message(contact3, elements, retryCount);
        if (!hook) return { messageId: "", time: -1, rawData: "", message_id: "", messageTime: -1 };
        try {
          const result = await originSendMsg.call(bot, contact3, elements, retryCount);
          await hooksSendMsgEmit.afterMessage(contact3, elements, result);
          return result;
        } catch (error) {
          if (typeof retryCount === "number" && retryCount > 0) {
            return bot.sendMsg(contact3, elements, retryCount - 1);
          }
          throw error;
        }
      };
      bot.sendForwardMsg = async (contact3, elements, options) => {
        const hook = await hooksSendMsgEmit.forward(contact3, elements, options);
        if (!hook) return { messageId: "", forwardId: "" };
        const result = await originSendForwardMsg.call(bot, contact3, elements, options);
        await hooksSendMsgEmit.afterForward(contact3, elements, result, options);
        return result;
      };
      setTimeout(async () => {
        const { createDB: createDB2 } = await Promise.resolve().then(() => (init_kv(), kv_exports));
        const db2 = await createDB2();
        const key = `karin:restart:${bot.selfId}`;
        const options = await db2.get(key);
        if (!options) return;
        try {
          const { selfId, contact: contact3, messageId, time: time2 } = options;
          const restartTime = ((Date.now() - time2) / 1e3).toFixed(2);
          if (Number(restartTime) > 120) {
            return false;
          }
          const element = [
            segment_exports.reply(messageId),
            segment_exports.text(`
\u91CD\u542F\u6210\u529F\uFF1A${restartTime}\u79D2`)
          ];
          await sendMsg2(selfId, contact3, element);
        } finally {
          await db2.del(key);
        }
      }, 10);
      setTimeout(() => {
        logger.bot("info", bot.selfId, `${logger.green("[registerBot]")}[${bot.adapter.name}]: ${bot.account.name} ${bot.adapter.address}`);
      }, 1e3);
      return id;
    };
    sendMsg2 = async (selfId, contact3, elements, options = { recallMsg: 0, retryCount: 1, retry_count: 1 }) => {
      let result = {};
      const NewElements = makeMessage(elements);
      const bot = getBot(selfId);
      if (!bot) throw new Error("\u53D1\u9001\u6D88\u606F\u5931\u8D25: \u672A\u627E\u5230\u5BF9\u5E94Bot\u5B9E\u4F8B");
      const { recallMsg } = options;
      const retryCount = options.retryCount ?? options.retry_count ?? 1;
      const { raw: raw2 } = createRawMessage(NewElements);
      if (contact3.scene === "group") {
        logger.bot("info", selfId, `${logger.green("Send Proactive Group")} ${contact3.peer}: ${raw2}`);
      } else {
        logger.bot("info", selfId, `${logger.green("Send Proactive private")} ${contact3.peer}: ${raw2}`);
      }
      try {
        listeners.emit(SEND_MSG, contact3);
        result = await bot.sendMsg(contact3, NewElements, retryCount);
        logger.bot("debug", selfId, `\u4E3B\u52A8\u6D88\u606F\u7ED3\u679C:${JSON.stringify(result, null, 2)}`);
      } catch (error) {
        logger.bot("error", selfId, `\u4E3B\u52A8\u6D88\u606F\u53D1\u9001\u5931\u8D25:${raw2}`);
        logger.error(error);
      }
      result.message_id = result.messageId;
      if (recallMsg && recallMsg > 0 && result?.messageId) {
        setTimeout(() => bot.recallMsg(contact3, result.messageId), recallMsg * 1e3);
      }
      return result;
    };
  }
});

// src/service/task/queue.ts
var queue_exports = {};
__export(queue_exports, {
  executeTask: () => executeTask,
  getTaskCallback: () => getTaskCallback,
  removeTaskCallback: () => removeTaskCallback,
  setTaskCallback: () => setTaskCallback
});
var taskCallbacks, setTaskCallback, getTaskCallback, removeTaskCallback, executeTask;
var init_queue = __esm({
  "src/service/task/queue.ts"() {
    taskCallbacks = /* @__PURE__ */ new Map();
    setTaskCallback = (taskId, executor) => {
      taskCallbacks.set(taskId, executor);
    };
    getTaskCallback = (taskId) => {
      return taskCallbacks.get(taskId);
    };
    removeTaskCallback = (taskId) => {
      return taskCallbacks.delete(taskId);
    };
    executeTask = async (task2, emitLog, emitStatus) => {
      emitStatus("running");
      try {
        const callback = taskCallbacks.get(task2.id);
        if (!callback) {
          emitLog(`\u672A\u627E\u5230\u4EFB\u52A1 ${task2.id} \u7684\u56DE\u8C03\u51FD\u6570`);
          emitStatus("failed");
          return false;
        }
        const startMessage = `\u5F00\u59CB\u6267\u884C\u4EFB\u52A1: ${task2.name} (\u76EE\u6807: ${task2.target})
`;
        emitLog(startMessage);
        const result = await callback(task2, emitLog);
        emitStatus(result ? "success" : "failed");
        if (typeof result === "boolean") {
          return result;
        }
        throw new Error("\u4EFB\u52A1\u6267\u884C\u5668\u8FD4\u56DE\u503C\u7C7B\u578B\u9519\u8BEF");
      } catch (error) {
        const errorMessage = `\u6267\u884C\u4EFB\u52A1\u51FA\u9519: ${error instanceof Error ? error.message : String(error)}
`;
        emitLog(errorMessage);
        emitStatus("failed");
        return false;
      }
    };
  }
});
var parseRow, handleUnfinishedTasks, initDatabase, taskAdd, taskUpdateStatus, taskUpdateLogs, taskGet, taskList, taskExists, _taskDB, setTaskDatabase, getTaskDatabase, updateTaskStatus, updateTaskLogs, createTaskDatabase;
var init_database = __esm({
  "src/service/task/database.ts"() {
    parseRow = (row) => {
      return {
        ...row
      };
    };
    handleUnfinishedTasks = async (db2) => {
      const now = Date.now();
      return new Promise((resolve, reject) => {
        db2.all(
          "SELECT id FROM tasks WHERE status = 'running'",
          [],
          async (err, rows) => {
            if (err) {
              reject(err);
              return;
            }
            if (rows.length === 0) {
              resolve();
              return;
            }
            try {
              await new Promise((resolve2, reject2) => {
                const taskIds = rows.map((row) => row.id);
                const placeholders = taskIds.map(() => "?").join(",");
                db2.run(
                  `UPDATE tasks SET
                status = 'timeout',
                updateTime = ?,
                endTime = ?,
                logs = logs || '
\u7CFB\u7EDF\u91CD\u542F\uFF0C\u4EFB\u52A1\u88AB\u6807\u8BB0\u4E3A\u8D85\u65F6\u5DF2\u53D6\u6D88'
              WHERE id IN (${placeholders})`,
                  [now, now, ...taskIds],
                  function(updateErr) {
                    if (updateErr) {
                      reject2(updateErr);
                      return;
                    }
                    console.log(`\u5DF2\u5C06 ${this.changes} \u4E2A\u672A\u5B8C\u6210\u4EFB\u52A1\u6807\u8BB0\u4E3A\u8D85\u65F6\u5DF2\u53D6\u6D88`);
                    resolve2();
                  }
                );
              });
              resolve();
            } catch (updateError) {
              reject(updateError);
            }
          }
        );
      });
    };
    initDatabase = async (dbPath2) => {
      const filename2 = `${dbPath2}/task.db`;
      if (fs5.existsSync(dbPath2) && fs5.statSync(dbPath2).isFile()) {
        fs5.renameSync(dbPath2, `${dbPath2}.bak`);
      }
      fs5.mkdirSync(dbPath2, { recursive: true });
      return new Promise((resolve, reject) => {
        const db2 = new sqlite3.Database(filename2, async (err) => {
          if (err) {
            reject(err);
            return;
          }
          try {
            await new Promise((resolve2, reject2) => {
              db2.exec(`
            CREATE TABLE IF NOT EXISTS tasks (
              id TEXT PRIMARY KEY,
              type TEXT NOT NULL,
              name TEXT NOT NULL,
              target TEXT NOT NULL,
              status TEXT NOT NULL,
              logs TEXT DEFAULT '',
              operatorIp TEXT NOT NULL,
              createTime INTEGER NOT NULL,
              updateTime INTEGER NOT NULL,
              endTime INTEGER
            )
          `, (err2) => {
                if (err2) {
                  reject2(err2);
                  return;
                }
                resolve2();
              });
            });
            await handleUnfinishedTasks(db2);
            resolve({ db: db2 });
          } catch (error) {
            reject(error);
          }
        });
      });
    };
    taskAdd = async (taskDB, taskParams) => {
      const taskId = randomUUID();
      const now = Date.now();
      const allPossibleFields = [
        "id",
        "type",
        "name",
        "target",
        "status",
        "logs",
        "operatorIp",
        "createTime",
        "updateTime"
      ];
      const fields = [
        "id",
        "type",
        "name",
        "target",
        "status",
        "logs",
        "operatorIp",
        "createTime",
        "updateTime"
      ];
      const values = [
        taskId,
        taskParams.type,
        taskParams.name,
        taskParams.target,
        "pending",
        "",
        taskParams.operatorIp,
        taskParams.createTime || now,
        now
      ];
      if (!fields.every((field) => allPossibleFields.includes(field))) {
        return Promise.reject(new Error("\u5305\u542B\u65E0\u6548\u7684\u6570\u636E\u5E93\u5B57\u6BB5"));
      }
      const placeholders = values.map(() => "?").join(", ");
      return new Promise((resolve, reject) => {
        taskDB.db.run(
          `INSERT INTO tasks (${fields.join(", ")}) VALUES (${placeholders})`,
          values,
          function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(taskId);
          }
        );
      });
    };
    taskUpdateStatus = async (taskDB, taskId, status) => {
      const now = Date.now();
      const endTime = status !== "pending" && status !== "running" ? now : null;
      return new Promise((resolve, reject) => {
        taskDB.db.run(
          "UPDATE tasks SET status = ?, updateTime = ?, endTime = ? WHERE id = ?",
          [status, now, endTime, taskId],
          function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(this.changes > 0);
          }
        );
      });
    };
    taskUpdateLogs = async (taskDB, taskId, logs2) => {
      return new Promise((resolve, reject) => {
        taskDB.db.run(
          "UPDATE tasks SET logs = ? WHERE id = ?",
          [logs2, taskId],
          function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(this.changes > 0);
          }
        );
      });
    };
    taskGet = async (taskDB, taskId) => {
      return new Promise((resolve, reject) => {
        taskDB.db.get(
          "SELECT * FROM tasks WHERE id = ?",
          [taskId],
          (err, row) => {
            if (err) {
              reject(err);
              return;
            }
            if (!row) {
              resolve(null);
              return;
            }
            resolve(parseRow(row));
          }
        );
      });
    };
    taskList = async (taskDB, filter) => {
      let query = "SELECT * FROM tasks";
      const params = [];
      const conditions = [];
      const safeConditionFields = {
        type: "type = ?",
        name: "name LIKE ?",
        operatorIp: "operatorIp = ?",
        status: "status = ?"
      };
      if (filter) {
        if (filter.type) {
          conditions.push(safeConditionFields.type);
          params.push(filter.type);
        }
        if (filter.name) {
          conditions.push(safeConditionFields.name);
          params.push(`%${filter.name}%`);
        }
        if (filter.operatorIp) {
          conditions.push(safeConditionFields.operatorIp);
          params.push(filter.operatorIp);
        }
        if (filter.status) {
          if (Array.isArray(filter.status)) {
            const statusPlaceholders = filter.status.map(() => "?").join(",");
            conditions.push(`status IN (${statusPlaceholders})`);
            params.push(...filter.status);
          } else {
            conditions.push(safeConditionFields.status);
            params.push(filter.status);
          }
        }
      }
      if (conditions.length > 0) {
        query += " WHERE " + conditions.join(" AND ");
      }
      query += " ORDER BY createTime DESC";
      if (filter?.limit && filter.limit > 0) {
        query += " LIMIT ?";
        params.push(filter.limit);
      }
      return new Promise((resolve, reject) => {
        taskDB.db.all(query, params, (err, rows) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(rows.map(parseRow));
        });
      });
    };
    taskExists = async (taskDB, type, target, statuses) => {
      const placeholders = statuses.map(() => "?").join(",");
      return new Promise((resolve, reject) => {
        taskDB.db.get(
          `SELECT COUNT(*) as count FROM tasks WHERE type = ? AND target = ? AND status IN (${placeholders})`,
          [type, target, ...statuses],
          (err, row) => {
            if (err) {
              reject(err);
              return;
            }
            resolve(row.count > 0);
          }
        );
      });
    };
    _taskDB = null;
    setTaskDatabase = (db2) => {
      _taskDB = db2;
    };
    getTaskDatabase = () => {
      return _taskDB;
    };
    updateTaskStatus = async (taskId, status) => {
      if (!_taskDB) {
        throw new Error("\u4EFB\u52A1\u6570\u636E\u5E93\u672A\u521D\u59CB\u5316");
      }
      return taskUpdateStatus(_taskDB, taskId, status);
    };
    updateTaskLogs = async (taskId, logs2) => {
      if (!_taskDB) {
        throw new Error("\u4EFB\u52A1\u6570\u636E\u5E93\u672A\u521D\u59CB\u5316");
      }
      return taskUpdateLogs(_taskDB, taskId, logs2);
    };
    createTaskDatabase = async (dbPath2) => {
      const taskDB = await initDatabase(dbPath2);
      return {
        /**
         * 添加任务
         * @param params - 任务参数
         * @param executor - 任务执行回调函数
         * @returns 任务ID
         */
        add: async (params, executor) => {
          const taskId = await taskAdd(taskDB, params);
          if (executor) {
            const { setTaskCallback: setTaskCallback2 } = await Promise.resolve().then(() => (init_queue(), queue_exports));
            setTaskCallback2(taskId, executor);
          }
          return taskId;
        },
        /**
         * 获取任务详情
         * @param taskId - 任务ID
         * @returns 任务详情
         */
        get: (taskId) => taskGet(taskDB, taskId),
        /**
         * 获取任务列表
         * @param filter - 过滤条件
         * @returns 任务列表
         */
        list: (filter) => taskList(taskDB, filter),
        /**
         * 获取所有任务列表
         * @returns 所有任务列表
         */
        all: () => taskList(taskDB),
        /**
         * 获取任务日志
         * @param taskId - 任务ID
         * @returns 任务日志内容
         */
        logs: async (taskId) => {
          const task2 = await taskGet(taskDB, taskId);
          return task2?.logs || null;
        },
        /**
         * 取消任务
         * @param taskId - 任务ID
         * @returns 是否成功
         */
        cancel: async (taskId) => {
          return new Promise((resolve, reject) => {
            const now = Date.now();
            taskDB.db.run(
              "UPDATE tasks SET status = ?, updateTime = ?, endTime = ?, logs = logs || ? WHERE id = ? AND (status = ? OR status = ?)",
              ["cancelled", now, now, "\n\u4EFB\u52A1\u5DF2\u88AB\u624B\u52A8\u53D6\u6D88", taskId, "pending", "running"],
              function(err) {
                if (err) {
                  reject(err);
                  return;
                }
                Promise.resolve().then(() => (init_queue(), queue_exports)).then(({ removeTaskCallback: removeTaskCallback2 }) => {
                  removeTaskCallback2(taskId);
                });
                resolve(this.changes > 0);
              }
            );
          });
        },
        /**
         * 删除任务
         * @param taskId - 任务ID
         * @returns 是否成功
         */
        delete: async (taskId) => {
          return new Promise((resolve, reject) => {
            taskDB.db.run(
              "DELETE FROM tasks WHERE id = ?",
              [taskId],
              function(err) {
                if (err) {
                  reject(err);
                  return;
                }
                Promise.resolve().then(() => (init_queue(), queue_exports)).then(({ removeTaskCallback: removeTaskCallback2 }) => {
                  removeTaskCallback2(taskId);
                });
                resolve(this.changes > 0);
              }
            );
          });
        },
        /**
         * 检查是否存在相同类型和目标的任务
         * @param type - 任务类型
         * @param target - 目标
         * @param statuses - 状态列表
         * @returns 是否存在
         */
        exists: (type, target, statuses) => {
          return taskExists(taskDB, type, target, statuses);
        },
        /**
         * 更新任务状态
         * @param taskId - 任务ID
         * @param status - 新状态
         * @returns 是否成功
         */
        update: {
          status: (taskId, status) => {
            return taskUpdateStatus(taskDB, taskId, status);
          },
          /**
           * 更新任务日志
           * @param taskId - 任务ID
           * @param logs - 完整日志内容
           * @returns 是否成功
           */
          logs: (taskId, logs2) => {
            return taskUpdateLogs(taskDB, taskId, logs2);
          }
        },
        /**
         * 运行任务
         * @param taskId - 任务ID
         * @param onLog - 日志回调函数
         * @param onStatusChange - 状态变更回调函数
         * @returns 是否成功
         */
        run: async (taskId, onLog = () => {
        }, onStatusChange = () => {
        }) => {
          const task2 = await taskGet(taskDB, taskId);
          if (!task2) {
            onLog(`\u4EFB\u52A1 ${taskId} \u4E0D\u5B58\u5728`);
            onStatusChange("failed");
            return false;
          }
          const { executeTask: executeTask2, getTaskCallback: getTaskCallback2 } = await Promise.resolve().then(() => (init_queue(), queue_exports));
          if (!getTaskCallback2(taskId)) {
            onLog(`\u4EFB\u52A1 ${taskId} \u6CA1\u6709\u5173\u8054\u7684\u6267\u884C\u56DE\u8C03\u51FD\u6570`);
            onStatusChange("failed");
            return false;
          }
          await taskUpdateStatus(taskDB, taskId, "running");
          const logCollector = (log3) => onLog(log3);
          const statusListener2 = async (status) => {
            await taskUpdateStatus(taskDB, taskId, status);
            onStatusChange(status);
            if (status !== "pending" && status !== "running") {
              const { removeTaskCallback: removeTaskCallback2 } = await Promise.resolve().then(() => (init_queue(), queue_exports));
              removeTaskCallback2(taskId);
            }
          };
          return executeTask2(task2, logCollector, statusListener2);
        }
      };
    };
  }
});

// src/service/task/index.ts
var taskSystem, initTaskSystem;
var init_task = __esm({
  "src/service/task/index.ts"() {
    init_database();
    init_queue();
    init_database();
    init_queue();
    initTaskSystem = async (dbPath2) => {
      taskSystem = await createTaskDatabase(dbPath2);
      return taskSystem;
    };
  }
});

// src/service/index.ts
var init_service = __esm({
  "src/service/index.ts"() {
    init_bot();
    init_handler();
    init_task();
  }
});

// src/adapter/onebot/core/core.ts
var AdapterOneBot;
var init_core = __esm({
  "src/adapter/onebot/core/core.ts"() {
    init_base();
    init_message5();
    init_notice3();
    init_request3();
    init_event2();
    init_dist2();
    init_service();
    init_convert();
    AdapterOneBot = class extends AdapterBase {
      #isInit = false;
      _onebot;
      constructor(_onebot) {
        super();
        this.adapter.platform = "qq";
        this.adapter.standard = "onebot11";
        this._onebot = _onebot;
      }
      async init() {
        if (this.#isInit) return;
        this.#isInit = true;
        await this._onebot.init();
        this.setAdapterInfo();
        this.setBotInfo();
        this._onebot.on(OneBotEventKey.EVENT, (data) => {
          if (this._onebot.isEcho(data)) return;
          if (data.post_type === "message") return createMessage(data, this);
          if (data.post_type === "notice") return createNotice(data, this);
          if (data.post_type === "request") return createRequest(data, this);
          if (data.post_type === "meta_event") {
            if (data.meta_event_type === "lifecycle") {
              if (data.sub_type === "enable") {
                return logger.bot("mark", this.selfId, "OneBot\u542F\u7528");
              }
              if (data.sub_type === "disable") {
                return logger.bot("mark", this.selfId, "OneBot\u505C\u7528");
              }
              if (data.sub_type === "connect") {
                return logger.bot("mark", this.selfId, "WebSocket\u8FDE\u63A5\u6210\u529F");
              }
            }
            if (data.meta_event_type === "heartbeat") {
              return logger.bot("trace", this.selfId, "\u5FC3\u8DF3:\n" + JSON.stringify(data, null, 2));
            }
          }
          logger.bot("warn", this.selfId, `\u6536\u5230\u672A\u77E5\u4E8B\u4EF6: ${JSON.stringify(data, null, 2)}`);
        });
      }
      /**
       * 注册机器人
       */
      registerBot() {
        logger.bot("info", this.selfId, `[OneBot][${this.adapter.communication}] \u8FDE\u63A5\u6210\u529F: ${this.adapter.address}`);
        this.adapter.index = registerBot(this.adapter.communication, this);
      }
      /**
       * 卸载注册的机器人
       */
      unregisterBot() {
        unregisterBot("index", this.adapter.index);
        logger.bot("info", this.selfId, `\u8FDE\u63A5\u5173\u95ED: ${this.adapter.address}`);
      }
      /** 设置登录号信息 */
      setAdapterInfo() {
        this.adapter.platform = "qq";
        this.adapter.name = this._onebot.protocol.name;
        this.adapter.version = this._onebot.protocol.version;
        if (/gocq/i.test(this.adapter.name)) {
          this.adapter.protocol = "gocq-http";
        } else if (/napcat/i.test(this.adapter.name)) {
          this.adapter.protocol = "napcat";
        } else if (/llonebot/i.test(this.adapter.name)) {
          this.adapter.protocol = "llonebot";
        } else if (/lagrange/i.test(this.adapter.name)) {
          this.adapter.protocol = "lagrange";
        } else if (/conwechat/i.test(this.adapter.name)) {
          this.adapter.protocol = "conwechat";
        } else {
          this.adapter.protocol = "other";
        }
      }
      /**
       * 设置登录号详细信息
       */
      async setBotInfo() {
        this.account.name = this._onebot.self.nickname;
        this.account.avatar = this._onebot.self.avatar;
        this.account.selfId = this._onebot.self_id + "";
      }
      async sendApi(action, params, timeout2) {
        return this._onebot.sendApi(action, params, timeout2);
      }
      /**
       * onebot11转karin
       * @param data onebot11格式消息
       * @param contact 联系人信息 如果需要转换napcat的文件消息则需要传入
       * @return karin格式消息
       */
      AdapterConvertKarin(data) {
        return AdapterConvertKarin(data, this);
      }
      /**
       * karin转onebot11
       * @param data karin格式消息
       */
      KarinConvertAdapter(data) {
        return KarinConvertAdapter(data, this);
      }
      /**
       * 获取头像url
       * @param userId 头像大小，默认`0`
       * @param size 头像大小，默认`0`
       * @returns 头像的url地址
       */
      async getAvatarUrl(userId = this.account.selfId, size = 0) {
        return Number(userId) ? `https://q1.qlogo.cn/g?b=qq&s=${size}&nk=${userId}` : `https://q.qlogo.cn/qqapp/${userId}/${userId}/${size}`;
      }
      /**
       * 获取群头像
       * @param groupId 群号
       * @param size 头像大小，默认`0`
       * @param history 历史头像记录，默认`0`，若要获取历史群头像则填写1,2,3...
       * @returns 群头像的url地址
       */
      async getGroupAvatarUrl(groupId, size = 0, history = 0) {
        return `https://p.qlogo.cn/gh/${groupId}/${groupId}${history ? "_" + history : ""}/` + size;
      }
      /**
       * 发送消息
       * @param contact
       * @param elements
       * @returns 消息ID
       */
      async sendMsg(contact3, elements, retryCount) {
        try {
          const message2 = this.KarinConvertAdapter(elements);
          let res;
          if (contact3.scene === "group") {
            res = await this._onebot.sendGroupMsg(Number(contact3.peer), message2);
          } else if (contact3.scene === "groupTemp") {
            res = await this._onebot.sendPrivateMsg(Number(contact3.subPeer), message2);
          } else {
            res = await this._onebot.sendPrivateMsg(Number(contact3.peer), message2);
          }
          const messageId = String(res.message_id);
          const messageTime = Date.now();
          const rawData = res;
          return { messageId, messageTime, rawData, message_id: messageId, time: messageTime };
        } catch (error) {
          if (retryCount && retryCount > 0) {
            return this.sendMsg(contact3, elements, retryCount - 1);
          }
          throw error;
        }
      }
      // /**
      //  * 上传合并转发消息
      //  * @param contact 联系人信息
      //  * @param elements nodes
      //  * @returns 资源id
      //  */
      // async UploadForwardMessage (contact: Contact, elements: NodeElementType[]) {
      //   if (!Array.isArray(elements)) elements = [elements]
      //   if (elements.some((element: { type: string }) => element.type !== 'node')) {
      //     throw new Error('elements should be all node type')
      //   }
      //   const { scene, peer } = contact
      //   const messageType = scene === 'group' ? 'group_id' : 'user_id'
      //   const messages: any[] = []
      //   const selfUin = this.account.uin
      //   const selfNick = this.account.name
      //   for (const i of elements) {
      //     const type = 'node'
      //     if (i.id) {
      //       messages.push({ type, data: { id: i.id } })
      //     } else {
      //       const content = this.KarinConvertAdapter(i.content as KarinElement[])
      //       const userId = Number(i.user_id || selfUin)
      //       const nickname = String(i.nickname || selfNick)
      //       messages.push({ type, data: { user_id: userId, nickname, content } })
      //     }
      //   }
      //   const params = { [messageType]: Number(peer), messages }
      //   return await this.sendApi(Action.sendForwardMsg, params)
      // }
      /**
       * 发送长消息
       * @param contact 目标信息
       * @param resId 资源ID
       */
      async sendLongMsg(contact3, resId) {
        const result = await (async () => {
          if (contact3.scene === "group") {
            return await this._onebot.sendGroupMsg(
              Number(contact3.peer),
              [{ type: OneBotMessageType.Forward, data: { id: resId } }]
            );
          }
          const id = contact3.scene === "friend" ? Number(contact3.peer) : Number(contact3.subPeer);
          return await this._onebot.sendPrivateMsg(
            id,
            [{ type: OneBotMessageType.Forward, data: { id: resId } }]
          );
        })();
        const messageId = String(result.message_id);
        const messageTime = Date.now();
        return {
          messageId,
          messageTime,
          rawData: result,
          message_id: messageId,
          message_time: messageTime,
          time: messageTime
        };
      }
      /**
       * 撤回消息
       * @param contact ob11无需提供contact参数
       * @param messageId 消息ID
       */
      async recallMsg(_, messageId) {
        await this._onebot.deleteMsg(Number(messageId));
      }
      /**
       * 获取消息
       * @param contact 联系人信息
       * @param messageId 消息ID
       */
      async getMsg(_contact, messageId) {
        const targetId = typeof _contact === "string" ? _contact : messageId;
        const result = await this._onebot.getMsg(Number(targetId));
        const userId = result.sender.user_id + "";
        const messageSeq = result.message_seq || result.message_id;
        const messageID = result.message_id + "";
        const contact3 = (() => {
          if (result.message_type === "group") {
            return {
              scene: "group",
              peer: result.group_id + "",
              name: result.sender.nickname
            };
          }
          return {
            scene: "friend",
            peer: result.sender.user_id + "",
            name: result.sender.nickname
          };
        })();
        const sender2 = (() => {
          if (result.message_type === "group") {
            return {
              userId,
              uid: userId,
              uin: result.sender.user_id,
              nick: result.sender.nickname,
              name: result.sender.nickname,
              sex: result.sender.sex || "unknown",
              role: result.sender?.role || "unknown",
              card: result.sender?.card || "",
              title: result.sender?.title || "",
              level: Number(result.sender?.level) || 0,
              area: result.sender?.area || ""
            };
          }
          return {
            userId,
            uid: userId,
            sex: result.sender.sex || "unknown",
            role: "unknown",
            uin: result.sender.user_id,
            nick: result.sender.nickname,
            name: result.sender.nickname
          };
        })();
        return {
          time: result.time,
          messageId: messageID,
          message_id: messageID,
          message_seq: messageSeq,
          messageSeq,
          contact: contact3,
          sender: sender2,
          elements: await this.AdapterConvertKarin(result.message)
        };
      }
      /**
       * 获取msgId获取历史消息
       * @param contact 目标信息
       * @param startMsgId 起始消息ID
       * @param count 获取消息数量 默认为1
       * @returns 包含历史消息的数组
       */
      async getHistoryMsg(contact3, startMsgId, count3) {
        const result = await (async () => {
          const targetId = Number(contact3.peer);
          if (typeof startMsgId === "number") {
            if (this.adapter.name === "Lagrange.OneBot") {
              throw new Error("Lagrange.OneBot\u4E0D\u652F\u6301\u901A\u8FC7seq\u83B7\u53D6\u5386\u53F2\u6D88\u606F");
            }
            return this._onebot.getGroupMsgHistory(targetId, startMsgId, count3);
          }
          if (typeof startMsgId !== "string") {
            throw new Error("startMsgId\u7C7B\u578B\u9519\u8BEF");
          }
          if (this.adapter.name === "Lagrange.OneBot") {
            if (contact3.scene === "group") {
              return this._onebot.lgl_getGroupMsgHistory(targetId, Number(startMsgId), count3);
            } else if (contact3.scene === "friend") {
              return this._onebot.lgl_getFriendMsgHistory(targetId, Number(startMsgId), count3);
            } else {
              throw new Error(`\u4E0D\u652F\u6301\u7684\u6D88\u606F\u73AF\u5883:${contact3.scene}`);
            }
          }
          const seq2 = await this.getMsg(contact3, startMsgId);
          if (contact3.scene === "group") {
            return this._onebot.getGroupMsgHistory(targetId, seq2.message_seq, count3);
          } else if (contact3.scene === "friend") {
            return this._onebot.nc_getFriendMsgHistory(targetId, seq2.message_seq, count3);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6D88\u606F\u73AF\u5883:${contact3.scene}`);
          }
        })();
        return await Promise.all(result.messages.map(async (v) => {
          const userId = v.sender.user_id + "" || "";
          const messageId = String(v.message_id) || "";
          const messageSeq = v.message_seq || v.message_id;
          const data = {
            time: Date.now(),
            messageId,
            messageSeq,
            message_id: messageId,
            message_seq: messageSeq,
            contact: contact3,
            sender: senderGroup({
              userId,
              nick: v?.sender?.nickname || "",
              name: v?.sender?.nickname || "",
              sex: v?.sender?.sex || "unknown",
              age: v?.sender?.age || 0,
              // @ts-ignore
              role: v?.sender?.role || "unknown",
              // @ts-ignore
              card: v?.sender?.card || "",
              // @ts-ignore
              area: v?.sender?.area || "",
              // @ts-ignore
              level: Number(v?.sender?.level) || 0,
              // @ts-ignore
              title: v?.sender?.title || ""
            }),
            elements: await this.AdapterConvertKarin(v.message)
          };
          return data;
        }));
      }
      /**
       * 发送好友赞
       * @param targetId 目标ID
       * @param count 赞的次数
       * @returns 此接口的返回值不值得信任
       */
      async sendLike(targetId, count3) {
        await this._onebot.sendLike(Number(targetId), count3);
      }
      /**
       * 群踢人
       * @param groupId 群ID
       * @param targetId 被踢出目标的ID 任选其一
       * @param rejectAddRequest 是否拒绝再次申请，默认为false
       * @param kickReason 踢出原因，可选
       * @returns 此接口的返回值不值得信任
       */
      async groupKickMember(groupId, targetId, rejectAddRequest, _) {
        await this._onebot.setGroupKick(Number(groupId), Number(targetId), rejectAddRequest);
      }
      /**
       * 禁言群成员
       * @param groupId 群ID
       * @param targetId 被禁言目标的ID 任选其一
       * @param duration 禁言时长 单位:秒
       * @returns 此接口的返回值不值得信任
       */
      async setGroupMute(groupId, targetId, duration) {
        await this._onebot.setGroupBan(Number(groupId), Number(targetId), duration);
      }
      /**
       * 群全员禁言
       * @param groupId 群ID
       * @param isBan 是否开启全员禁言
       * @returns 此接口的返回值不值得信任
       */
      async setGroupAllMute(groupId, isBan) {
        await this._onebot.setGroupWholeBan(Number(groupId), isBan);
      }
      /**
       * 设置群管理员
       * @param groupId 群ID
       * @param targetId 目标用户的ID
       * @param isAdmin 是否设置为管理员
       * @returns 此接口的返回值不值得信任
       */
      async setGroupAdmin(groupId, targetId, isAdmin) {
        await this._onebot.setGroupAdmin(Number(groupId), Number(targetId), isAdmin);
      }
      /**
       * 设置群名片
       * @param groupId 群ID
       * @param targetId 目标用户的ID
       * @param card 新的群名片
       * @returns 此接口的返回值不值得信任
       */
      async setGroupMemberCard(groupId, targetId, card) {
        await this._onebot.setGroupCard(Number(groupId), Number(targetId), card);
      }
      /**
       * 设置群名
       * @param groupId 群ID
       * @param groupName 新的群名
       * @returns 此接口的返回值不值得信任
       */
      async setGroupName(groupId, groupName) {
        await this._onebot.setGroupName(Number(groupId), groupName);
      }
      /**
       * 退出群组
       * @param groupId 群ID
       * @param isDismiss 如果Bot是群主，是否解散群
       * @returns 此接口的返回值不值得信任
       */
      async setGroupQuit(groupId, isDismiss) {
        await this._onebot.setGroupLeave(Number(groupId), isDismiss);
      }
      /**
       * 设置群专属头衔 仅群主可用
       * @param groupId 群ID
       * @param targetId 目标用户的ID
       * @param title 新的专属头衔
       * @returns 此接口的返回值不值得信任
       */
      async setGroupMemberTitle(groupId, targetId, title) {
        await this._onebot.setGroupSpecialTitle(Number(groupId), Number(targetId), title);
      }
      /**
       * 获取陌生人信息
       * @param targetId 用户ID 任选其一
       * @returns 陌生人信息数组
       */
      async getStrangerInfo(targetId) {
        const result = await this._onebot.getStrangerInfo(Number(targetId[0]), true);
        return {
          ...result,
          userId: targetId,
          user_id: targetId,
          /** 用户UID */
          uid: result.uid || "",
          /** 用户UIN */
          uin: targetId,
          /** qid */
          qid: result.qid || "",
          /** 名称 */
          nick: result.nickname,
          /** 备注 */
          remark: "",
          /** 用户等级 */
          level: 0,
          /** 生日 */
          birthday: "",
          /** 登录天数 */
          login_day: result.login_days || 0,
          /** 点赞数 */
          vote_cnt: 0,
          /** 学校是否已核实 */
          is_school_verified: void 0,
          /**
          * 年龄
          * 拓展字段
          */
          age: result.age,
          /**
          * 性别
          * 拓展字段
          */
          sex: result.sex || "unknown",
          /** 大会员 */
          big_vip: void 0,
          /** 好莱坞/腾讯视频会员 */
          hollywood_vip: void 0,
          /** QQ会员 */
          qq_vip: result.is_vip,
          /** QQ超级会员 */
          super_vip: void 0,
          /** 是否已经赞过 */
          voted: void 0
        };
      }
      /**
       * 获取好友列表
       * @param refresh 是否刷新好友列表
       * @returns 好友列表数组
       */
      async getFriendList(_) {
        const friendList = await this._onebot.getFriendList();
        return friendList.map((v) => {
          const userId = v.user_id + "";
          return {
            ...v,
            userId,
            user_id: userId,
            /** 用户UID */
            uid: "",
            /** 用户UIN */
            uin: userId,
            /** qid */
            qid: v.qid || "",
            /** 昵称 */
            nick: v.nickname,
            /** 昵称 */
            name: v.nickname,
            /** 用户等级 */
            level: 0,
            /** 生日 */
            birthday: "",
            /** 登录天数 */
            login_day: v.login_days || 0,
            /** 点赞数 */
            vote_cnt: 0,
            /** 学校是否已核实 */
            is_school_verified: void 0,
            /**
             * 年龄
             * 拓展字段
             */
            age: v.age,
            /**
             * 性别
             * 拓展字段
             */
            sex: v.sex || "unknown",
            /** 大会员 */
            big_vip: void 0,
            /** 好莱坞/腾讯视频会员 */
            hollywood_vip: void 0,
            /** QQ会员 */
            qq_vip: v.is_vip,
            /** QQ超级会员 */
            super_vip: void 0,
            /** 是否已经赞过 */
            voted: void 0
          };
        });
      }
      /** 获取好友列表 */
      async GetFriendList() {
        return this.getFriendList();
      }
      /**
       * 获取群信息
       * @param groupId 群ID
       * @param noCache 是否刷新缓存
       * @returns 群信息
       */
      async getGroupInfo(groupId, noCache) {
        const info = await this._onebot.getGroupInfo(Number(groupId), noCache);
        const groupName = info.group_name;
        return {
          groupId,
          groupName,
          groupRemark: groupName,
          maxMemberCount: info.max_member_count,
          memberCount: info.member_count,
          groupDesc: "",
          group_name: groupName,
          group_remark: groupName,
          max_member_count: info.max_member_count,
          member_count: info.member_count,
          group_uin: groupId,
          admins: (info.admin_list || []).map((v) => ({
            userId: v.user_id + "",
            name: v.nickname,
            role: v.role
          })),
          owner: info.owner_id + ""
        };
      }
      /**
       * 获取群列表
       * @param refresh 是否刷新好友列表
       * @returns 群列表数组
       */
      async getGroupList(_refresh) {
        const groupList = await this._onebot.getGroupList();
        return groupList.map((info) => {
          const groupId = info.group_id + "";
          const groupName = info.group_name;
          return {
            groupId,
            groupName,
            groupRemark: groupName,
            maxMemberCount: info.max_member_count,
            memberCount: info.member_count,
            groupDesc: "",
            group_name: groupName,
            group_remark: groupName,
            max_member_count: info.max_member_count,
            member_count: info.member_count,
            group_uin: groupId,
            admins: [],
            owner: ""
          };
        });
      }
      /**
       * 获取群成员信息
       * 此接口在非QQ平台上很难获取到标准信息，因此返回的数据可能会有所不同
       * @param groupId 群ID
       * @param targetId 目标用户的ID
       * @param refresh 是否刷新缓存
       * @returns 群成员信息
       */
      async getGroupMemberInfo(groupId, targetId, refresh) {
        const userId = Number(targetId);
        const info = await this._onebot.getGroupMemberInfo(Number(groupId), userId, refresh);
        return {
          ...info,
          userId: targetId,
          uid: targetId,
          uin: targetId,
          nick: info.nickname,
          role: info.role,
          age: info.age,
          uniqueTitle: info.title,
          card: info.card,
          joinTime: info.join_time,
          lastActiveTime: info.last_sent_time,
          level: Number(info.level) || 0,
          shutUpTime: 0,
          distance: void 0,
          honors: [],
          unfriendly: info.unfriendly,
          sex: info.sex,
          get sender() {
            return senderGroup({
              userId: targetId,
              nick: info.nickname,
              name: info.nickname,
              role: info.role,
              sex: info.sex,
              age: info.age,
              card: info.card,
              area: info.area,
              level: Number(info.level) || 0,
              title: info.title
            });
          }
        };
      }
      /**
       * 获取群成员列表
       * @param groupId 群ID
       * @param refresh 是否刷新缓存
       * @returns 群成员列表数组
       */
      async getGroupMemberList(groupId, refresh) {
        const list2 = await this._onebot.getGroupMemberList(Number(groupId), refresh);
        return list2.map((v) => {
          const targetId = v.user_id + "";
          return {
            ...v,
            userId: targetId,
            uid: targetId,
            uin: targetId,
            nick: v.nickname,
            role: v.role,
            age: v.age,
            uniqueTitle: v.title,
            card: v.card,
            joinTime: v.join_time,
            lastActiveTime: v.last_sent_time,
            level: Number(v.level) || 0,
            shutUpTime: 0,
            distance: void 0,
            honors: [],
            unfriendly: v.unfriendly,
            sex: v.sex,
            get sender() {
              return senderGroup({
                userId: targetId,
                nick: v.nickname,
                name: v.nickname,
                role: v.role,
                sex: v.sex,
                age: v.age,
                card: v.card,
                area: v.area,
                level: Number(v.level),
                title: v.title
              });
            }
          };
        });
      }
      /**
       * 获取群荣誉信息
       * @param groupId 群ID
       * @param refresh 是否刷新缓存
       * @returns 群荣誉信息数组
       */
      async getGroupHonor(groupId) {
        const groupHonor = await this._onebot.getGroupHonorInfo(Number(groupId), "all");
        const result = [];
        groupHonor.talkative_list && groupHonor.talkative_list.forEach((honor) => {
          const userId = honor.user_id + "";
          result.push({
            userId,
            nick: honor.nickname,
            honorName: "\u5386\u53F2\u9F99\u738B",
            id: 0,
            avatar: honor.avatar,
            description: honor.description
          });
        });
        groupHonor.performer_list && groupHonor.performer_list.forEach((honor) => {
          const userId = honor.user_id + "";
          result.push({
            userId,
            nick: honor.nickname,
            honorName: "\u7FA4\u804A\u4E4B\u706B",
            avatar: honor.avatar,
            id: 0,
            description: honor.description
          });
        });
        groupHonor.legend_list && groupHonor.legend_list.forEach((honor) => {
          const userId = honor.user_id + "";
          result.push({
            userId,
            nick: honor.nickname,
            honorName: "\u7FA4\u804A\u70BD\u7130",
            avatar: honor.avatar,
            id: 0,
            description: honor.description
          });
        });
        groupHonor.strong_newbie_list && groupHonor.strong_newbie_list.forEach((honor) => {
          const userId = honor.user_id + "";
          result.push({
            userId,
            nick: honor.nickname,
            honorName: "\u5192\u5C16\u5C0F\u6625\u7B0B",
            avatar: honor.avatar,
            id: 0,
            description: honor.description
          });
        });
        groupHonor.emotion_list && groupHonor.emotion_list.forEach((honor) => {
          const userId = honor.user_id + "";
          result.push({
            userId,
            nick: honor.nickname,
            honorName: "\u5FEB\u4E50\u4E4B\u6E90",
            avatar: honor.avatar,
            id: 0,
            description: honor.description
          });
        });
        return result;
      }
      /**
       * 设置消息表情回应
       * @param contact 目标信息
       * @param messageId 消息ID
       * @param faceId 表情ID
       * @returns 此接口的返回值不值得信任
       */
      async setMsgReaction(contact3, messageId, faceId, isSet) {
        if (this.adapter.name === "Lagrange.OneBot") {
          await this._onebot.lgl_setGroupReaction(+contact3.peer, +messageId, faceId + "", isSet);
          return;
        }
        if (this.adapter.name === "NapCat.Onebot") {
          await this._onebot.nc_setMsgEmojiLike(+messageId, faceId + "", isSet);
          return;
        }
        throw new Error(`${this.adapter.name} \u4E0D\u652F\u6301\u8BBE\u7F6E\u6D88\u606F\u8868\u60C5\u56DE\u5E94`);
      }
      /**
       * 获取版本信息
       */
      async getVersion() {
        const res = await this._onebot.getVersionInfo();
        return {
          name: res.app_name,
          app_name: res.app_name,
          version: res.app_version,
          protocol: res.protocol_version
        };
      }
      async DownloadForwardMessage(_) {
        throw new Error("Method not implemented.");
      }
      /**
       * 获取精华消息
       * @param groupId 群ID
       * @param page 页码
       * @param pageSize 每页数量
       * @returns EssenceMessageBody对象
       */
      async getGroupHighlights(groupId, _, __) {
        const list2 = [];
        const res = await this._onebot.getEssenceMsgList(Number(groupId));
        for (const v of res) {
          const { message_seq: messageSeq, elements } = await this.getMsg({
            scene: "group",
            peer: groupId,
            name: ""
          }, v.message_id + "");
          const senderId = v.sender_id + "";
          const operatorId = v.operator_id + "";
          list2.push({
            /** 群ID */
            groupId,
            /** 发送者Id */
            senderId,
            /** 操作者Id */
            operatorId,
            senderName: v.sender_nick,
            operatorName: v.operator_nick,
            operationTime: v.operator_time,
            messageTime: v.sender_time,
            messageSeq,
            messageId: v.message_id + "",
            jsonElements: JSON.stringify(elements),
            group_id: groupId,
            /** 发送者uid */
            sender_uid: senderId,
            /** 发送者uin */
            sender_uin: senderId,
            /** 发送者昵称 */
            sender_nick: v.sender_nick,
            /** 操作者uid */
            operator_uid: operatorId,
            /** 操作者uin */
            operator_uin: operatorId,
            /** 操作者昵称 */
            operator_nick: v.operator_nick,
            /** 操作时间 */
            operation_time: v.operator_time,
            /** 消息时间 */
            message_time: v.sender_time,
            /** 消息ID */
            message_id: v.message_id + "",
            /** 消息序列号 */
            message_seq: messageSeq,
            /** 被设置的精华消息元素文本 */
            json_elements: JSON.stringify(elements)
          });
        }
        return list2;
      }
      /**
       * 上传群文件、私聊文件
       * @param contact 目标信息
       * @param file 本地文件绝对路径
       * @param name 文件名称 必须提供
       * @param folder 父目录ID 不提供则上传到根目录 仅在群聊时有效
       * @returns 此接口的返回值不值得信任
       */
      async uploadFile(contact3, file2, name, folder) {
        if (contact3.scene === "group") {
          await this._onebot.uploadGroupFile(+contact3.peer, file2, name, folder);
          return;
        }
        await this._onebot.uploadPrivateFile(+contact3.peer, file2, name);
      }
      /**
       * 设置、取消群精华消息
       * @param groupId 群ID
       * @param messageId 群消息ID
       * @param create true为添加精华消息，false为删除精华消息 默认为true
       */
      async setGgroupHighlights(_, messageId, create2) {
        if (create2) {
          await this._onebot.setEssenceMsg(+messageId);
        } else {
          await this._onebot.deleteEssenceMsg(+messageId);
        }
      }
      async PokeMember(_, __) {
        throw new Error("Method not implemented.");
      }
      /**
       * 设置好友请求结果
       * @param requestId 请求事件ID
       * @param isApprove 是否同意
       * @param remark 好友备注 同意时有效
       * @returns 设置结果
       */
      async setFriendApplyResult(requestId, isApprove, remark) {
        await this._onebot.setFriendAddRequest(requestId, isApprove, remark);
      }
      /**
       * 设置申请加入群请求结果
       * @param requestId 请求事件ID
       * @param isApprove 是否同意
       * @param denyReason 拒绝理由 拒绝时有效
       * @returns 此接口的返回值不值得信任
       */
      async setGroupApplyResult(requestId, isApprove, denyReason) {
        await this._onebot.setGroupAddRequest(requestId, "add", isApprove, denyReason);
      }
      /**
       * 设置邀请加入群请求结果
       * @param requestId 请求事件ID
       * @param isApprove 是否同意
       * @returns 此接口的返回值不值得信任
       */
      async setInvitedJoinGroupResult(requestId, isApprove) {
        await this._onebot.setGroupAddRequest(requestId, "invite", isApprove);
      }
      /**
       * 合并转发 karin -> adapter
       * @param elements 消息元素
       * @param options 首层小卡片外显参数
       * @returns 适配器消息元素
       */
      forwardKarinConvertAdapter(elements, options) {
        const messages = [];
        for (const elem of elements) {
          if (elem.subType === "messageID") {
            messages.push({ type: OneBotMessageType.Node, data: { id: elem.messageId } });
          } else {
            const node2 = {
              type: OneBotMessageType.Node,
              data: {
                user_id: elem.userId,
                nickname: elem.nickname,
                content: this.KarinConvertAdapter(elem.message)
              }
            };
            if (typeof elem.options === "object") {
              if (elem.options.prompt) node2.data.prompt = elem.options.prompt;
              if (elem.options.summary) node2.data.summary = elem.options.summary;
              if (elem.options.source) node2.data.source = elem.options.source;
            }
            if (options && messages.length === 0) {
              node2.data.prompt = options.prompt;
              node2.data.summary = options.summary;
              node2.data.source = options.source;
            }
            messages.push(node2);
          }
        }
        return messages;
      }
      /**
       * 发送合并转发消息
       * @param contact 目标信息
       * @param elements 消息元素
       * @param options 首层小卡片外显参数
       */
      async sendForwardMsg(contact3, elements, options) {
        const result = await (() => {
          if (contact3.scene === "group") {
            return this._onebot.sendGroupForwardMsg(
              Number(contact3.peer),
              this.forwardKarinConvertAdapter(elements, options)
            );
          }
          if (contact3.scene === "friend") {
            return this._onebot.sendPrivateForwardMsg(
              Number(contact3.peer),
              this.forwardKarinConvertAdapter(elements, options)
            );
          }
          throw TypeError(`\u4E0D\u652F\u6301\u7684\u573A\u666F\u7C7B\u578B: ${contact3.scene}`);
        })();
        return {
          ...result,
          messageId: String(result.message_id),
          forwardId: String(result.res_id || result.forward_id)
        };
      }
      /**
       * 获取文件url
       * @description napcat支持仅提供fid获取url`(但是你要伪造一个假的contact...)`
       * @param contact 目标信息
       * @param fid 文件id
       * @returns 文件url
       */
      async getFileUrl(contact3, fid) {
        if (this.adapter.name === "NapCat.Onebot") {
          const { url } = await this._onebot.nc_getFile(fid);
          return url;
        }
        if (contact3.scene === "group") {
          const { url } = await this._onebot.getGroupFileUrl(+contact3.peer, fid);
          return url;
        }
        if (contact3.scene === "friend") {
          const { url } = await this._onebot.getPrivateFileUrl(+contact3.peer, fid);
          return url;
        }
        throw TypeError(`\u4E0D\u652F\u6301\u7684\u573A\u666F\u7C7B\u578B: ${contact3.scene}`);
      }
      /**
       * 获取群文件系统信息
       * @param groupId 群ID
       * @returns 群文件系统信息
       */
      async getGroupFileSystemInfo(groupId) {
        const result = await this._onebot.getGroupFileSystemInfo(+groupId);
        return {
          ...result,
          fileCount: result.file_count,
          limitCount: result.limit_count,
          usedSpace: result.used_space,
          totalSpace: result.total_space
        };
      }
      /**
       * 获取群文件列表
       * @param groupId 群ID
       * @param folderId 文件夹ID
       * @returns 群文件列表
       */
      async getGroupFileList(groupId, folderId) {
        const result = typeof folderId !== "string" ? await this._onebot.getGroupRootFiles(+groupId) : await this._onebot.getGroupFilesByFolder(+groupId, folderId);
        return {
          files: result.files.map((v) => ({
            fid: v.file_id,
            name: v.file_name,
            size: v.file_size,
            uploadTime: v.upload_time,
            expireTime: v.dead_time,
            modifyTime: v.modify_time,
            downloadCount: v.download_times,
            uploadId: v.uploader + "",
            uploadName: v.uploader_name,
            sha1: "",
            sha3: "",
            md5: ""
          })),
          folders: result.folders.map((v) => ({
            id: v.folder_id,
            name: v.folder_name,
            fileCount: v.total_file_count,
            createTime: v.create_time,
            creatorId: v.creator + "",
            creatorName: v.creator_name
          }))
        };
      }
      /**
       * 获取 Cookies
       * @param domain The domain to get cookies from
       */
      async getCookies(domain) {
        const result = await this._onebot.getCookies(domain);
        return { ...result, cookie: result.cookies };
      }
      /**
       * 获取 QQ 相关接口凭证
       * @param domain The domain to get credentials from
       */
      async getCredentials(domain) {
        const result = await this._onebot.getCredentials(domain);
        return { ...result, cookies: result.cookies };
      }
      /**
       * 获取 CSRF Token
       */
      async getCSRFToken() {
        const result = await this._onebot.getCsrfToken();
        return { ...result, token: result.token };
      }
      /**
       * 设置头像
       * @param file base64:// file:// http(s)://
       * @returns 是否设置成功
       */
      async setAvatar(file2) {
        await this._onebot.setQqAvatar(file2);
      }
      /**
       * 获取群 Ai 语音可用声色列表
       * @returns 声色列表
       */
      async getAiCharacters() {
        const result = await this._onebot.getAiCharacters();
        return result;
      }
      /**
       * 设置群 Ai 语音声色
       * @param groupId 群号
       * @param character 声色ID
       * @param text 转换的文本
       */
      async sendAiCharacter(groupId, character, text2) {
        const result = await this._onebot.sendGroupAiRecord(+groupId, character, text2);
        return { messageId: result.message_id + "" };
      }
      /**
       * 获取 rkey
       * @returns rkey
       */
      async getRkey() {
        const result = await this._onebot.getRkey();
        return result.rkeys;
      }
    };
  }
});

// src/adapter/onebot/create/create.ts
var loggerPrefix, createOneBotWsServer, createOneBotClient, createOneBotHttp, disconnectAllOneBotServer;
var init_create2 = __esm({
  "src/adapter/onebot/create/create.ts"() {
    init_core();
    init_config();
    init_dist2();
    init_cache2();
    loggerPrefix = "[OneBot]";
    createOneBotWsServer = async (socket, request3) => {
      if (!adapter().onebot.ws_server.enable) {
        logger.warn(`${loggerPrefix} \u672A\u542F\u7528WebSocketServer\u670D\u52A1`);
        return;
      }
      const onebot = oneBotWsServerManager.createServer(socket, request3, {
        accessToken: process.env.WS_SERVER_AUTH_KEY,
        timeout: adapter().onebot.ws_server.timeout
      });
      const adapter3 = new AdapterOneBot(onebot);
      const url = `ws://${request3.headers.host}${request3.url}`;
      adapter3.adapter.address = url;
      adapter3.adapter.communication = "webSocketServer";
      adapter3.account.selfId = String(request3.headers["x-self-id"]);
      onebot.on(OneBotEventKey.OPEN, async () => {
        logger.debug(`[OneBot] \u670D\u52A1\u7AEF\u8FDE\u63A5\u6210\u529F: ${url}`);
        adapter3.registerBot();
      });
      onebot.on(OneBotEventKey.CLOSE, async (type) => {
        adapter3.unregisterBot();
        if (type === OneBotCloseType.MANUAL_CLOSE) {
          logger.info(`${loggerPrefix} \u4E3B\u52A8\u5173\u95ED: ${url}`);
        }
        return logger.error(`${loggerPrefix} \u8FDE\u63A5\u65AD\u5F00: ${url}`);
      });
      onebot.on(OneBotEventKey.ERROR, async (args) => {
        if (args.type === OneBotErrorType.AUTH_FAILED) {
          return logger.error(`${loggerPrefix} \u9274\u6743\u5931\u8D25: ${args.error.message}`);
        }
        if (args.type === OneBotErrorType.AUTH_INVALID_FORMAT) {
          return logger.error(`${loggerPrefix} \u9274\u6743\u5934\u683C\u5F0F\u9519\u8BEF: ${args.error.message}`);
        }
        return logger.error(new Error(`${loggerPrefix} \u53D1\u751F\u9519\u8BEF:`, { cause: args.error }));
      });
      await adapter3.init();
      cacheMap.wsServer.set(url, adapter3);
    };
    createOneBotClient = async (url, token) => {
      const onebot = await oneBotWsClientManager.createClient(url, {
        timeout: adapter().onebot.ws_server.timeout,
        accessToken: token,
        autoReconnect: true
      });
      const adapter3 = new AdapterOneBot(onebot);
      adapter3.adapter.address = url;
      adapter3.adapter.communication = "webSocketClient";
      onebot.on(OneBotEventKey.OPEN, async () => {
        logger.info(`[OneBot] \u5BA2\u6237\u7AEF\u8FDE\u63A5\u6210\u529F: ${url}`);
        await adapter3.init();
        adapter3.registerBot();
      });
      onebot.on(OneBotEventKey.CLOSE, async (type) => {
        adapter3.unregisterBot();
        if (type === OneBotCloseType.CONNECTION_FAILED) {
          return logger.error(`${loggerPrefix} \u8FDE\u63A5\u5F02\u5E38\u65AD\u5F00 \u5373\u5C06\u91CD\u8FDE: ${url}`);
        }
        if (type === OneBotCloseType.ERROR) {
          return logger.error(`${loggerPrefix} \u5BA2\u6237\u7AEF\u8FDE\u63A5\u5173\u95ED: ${url}`);
        }
        if (type === OneBotCloseType.MANUAL_CLOSE) {
          return logger.info(`${loggerPrefix} \u4E3B\u52A8\u5173\u95ED: ${url}`);
        }
        if (type === OneBotCloseType.MAX_RETRIES) {
          return logger.error(`${loggerPrefix} \u91CD\u8FDE\u6B21\u6570\u8FC7\u591A: ${url}`);
        }
        if (type === OneBotCloseType.SERVER_CLOSE) {
          return logger.error(`${loggerPrefix} \u670D\u52A1\u7AEF\u5F02\u5E38\u5173\u95ED: ${url}`);
        }
        logger.info(`${loggerPrefix} \u5BA2\u6237\u7AEF\u8FDE\u63A5\u5173\u95ED: ${url}`);
      });
      onebot.on(OneBotEventKey.ERROR, async (args) => {
        if (args.type === OneBotErrorType.CONNECTION_FAILED) {
          return logger.error(`${loggerPrefix} \u8FDE\u63A5\u5EFA\u7ACB\u5931\u8D25\uFF0C${args.reconnectInterval / 1e3}\u79D2\u540E\u91CD\u8BD5(${args.reconnectAttempt}/${args.maxReconnectAttempt}): ${args.error.message}`);
        }
        if (args.type === OneBotErrorType.RECONNECT_FAILED) {
          return logger.error(`${loggerPrefix} \u91CD\u8FDE\u8FBE\u5230\u4E0A\u9650: ${args.totalReconnectAttempt}\u6B21`);
        }
        return logger.error(new Error(`${loggerPrefix} \u53D1\u751F\u9519\u8BEF:`, { cause: args.error }));
      });
      cacheMap.wsClient.set(url, adapter3);
    };
    createOneBotHttp = async (options) => {
      if (!options.enable) {
        logger.debug(`${loggerPrefix} \u672A\u542F\u7528Http\u9002\u914D\u5668: ${options.url}`);
        return;
      }
      const onebot = oneBotHttpManager.createClient({
        httpHost: options.url,
        self_id: +options.self_id,
        timeout: adapter().onebot.ws_server.timeout * 1e3,
        accessToken: options.post_token,
        OneBotAccessToken: options.token || options.api_token
      });
      const adapter3 = new AdapterOneBot(onebot);
      adapter3.adapter.address = options.url;
      adapter3.account.selfId = options.self_id;
      adapter3.adapter.communication = "http";
      onebot.on(OneBotEventKey.OPEN, async () => {
        adapter3.registerBot();
      });
      onebot.on(OneBotEventKey.CLOSE, async (type) => {
        adapter3.unregisterBot();
        if (type === OneBotCloseType.MANUAL_CLOSE) {
          return logger.info(`${loggerPrefix} \u4E3B\u52A8\u5173\u95ED: ${options.url}`);
        }
        if (type === OneBotCloseType.HEARTBEAT_FAILED_MAX_RETRIES) {
          return logger.error(`${loggerPrefix} \u5FC3\u8DF3\u5931\u8D25\u6B21\u6570\u8FBE\u5230\u4E0A\u9650: ${options.url}`);
        }
        if (type === OneBotCloseType.HEARTBEAT_FAILED) {
          return logger.error(`${loggerPrefix} \u9996\u6B21\u5FC3\u8DF3\u5931\u8D25: ${options.url}`);
        }
        return logger.error(`${loggerPrefix} \u5FC3\u8DF3\u5931\u8D25: ${options.url}`);
      });
      onebot.on(OneBotEventKey.ERROR, (args) => {
        if (args.type === OneBotErrorType.CONNECTION_FAILED) {
          return logger.error(`${loggerPrefix} \u5FC3\u8DF3\u5931\u8D25\uFF0C${args.reconnectInterval / 1e3}\u79D2\u540E\u91CD\u8BD5(${args.reconnectAttempt}/${args.maxReconnectAttempt}): ${args.error.message}`);
        }
        if (args.type === OneBotErrorType.RECONNECT_FAILED) {
          return logger.error(`${loggerPrefix} \u91CD\u8FDE\u8FBE\u5230\u4E0A\u9650: ${args.totalReconnectAttempt}\u6B21`);
        }
        return logger.error(new Error(`${loggerPrefix} \u53D1\u751F\u9519\u8BEF:`, { cause: args.error }));
      });
      cacheMap.http.set(options.self_id, adapter3);
      await adapter3.init();
      return adapter3;
    };
    disconnectAllOneBotServer = () => {
      cacheMap.wsServer.forEach((adapter3) => adapter3._onebot.close());
    };
  }
});

// src/utils/config/file/adapter.ts
var cache6, format, initAdapter, hmrOneBot, adapter, timeout, webSocketServerToken, adapter_default;
var init_adapter = __esm({
  "src/utils/config/file/adapter.ts"() {
    init_watch();
    init_fs2();
    init_number();
    init_require();
    init_listeners();
    init_cache2();
    init_create2();
    format = (data) => {
      return {
        console: {
          ...data.console,
          token: String(data.console.token)
        },
        onebot: {
          ws_server: {
            ...data.onebot.ws_server,
            timeout: Number(data.onebot.ws_server.timeout) || 120
          },
          ws_client: data.onebot.ws_client.map((v) => ({
            ...v,
            token: String(v.token)
          })),
          http_server: data.onebot.http_server.map((v) => ({
            ...v,
            self_id: String(v.self_id),
            api_token: String(v?.api_token) || String(v.token),
            post_token: String(v.post_token)
          }))
        }
      };
    };
    initAdapter = (dir) => {
      const name = "adapter.json";
      const file2 = `${dir}/${name}`;
      const data = requireFileSync(file2, { type: "json" });
      cache6 = format(data);
      watch(file2, (old, data2) => {
        cache6 = format(data2);
        const options = { file: name, old, data: cache6 };
        listeners.emit(FILE_CHANGE, options);
        listeners.emit(`${FILE_CHANGE}:${name}`, options);
        hmrOneBot(old, data2);
      }, { type: "json" });
    };
    hmrOneBot = (old, data) => {
      const client = diffArray(
        Array.isArray(old?.onebot?.ws_client) ? old?.onebot?.ws_client : [],
        Array.isArray(data?.onebot?.ws_client) ? data?.onebot?.ws_client : []
      );
      client.removed.forEach((v) => {
        const bot = cacheMap.wsClient.get(v.url);
        if (!bot) return;
        bot._onebot.close();
        cacheMap.wsClient.delete(v.url);
      });
      client.added.forEach((v) => v.enable && createOneBotClient(v.url, v.token));
      const http = diffArray(
        Array.isArray(old?.onebot?.http_server) ? old?.onebot?.http_server : [],
        Array.isArray(data?.onebot?.http_server) ? data?.onebot?.http_server : []
      );
      http.removed.forEach((v) => {
        const bot = cacheMap.http.get(v.url);
        if (!bot) return;
        bot._onebot.close();
        cacheMap.http.delete(v.url);
      });
      http.added.forEach((v) => v.enable && createOneBotHttp(v));
    };
    adapter = () => cache6;
    timeout = () => adapter().onebot.ws_server.timeout;
    webSocketServerToken = () => process.env.WS_SERVER_AUTH_KEY;
    adapter_default = initAdapter;
  }
});

// src/utils/config/file/config.ts
var cache7, initConfig, config2, master, admin, config_default;
var init_config2 = __esm({
  "src/utils/config/file/config.ts"() {
    init_tools();
    init_watch();
    init_require();
    init_fs2();
    init_listeners();
    initConfig = (dir) => {
      const name = "config.json";
      const file2 = `${dir}/${name}`;
      const data = requireFileSync(file2, { type: "json" });
      cache7 = formatObject(data);
      watch(file2, (old, data2) => {
        cache7 = formatObject(data2);
        const options = { file: name, old, data: cache7 };
        listeners.emit(FILE_CHANGE, options);
        listeners.emit(`${FILE_CHANGE}:${name}`, options);
      }, { type: "json" });
    };
    config2 = () => cache7;
    master = () => config2().master;
    admin = () => config2().admin;
    config_default = initConfig;
  }
});
var count, staticCache, dynamicCache, getCfg, isOld, migrate, format2, initGroups, groups, getGroupCfg, getGuildCfg, getGroupsFileData, groups_default;
var init_groups4 = __esm({
  "src/utils/config/file/groups.ts"() {
    init_watch();
    init_require();
    init_fs2();
    init_listeners();
    init_default();
    init_common();
    init_tools();
    count = createCount();
    getCfg = (keys) => getCacheCfg(dynamicCache, count, keys);
    isOld = (obj) => {
      if (Array.isArray(obj)) return false;
      return Object.keys(obj).every((key) => typeof obj[key] === "object");
    };
    migrate = (file2, data) => {
      const list2 = [];
      Object.entries(data).forEach(([key, value]) => {
        list2.push({ key, ...value });
      });
      fs5.writeFileSync(file2, JSON.stringify(list2, null, 2));
      logger.mark("[migrate] \u8FC1\u79FB groups.json \u914D\u7F6E\u6587\u4EF6\u6210\u529F");
      return format2(list2);
    };
    format2 = (data) => {
      const defaultGlobal = defaultConfig.groups[1];
      const defaultGroup = defaultConfig.groups[0];
      const userGlobal = data.find((item) => item.key === "global") || defaultGlobal;
      const userGroup = data.find((item) => item.key === "default") || defaultGroup;
      const merge = (key, inherit, ...args) => {
        if (typeof inherit !== "boolean") {
          inherit = true;
        }
        let alias = args.map((item) => item.alias);
        let enable = args.map((item) => item.enable);
        let disable = args.map((item) => item.disable);
        let memberEnable = args.map((item) => item.member_enable);
        let memberDisable = args.map((item) => item.member_disable);
        if (inherit && args.length === 3) {
          alias = [strToBool.mergeArray(alias[0], alias[1]), alias[2]];
          enable = [strToBool.mergeArray(enable[0], enable[1]), enable[2]];
          disable = [strToBool.mergeArray(disable[0], disable[1]), disable[2]];
          memberEnable = [strToBool.mergeArray(memberEnable[0], memberEnable[1]), memberEnable[2]];
          memberDisable = [strToBool.mergeArray(memberDisable[0], memberDisable[1]), memberDisable[2]];
        }
        return {
          key,
          inherit,
          cd: isNumberInArray(args.map((item) => item.cd), 0),
          userCD: isNumberInArray(args.map((item) => item.userCD), 0),
          mode: isNumberInArray(args.map((item) => item.mode), 0),
          alias: strToBool.arrayString(alias),
          enable: strToBool.arrayString(enable),
          disable: strToBool.arrayString(disable),
          member_enable: strToBool.arrayString(memberEnable),
          member_disable: strToBool.arrayString(memberDisable)
        };
      };
      const global2 = merge("global", true, userGlobal, defaultGlobal);
      const def = merge("default", true, userGroup, defaultGroup);
      const kv = {
        global: global2,
        default: def
      };
      data.forEach((item) => {
        kv[item.key] = merge(item.key, item.inherit, item, kv.global, kv.default);
      });
      return kv;
    };
    initGroups = async (dir) => {
      const name = "groups.json";
      const file2 = `${dir}/${name}`;
      const data = requireFileSync(file2, { type: "json" });
      staticCache = isOld(data) ? migrate(file2, data) : format2(data);
      dynamicCache = format2(data);
      watch(file2, async (old, data2) => {
        staticCache = isOld(data2) ? migrate(file2, data2) : format2(data2);
        dynamicCache = staticCache;
        const options = { file: name, old, data: dynamicCache };
        listeners.emit(FILE_CHANGE, options);
        listeners.emit(`${FILE_CHANGE}:${name}`, options);
      }, { type: "json" });
      clearCache(count, staticCache, dynamicCache);
    };
    groups = () => {
      return {
        get: () => dynamicCache
      };
    };
    getGroupCfg = (groupId, selfId) => {
      const keys = [
        `Bot:${selfId}:${groupId}`,
        `Bot:${selfId}`,
        groupId,
        "global",
        "default"
      ];
      return getCfg(keys);
    };
    getGuildCfg = (guildId, channelId, selfId) => {
      const keys = [
        `Bot:${selfId}:${guildId}:${channelId}`,
        `Bot:${selfId}:${guildId}`,
        `Bot:${selfId}`,
        guildId,
        channelId,
        "global",
        "default"
      ];
      return getCfg(keys);
    };
    getGroupsFileData = (dir) => {
      const name = "groups.json";
      const file2 = `${dir}/${name}`;
      const data = requireFileSync(file2, { type: "json" });
      return isOld(data) ? migrate(file2, data) : format2(data);
    };
    groups_default = initGroups;
  }
});
var count2, staticCache2, dynamicCache2, getCfg2, isOld2, migrate2, format3, initPrivates, privates, getFriendCfg, getDirectCfg, getPrivatesFileData, privates_default;
var init_privates = __esm({
  "src/utils/config/file/privates.ts"() {
    init_watch();
    init_require();
    init_fs2();
    init_listeners();
    init_default();
    init_common();
    init_tools();
    count2 = createCount();
    getCfg2 = (keys) => getCacheCfg(dynamicCache2, count2, keys);
    isOld2 = (obj) => {
      if (Array.isArray(obj)) return false;
      return Object.keys(obj).every((key) => typeof obj[key] === "object");
    };
    migrate2 = (file2, data) => {
      const list2 = [];
      Object.entries(data).forEach(([key, value]) => {
        list2.push({ key, ...value });
      });
      fs5.writeFileSync(file2, JSON.stringify(list2, null, 2));
      logger.mark("[migrate] \u8FC1\u79FB privates.json \u914D\u7F6E\u6587\u4EF6\u6210\u529F");
      return format3(list2);
    };
    format3 = (data) => {
      const defaultGlobal = defaultConfig.privates[1];
      const defaultPrivates = defaultConfig.privates[0];
      const userGlobal = data.find((item) => item.key === "global") || defaultGlobal;
      const userPrivates = data.find((item) => item.key === "default") || defaultPrivates;
      const merge = (key, inherit, ...args) => {
        if (typeof inherit !== "boolean") {
          inherit = true;
        }
        let alias = args.map((item) => item.alias);
        let enable = args.map((item) => item.enable);
        let disable = args.map((item) => item.disable);
        if (inherit && args.length === 3) {
          alias = [strToBool.mergeArray(alias[0], alias[1]), alias[2]];
          enable = [strToBool.mergeArray(enable[0], enable[1]), enable[2]];
          disable = [strToBool.mergeArray(disable[0], disable[1]), disable[2]];
        }
        return {
          key,
          inherit,
          cd: isNumberInArray(args.map((item) => item.cd), 0),
          mode: isNumberInArray(args.map((item) => item.mode), 0),
          alias: strToBool.arrayString(alias),
          enable: strToBool.arrayString(enable),
          disable: strToBool.arrayString(disable)
        };
      };
      const global2 = merge("global", true, userGlobal, defaultGlobal);
      const def = merge("default", true, userPrivates, defaultPrivates);
      const kv = {
        global: global2,
        default: def
      };
      data.forEach((value) => {
        kv[value.key] = merge(value.key, value.inherit, value, kv.global, kv.default);
      });
      return kv;
    };
    initPrivates = async (dir) => {
      const name = "privates.json";
      const file2 = `${dir}/${name}`;
      const data = requireFileSync(file2, { type: "json" });
      staticCache2 = isOld2(data) ? migrate2(file2, data) : format3(data);
      dynamicCache2 = format3(data);
      watch(file2, async (old, data2) => {
        staticCache2 = isOld2(data2) ? migrate2(file2, data2) : format3(data2);
        dynamicCache2 = staticCache2;
        const options = { file: name, old, data: dynamicCache2 };
        listeners.emit(FILE_CHANGE, options);
        listeners.emit(`${FILE_CHANGE}:${name}`, options);
      }, { type: "json" });
      clearCache(count2, staticCache2, dynamicCache2);
    };
    privates = () => dynamicCache2;
    getFriendCfg = (userId, selfId) => {
      const keys = [`Bot:${selfId}:${userId}`, `Bot:${selfId}`, userId, "global", "default"];
      return getCfg2(keys);
    };
    getDirectCfg = (userId, selfId) => {
      const keys = [`Bot:${selfId}:${userId}`, `Bot:${selfId}`, userId, "global", "default"];
      return getCfg2(keys);
    };
    getPrivatesFileData = (dir) => {
      const name = "privates.json";
      const file2 = `${dir}/${name}`;
      const data = requireFileSync(file2, { type: "json" });
      return isOld2(data) ? migrate2(file2, data) : format3(data);
    };
    privates_default = initPrivates;
  }
});

// src/adapter/snapka/key.ts
var createWsResponseKey;
var init_key3 = __esm({
  "src/adapter/snapka/key.ts"() {
    createWsResponseKey = (echo) => {
      return `_response:${echo}`;
    };
  }
});

// src/adapter/snapka/request.ts
var index3, createRequestError, sendWsRequest, sendWsScreenshotRequest;
var init_request4 = __esm({
  "src/adapter/snapka/request.ts"() {
    init_internal();
    init_key3();
    index3 = 0;
    createRequestError = (options, errorType, cause) => {
      return new Error(
        `[sendRequest] \u8BF7\u6C42\u9519\u8BEF:
  options: ${options}
  error: ${errorType}`,
        { cause }
      );
    };
    sendWsRequest = (socket, data, options = { timeout: 60 * 1e3, onRequest: true }) => {
      return new Promise((resolve, reject) => {
        const timeout2 = options?.timeout ?? 60 * 1e3;
        if (socket.readyState !== socket.OPEN) {
          return reject(createRequestError(
            JSON.stringify(data),
            `WebSocket\u672A\u8FDE\u63A5\uFF0C\u5F53\u524D\u72B6\u6001: ${socket.readyState}`
          ));
        }
        if (options.onRequest) {
          if (index3 >= Number.MAX_SAFE_INTEGER) {
            index3 = 0;
          }
          const echo = (++index3).toString();
          const key = createWsResponseKey(echo);
          const str = JSON.stringify({ ...data, echo });
          const result = (data2) => {
            clearTimeout(timer);
            if (data2?.status === "ok") {
              return resolve(data2.data);
            }
            reject(createRequestError(str, "\u8BF7\u6C42\u5931\u8D25", data2));
          };
          const timer = setTimeout(() => {
            listeners.off(key, result);
            reject(createRequestError(str, `\u8BF7\u6C42\u8D85\u65F6 ${timeout2}ms`));
          }, timeout2);
          listeners.once(key, result);
          try {
            socket.send(str);
          } catch (error) {
            clearTimeout(timer);
            listeners.off(key, result);
            reject(createRequestError(str, "\u53D1\u9001\u5931\u8D25", error));
          }
          return;
        }
        try {
          socket.send(JSON.stringify(data));
          resolve(void 0);
        } catch (error) {
          reject(createRequestError(JSON.stringify(data), "\u53D1\u9001\u5931\u8D25", error));
        }
      });
    };
    sendWsScreenshotRequest = (socket, params, timeout2 = 60 * 1e3) => {
      return sendWsRequest(
        socket,
        {
          params,
          type: "request",
          action: params.data ? "render" : "screenshot"
        },
        {
          onRequest: true,
          timeout: timeout2
        }
      );
    };
  }
});

// src/adapter/render/admin/template.ts
var template_exports = {};
__export(template_exports, {
  renderTemplate: () => renderTemplate,
  renderTpl: () => renderTpl,
  startCleanExpiredFiles: () => startCleanExpiredFiles
});
var renderTpl, renderTemplate, getOutputPath, cleanExpiredFiles, startCleanExpiredFiles;
var init_template = __esm({
  "src/adapter/render/admin/template.ts"() {
    init_root();
    init_fsSync();
    init_file();
    renderTpl = (options) => {
      if (typeof options.file !== "string") {
        throw TypeError("\u6A21\u677F\u6587\u4EF6\u8DEF\u5F84\u5FC5\u987B\u4E3A\u5B57\u7B26\u4E32");
      }
      if (!options.name) {
        options.name = path4.basename(options.file) || "render";
      }
      if (options.data) {
        if (options.file.startsWith("http")) {
          throw TypeError("\u4ED6\u55B5\u7684 \u4E0D\u4F1A\u771F\u7684\u6709\u7B28\u6BD4\u4F20\u4E2Ahttp\u6765\u5F53\u505A\u6A21\u677F\u5427...");
        }
        const file2 = path4.resolve(options.file);
        const tplData = fs5.readFileSync(file2, "utf-8");
        const renderData = template.render(tplData, options.data);
        const outputPath = getOutputPath(options.file, renderData, options.name);
        fs5.writeFileSync(outputPath, renderData);
        delete options.data;
        options.file = `file://${outputPath}`;
        return options;
      }
      if (!options.file.startsWith("http") && !options.file.startsWith("file")) {
        options.file = `file://${path4.resolve(options.file)}`;
      }
      delete options.data;
      return options;
    };
    renderTemplate = (options) => {
      if (typeof options.file !== "string") {
        throw TypeError("\u6A21\u677F\u6587\u4EF6\u8DEF\u5F84\u5FC5\u987B\u4E3A\u5B57\u7B26\u4E32");
      }
      if ("name" in options) {
        options.file_name = options.name;
        delete options.name;
      }
      if (!options.file_name) {
        options.file_name = path4.basename(options.file) || "render";
      }
      if (options.data) {
        if (options.file.startsWith("http")) {
          throw TypeError("\u4ED6\u55B5\u7684 \u4E0D\u4F1A\u771F\u7684\u6709\u7B28\u6BD4\u4F20\u4E2Ahttp\u6765\u5F53\u505A\u6A21\u677F\u5427...");
        }
        const file2 = path4.resolve(options.file);
        const tplData = fs5.readFileSync(file2, "utf-8");
        const renderData = template.render(tplData, options.data);
        const outputPath = getOutputPath(options.file, renderData, options.file_name);
        fs5.writeFileSync(outputPath, renderData);
        delete options.data;
        options.file = `file://${outputPath}`;
        return options;
      }
      if (!options.file.startsWith("http") && !options.file.startsWith("file")) {
        options.file = `file://${path4.resolve(options.file)}`;
      }
      delete options.data;
      return options;
    };
    getOutputPath = (file2, data, name) => {
      const extname = path4.extname(file2);
      const basename = path4.basename(file2, extname);
      const fileDir = path4.join(htmlPath, name || "render");
      mkdirSync(fileDir);
      const contentHash = crypto.createHash("md5").update(data).digest("hex").substring(0, 8);
      const filePath = path4.join(fileDir, `${basename}-${contentHash}${extname}`);
      if (fs5.existsSync(filePath)) {
        const now = /* @__PURE__ */ new Date();
        try {
          fs5.utimesSync(filePath, now, now);
        } catch (err) {
          logger.error(`[\u6587\u4EF6\u66F4\u65B0] \u66F4\u65B0\u6587\u4EF6\u65F6\u51FA\u9519: ${filePath}, ${err}`);
        }
        return filePath;
      }
      fs5.writeFileSync(filePath, data);
      return filePath;
    };
    cleanExpiredFiles = async () => {
      let count3 = 0;
      const now = Date.now();
      const files = await getAllFiles(htmlPath, { suffixs: [".html"], returnType: "abs" });
      if (files.length === 0) return;
      const EXPIRE_TIME = 10 * 60 * 1e3;
      for (const file2 of files) {
        try {
          const stats = await fs5.promises.stat(file2);
          const lastModified = stats.mtimeMs;
          if (now - lastModified > EXPIRE_TIME) {
            await fs5.promises.unlink(file2);
            count3++;
          }
        } catch (err) {
          logger.error(`[\u6587\u4EF6\u6E05\u7406] \u5904\u7406\u6587\u4EF6\u65F6\u51FA\u9519: ${file2}, ${err}`);
        }
      }
      logger.mark(`[\u6587\u4EF6\u6E05\u7406] \u6E05\u7406HTML\u5B8C\u6210: ${count3}/${files.length}`);
    };
    startCleanExpiredFiles = () => {
      schedule.scheduleJob(process.env.CLEAN_HTML_CRON || "*/10 * * * *", cleanExpiredFiles);
    };
  }
});

// src/adapter/render/admin/cache.ts
var index4, cache8, registerRender, unregisterRender, getRender, callRender, getRenderCount, getRenderList, renderHtml, renderMultiHtml, RenderCache, render, Renderer;
var init_cache4 = __esm({
  "src/adapter/render/admin/cache.ts"() {
    index4 = 0;
    cache8 = [];
    registerRender = (id, render4) => {
      const i = ++index4;
      cache8.push({ index: i, id, render: render4 });
      logger.mark(`[render:${index4}] ${logger.green("\u6CE8\u518C\u6210\u529F")}: ${id}`);
      return i;
    };
    unregisterRender = (index6) => {
      const app5 = cache8.find((app6) => app6.index === index6);
      if (!app5) {
        logger.error(`[render] \u5378\u8F7D\u5931\u8D25: \u4E0D\u5B58\u5728\u7D22\u5F15 ${index6}`);
        return false;
      }
      cache8.splice(cache8.findIndex((app6) => app6.index === index6), 1);
      logger.mark(`[render] ${logger.yellow("\u5378\u8F7D\u6210\u529F")}: ${app5.id}`);
      return true;
    };
    getRender = (id) => {
      if (cache8.length === 0) throw new Error("\u6E32\u67D3\u5668\u5217\u8868\u4E3A\u7A7A: \u8BF7\u524D\u5F80\u63D2\u4EF6\u5E02\u573A\u5B89\u88C5\u3010@karinjs/puppeteer\u3011\u63D2\u4EF6");
      if (!id) {
        const app6 = cache8[Math.floor(Math.random() * cache8.length)];
        return app6;
      }
      if (typeof id === "number") {
        const app6 = cache8.find((app7) => app7.index === id);
        if (!app6) throw new Error(`\u672A\u627E\u5230\u6E32\u67D3\u5668\uFF1A${id}`);
        return app6;
      }
      const app5 = cache8.find((app6) => app6.id === id);
      if (!app5) throw new Error(`\u672A\u627E\u5230\u6E32\u67D3\u5668\uFF1A${id}`);
      return app5;
    };
    callRender = async (options, id) => {
      const res = getRender(id);
      const result = await res.render(Object.assign(options, { encoding: "base64" }));
      return result;
    };
    getRenderCount = () => cache8.length;
    getRenderList = () => {
      const list2 = cache8.map((app5) => app5);
      return list2;
    };
    renderHtml = (data) => {
      return callRender({
        file: data,
        name: "render",
        encoding: "base64",
        pageGotoParams: {
          waitUntil: "networkidle2"
        }
      });
    };
    renderMultiHtml = (file2, multiPage) => {
      if (!multiPage && multiPage !== 0) multiPage = true;
      return callRender({
        file: file2,
        name: "render",
        encoding: "base64",
        multiPage,
        pageGotoParams: {
          waitUntil: "networkidle2"
        }
      });
    };
    RenderCache = class {
      /**
       * 注册渲染器
       * @param data 渲染器数据
       * @param data.id 渲染器ID
       * @param data.type 渲染器类型
       * @param ata.render 渲染器标准方法
       * @returns 渲染器索引
       */
      app(data) {
        return registerRender(data.id, data.render);
      }
      /**
         * 卸载渲染器
         * @param index 渲染器索引
         * @returns 是否卸载成功
         */
      unapp(index6) {
        return unregisterRender(index6);
      }
      /**
         * 返回渲染器实例 未键入id返回第一个
         * @param id 渲染器ID
         * @returns 渲染器实例
         */
      App(id = "") {
        return getRender(id);
      }
      /**
         * 调用标准渲染器
         */
      async render(options, id) {
        return callRender(options, id);
      }
      /**
         * 快速渲染
         * @param data html路径、http地址
         * @returns 返回图片base64或数组
         */
      async renderHtml(data) {
        return renderHtml(data);
      }
      /**
         * 快速分片渲染
         * @param data html路径、http地址
         * @param multiPage 分片高度 自动计算传true
         */
      async renderMultiHtml(data, multiPage) {
        return renderMultiHtml(data, multiPage);
      }
    };
    render = new RenderCache();
    Renderer = render;
  }
});
var PREFIX, snapkaMap, createSnapkaClient, onMessage, initSnapkaClient, disconnectSnapkaClient, addSnapkaClient;
var init_client = __esm({
  "src/adapter/snapka/client.ts"() {
    init_internal();
    init_request4();
    init_template();
    init_cache4();
    init_key3();
    init_static();
    PREFIX = "[snapka-ws-clinet] ";
    snapkaMap = /* @__PURE__ */ new Map();
    createSnapkaClient = (clientOptions) => {
      let index6 = -1;
      let isReconnect = true;
      let reconnectTimer;
      const { enable, url, token, reconnectTime = 5e3, heartbeatTime = 3e4, isSnapka = false } = clientOptions;
      if (!enable || !isSnapka) return;
      const authorization = token ? `Bearer ${crypto.createHash("sha256").update(token).digest("hex")}` : void 0;
      const close = () => {
        isReconnect = false;
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = void 0;
        }
        client?.close();
        snapkaMap.delete(url);
      };
      const client = token ? new WebSocket$1(url, {
        headers: {
          authorization: `Bearer ${crypto.createHash("sha256").update(token).digest("hex")}`
        }
      }) : new WebSocket$1(url);
      const fnc2 = (isPrint = true) => {
        client.removeAllListeners();
        client?.close();
        index6 > 0 && unregisterRender(index6);
        if (!isReconnect) {
          isPrint && logger.error(`${PREFIX}\u8FDE\u63A5\u5173\u95ED: ${url}`);
          return;
        }
        isPrint && logger.error(`${PREFIX}\u8FDE\u63A5\u5173\u95ED: ${url} ${reconnectTime / 1e3}s \u540E\u91CD\u8FDE...`);
        reconnectTimer = setTimeout(() => createSnapkaClient(clientOptions), reconnectTime);
      };
      client.once("open", () => {
        const timer = setInterval(() => client.ping(), heartbeatTime);
        if (snapkaMap.has(url)) snapkaMap.get(url)?.close();
        snapkaMap.set(url, { client, close });
        client.once("close", () => {
          clearInterval(timer);
          fnc2();
        });
        setTimeout(() => {
          if (client.readyState !== WebSocket$1.OPEN) return;
          logger.info(`${PREFIX}\u8FDE\u63A5\u6210\u529F: ${url}`);
          index6 = registerRender("snapka", render4);
          client.on("message", async (event) => onMessage(client, url, event, authorization));
        }, 3e3);
      });
      client.on("error", (error) => {
        logger.error(`${PREFIX}\u8FDE\u63A5\u9519\u8BEF: ${error}`);
        fnc2(false);
      });
      const render4 = (options) => {
        options = renderTemplate(options);
        return sendWsScreenshotRequest(client, options);
      };
      return {
        render: render4,
        close
      };
    };
    onMessage = async (client, url, event, authorization) => {
      const raw2 = event.toString();
      const options = JSON.parse(raw2);
      logger.debug(`${PREFIX}\u6536\u5230\u6D88\u606F: ${lodash3.truncate(raw2, { length: 300 })}`);
      if (options.type === "response") {
        const key = createWsResponseKey(options.echo);
        return listeners.emit(key, options);
      }
      if (options.type !== "request") {
        return logger.error(`${PREFIX}\u6536\u5230\u672A\u77E5\u6D88\u606F: ${raw2}`);
      }
      if (options.action === "uploadFile") {
        const file2 = fileURLToPath$1(options.params.path);
        logger.debug(`${PREFIX}\u6536\u5230\u4E0A\u4F20\u6587\u4EF6\u8BF7\u6C42: ${options.params.path}`);
        if (!isPublic(file2)) {
          logger.error(`${PREFIX}\u4E0A\u4F20\u6587\u4EF6\u5931\u8D25: \u975E\u6CD5\u7684\u8DEF\u5F84\uFF0C${file2} \u6CA1\u6709\u5904\u4E8E\u5141\u8BB8\u9759\u6001\u8D44\u6E90\u76EE\u5F55\u4E0B`);
          client.send(JSON.stringify({
            type: "response",
            action: "uploadFile",
            echo: options.echo,
            status: "failed",
            data: "\u975E\u6CD5\u7684\u8DEF\u5F84\uFF0C\u6CA1\u6709\u5904\u4E8E\u5141\u8BB8\u9759\u6001\u8D44\u6E90\u76EE\u5F55\u4E0B"
          }));
          return;
        }
        const target = new URL$1(url);
        target.protocol = url.startsWith("wss") ? "https:" : "http:";
        target.pathname = options.params.uploadPath;
        try {
          await axios8.post(
            target.toString(),
            {
              echo: options.echo,
              file: `base64://${fs5.readFileSync(file2, "base64")}`
            },
            {
              headers: {
                "Content-Type": "application/json",
                Authorization: authorization
              }
            }
          );
        } catch (error) {
          logger.error(new Error(`${PREFIX}\u4E0A\u4F20\u6587\u4EF6\u5931\u8D25: ${error}`, { cause: error }));
          client.send(JSON.stringify({
            type: "response",
            action: "uploadFile",
            echo: options.echo,
            status: "failed",
            data: error.message
          }));
        }
      }
    };
    initSnapkaClient = async () => {
      const { getRenderCfg: getRenderCfg2 } = await Promise.resolve().then(() => (init_config(), config_exports));
      const cfg = getRenderCfg2();
      cfg.ws_client.forEach((item) => {
        createSnapkaClient(item);
      });
    };
    disconnectSnapkaClient = (url) => {
      const cache10 = snapkaMap.get(url);
      if (!cache10) return;
      cache10.close();
      snapkaMap.delete(url);
    };
    addSnapkaClient = (clientOptions) => {
      createSnapkaClient(clientOptions);
    };
  }
});
var auth;
var init_auth = __esm({
  "src/adapter/snapka/auth.ts"() {
    auth = (token) => {
      if (!process.env.WS_SERVER_AUTH_KEY) return true;
      if (!token) return false;
      if (token === `Bearer ${process.env.WS_SERVER_AUTH_KEY}`) return true;
      const sha256 = crypto.createHash("sha256").update(process.env.WS_SERVER_AUTH_KEY).digest("hex");
      if (token === `Bearer ${sha256}`) return true;
      return false;
    };
  }
});

// src/adapter/snapka/server.ts
var WebSocketPuppeteerServer, initWebSocketPuppeteerServer;
var init_server = __esm({
  "src/adapter/snapka/server.ts"() {
    init_auth();
    init_internal();
    init_key3();
    init_request4();
    init_key2();
    init_template();
    init_cache4();
    WebSocketPuppeteerServer = async (socket, request3) => {
      let index6 = -1;
      const authorization = request3.headers["authorization"];
      if (!auth(authorization)) {
        socket.close();
        logger.error(`[WebSocket] \u9274\u6743\u5931\u8D25: authorization: ${authorization} url: ${request3.url}`);
        return;
      }
      const render4 = (options) => {
        options = renderTemplate(options);
        return sendWsScreenshotRequest(socket, options);
      };
      socket.on("close", () => {
        index6 > 0 && unregisterRender(index6);
        socket.removeAllListeners();
        socket.close();
      });
      socket.on("message", (event) => {
        const raw2 = event.toString();
        const { type, status, echo, data } = JSON.parse(raw2) || {};
        logger.debug(`[WebSocket] ${echo} ${type} ${status}`);
        logger.trace(`[WebSocket] ${echo} ${raw2}`);
        if (type !== "response") {
          logger.error(`[WebSocket] \u672A\u77E5\u7684\u8BF7\u6C42: ${raw2}`);
          return;
        }
        const key = createWsResponseKey(echo);
        listeners.emit(key, { status, data });
      });
      const name = request3.headers["x-client-name"] || "snapka";
      index6 = registerRender(name, render4);
    };
    initWebSocketPuppeteerServer = () => {
      listeners.on(WS_SNAPKA, (socket, request3, call2) => {
        call2();
        WebSocketPuppeteerServer(socket, request3);
      });
    };
  }
});
var snapkaMap2, createSnapkaHttp, initSnapkaHttp, disconnectSnapkaHttp;
var init_http = __esm({
  "src/adapter/snapka/http.ts"() {
    init_config();
    init_template();
    init_cache4();
    snapkaMap2 = /* @__PURE__ */ new Map();
    createSnapkaHttp = async (options) => {
      if (!options.isSnapka || !options.enable) return;
      const authorization = `Bearer ${crypto.createHash("sha256").update(options.token).digest("hex")}`;
      const url = path4.dirname(options.url) + `/ping?token=${authorization}`;
      const test = async () => {
        try {
          const result = await axios8.get(url);
          return result.data;
        } catch (error) {
          return false;
        }
      };
      const pingResult = await test();
      if (!pingResult) {
        logger.error(`\u65E0\u6CD5\u8FDE\u63A5\u5230 Snapka-http \u670D\u52A1: ${options.url}\uFF0C\u5C06\u5728\u540E\u53F0\u7EE7\u7EED\u5C1D\u8BD5\u8FDE\u63A5`);
      }
      const render4 = async (data) => {
        data = renderTemplate(data);
        try {
          const result = await axios8.post(options.url, data, {
            headers: {
              Authorization: authorization
            }
          });
          if (result.status === 200 && result.data?.code === 200) {
            return result.data.data;
          }
          throw new Error("\u8BF7\u6C42\u5931\u8D25:", { cause: result.data });
        } catch (error) {
          logger.error(`Snapka-http \u670D\u52A1\u8BF7\u6C42\u5F02\u5E38: ${options.url}`, error);
          throw error;
        }
      };
      let pingTimer;
      let consecutiveFailures = 0;
      const index6 = registerRender("snapka-http", render4);
      const close = () => {
        if (pingTimer) {
          clearInterval(pingTimer);
          pingTimer = void 0;
        }
        snapkaMap2.delete(options.url);
        unregisterRender(index6);
      };
      const startPingInterval = () => {
        pingTimer = setInterval(async () => {
          const isAlive = await test();
          if (isAlive) {
            if (consecutiveFailures > 0) {
              logger.info(`Snapka-http \u670D\u52A1 ${options.url} \u6062\u590D\u8FDE\u63A5`);
              consecutiveFailures = 0;
            }
          } else {
            consecutiveFailures++;
            logger.error(`Snapka-http \u670D\u52A1\u8FDE\u63A5\u5F02\u5E38 (${consecutiveFailures}\u6B21): ${options.url}\uFF0C\u5C06\u7EE7\u7EED\u5C1D\u8BD5\u91CD\u8FDE`);
          }
        }, 1e4);
      };
      startPingInterval();
      snapkaMap2.set(options.url, { close, pingTimer });
      return {
        render: render4,
        close
      };
    };
    initSnapkaHttp = async () => {
      const cfg = getRenderCfg();
      for (const options of cfg.http_server) {
        await createSnapkaHttp(options);
      }
    };
    disconnectSnapkaHttp = (url) => {
      const handler3 = snapkaMap2.get(url);
      if (handler3) {
        handler3.close();
      }
    };
  }
});

// src/adapter/snapka/index.ts
var snapka_exports = {};
__export(snapka_exports, {
  addSnapkaClient: () => addSnapkaClient,
  createSnapkaClient: () => createSnapkaClient,
  createSnapkaHttp: () => createSnapkaHttp,
  disconnectSnapkaClient: () => disconnectSnapkaClient,
  disconnectSnapkaHttp: () => disconnectSnapkaHttp,
  initSnapkaClient: () => initSnapkaClient,
  initSnapkaHttp: () => initSnapkaHttp,
  initWebSocketPuppeteerServer: () => initWebSocketPuppeteerServer
});
var init_snapka = __esm({
  "src/adapter/snapka/index.ts"() {
    init_client();
    init_server();
    init_http();
  }
});

// src/utils/config/file/render.ts
var cache9, format4, initRender, render2, getRenderCfg, render_default;
var init_render = __esm({
  "src/utils/config/file/render.ts"() {
    init_watch();
    init_fs2();
    init_number();
    init_require();
    init_listeners();
    format4 = (data) => {
      return {
        ws_server: data.ws_server,
        ws_client: data.ws_client.map((v) => ({
          ...v,
          token: String(v.token)
        })),
        http_server: data.http_server.map((v) => ({
          ...v,
          token: String(v.token),
          isSnapka: v.isSnapka ?? false
        }))
      };
    };
    initRender = (dir) => {
      const name = "render.json";
      const file2 = `${dir}/${name}`;
      const data = requireFileSync(file2, { type: "json" });
      cache9 = format4(data);
      watch(file2, async (old, data2) => {
        cache9 = format4(data2);
        const wsClient = diffArray(
          Array.isArray(old?.ws_client) ? old?.ws_client : [],
          Array.isArray(data2?.ws_client) ? data2?.ws_client : []
        );
        const {
          disconnectSnapkaClient: disconnectSnapkaClient2,
          createSnapkaClient: createSnapkaClient2,
          disconnectSnapkaHttp: disconnectSnapkaHttp2,
          createSnapkaHttp: createSnapkaHttp2
        } = await Promise.resolve().then(() => (init_snapka(), snapka_exports));
        wsClient.removed.forEach((v) => disconnectSnapkaClient2(v.url));
        wsClient.added.forEach((v) => createSnapkaClient2(v));
        const httpServer = diffArray(
          Array.isArray(old?.http_server) ? old?.http_server : [],
          Array.isArray(data2?.http_server) ? data2?.http_server : []
        );
        httpServer.removed.forEach((v) => disconnectSnapkaHttp2(v.url));
        httpServer.added.forEach((v) => createSnapkaHttp2(v));
        const options = { file: name, old, data: cache9 };
        listeners.emit(FILE_CHANGE, options);
        listeners.emit(`${FILE_CHANGE}:${name}`, options);
      }, { type: "json" });
    };
    render2 = () => cache9;
    getRenderCfg = () => cache9;
    render_default = initRender;
  }
});

// src/utils/config/file/pm2.ts
var pm2, initPm2;
var init_pm2 = __esm({
  "src/utils/config/file/pm2.ts"() {
    init_root();
    init_require();
    pm2 = () => requireFileSync(`${configPath}/pm2.json`, { ex: 30 });
    initPm2 = () => {
    };
  }
});

// src/utils/config/file/redis.ts
var redis;
var init_redis2 = __esm({
  "src/utils/config/file/redis.ts"() {
    init_root();
    init_require();
    redis = () => requireFileSync(`${configPath}/redis.json`, { ex: 30 });
  }
});

// src/utils/config/file/index.ts
var initConfigCache;
var init_file2 = __esm({
  "src/utils/config/file/index.ts"() {
    init_adapter();
    init_config2();
    init_env3();
    init_groups4();
    init_privates();
    init_render();
    init_adapter();
    init_config2();
    init_env3();
    init_groups4();
    init_privates();
    init_render();
    init_pm2();
    init_redis2();
    initConfigCache = (dir) => {
      env_default();
      adapter_default(dir);
      config_default(dir);
      groups_default(dir);
      privates_default(dir);
      render_default(dir);
    };
  }
});

// src/server/router/router.ts
var BASE_ROUTER, LOGIN_ROUTER, REFRESH_ROUTER, GET_CONFIG_ROUTER, SAVE_CONFIG_ROUTER, GET_LOG_ROUTER, SET_LOG_LEVEL_ROUTER, GET_LOG_FILE_LIST_ROUTER, GET_LOG_FILE_ROUTER, EXIT_ROUTER, RESTART_ROUTER, GET_NETWORK_STATUS_ROUTER, UPDATE_CORE_ROUTER, GET_BOTS_ROUTER, CONSOLE_ROUTER, PING_ROUTER, SYSTEM_STATUS_ROUTER, SYSTEM_INFO_ROUTER, SYSTEM_STATUS_WS_ROUTER, SYSTEM_STATUS_KARIN_ROUTER, GET_ONLINE_PLUGIN_LIST_ROUTER, GET_PLUGIN_LIST_ROUTER, GET_PLUGIN_APPS_ROUTER, GET_PLUGIN_FILE_ROUTER, GET_UPDATABLE_PLUGINS_ROUTER, BATCH_UPDATE_PLUGINS_ROUTER, GET_PLUGIN_CONFIG_ROUTER, SAVE_PLUGIN_CONFIG_ROUTER, IS_PLUGIN_CONFIG_EXIST_ROUTER, UPDATE_PLUGIN_ROUTER, INSTALL_PLUGIN_ROUTER, UNINSTALL_PLUGIN_ROUTER, GET_TASK_STATUS_ROUTER, GET_TASK_LIST_ROUTER, UPDATE_TASK_STATUS_ROUTER, GET_LOCAL_PLUGIN_LIST_ROUTER, CREATE_TERMINAL_ROUTER, GET_TERMINAL_LIST_ROUTER, CLOSE_TERMINAL_ROUTER, CHECK_PLUGIN_ROUTER, INSTALL_WEBUI_PLUGIN_ROUTER, GET_WEBUI_PLUGIN_LIST_ROUTER, UNINSTALL_WEBUI_PLUGIN_ROUTER, GET_WEBUI_PLUGIN_VERSIONS_ROUTER, UPDATE_WEBUI_PLUGIN_VERSION_ROUTER, TASK_LIST_ROUTER, TASK_RUN_ROUTER, TASK_LOGS_ROUTER, TASK_DELETE_ROUTER, PLUGIN_ADMIN_ROUTER, GET_PLUGIN_LIST_PLUGIN_ADMIN_ROUTER, GET_DEPENDENCIES_LIST_ROUTER, MANAGE_DEPENDENCIES_ROUTER, GET_NPMRC_LIST_ROUTER, GET_NPM_CONFIG_ROUTER, GET_NPM_BASE_CONFIG_ROUTER, SAVE_NPMRC_ROUTER, GET_LOADED_COMMAND_PLUGIN_CACHE_LIST_ROUTER, GET_PLUGIN_MARKET_LIST_ROUTER, GET_LOCAL_PLUGIN_FRONTEND_LIST_ROUTER;
var init_router = __esm({
  "src/server/router/router.ts"() {
    BASE_ROUTER = "/api/v1";
    LOGIN_ROUTER = "/login";
    REFRESH_ROUTER = "/refresh";
    GET_CONFIG_ROUTER = "/config/new/get";
    SAVE_CONFIG_ROUTER = "/config/new/save";
    GET_LOG_ROUTER = "/log";
    SET_LOG_LEVEL_ROUTER = "/logs/level";
    GET_LOG_FILE_LIST_ROUTER = "/logs/list";
    GET_LOG_FILE_ROUTER = "/logs/file";
    EXIT_ROUTER = "/exit";
    RESTART_ROUTER = "/restart";
    GET_NETWORK_STATUS_ROUTER = "/system/get/network";
    UPDATE_CORE_ROUTER = "/system/update";
    GET_BOTS_ROUTER = "/system/get/bots";
    CONSOLE_ROUTER = "/console/{*path}";
    PING_ROUTER = "/ping";
    SYSTEM_STATUS_ROUTER = "/status/system";
    SYSTEM_INFO_ROUTER = "/info";
    SYSTEM_STATUS_WS_ROUTER = "/status/ws";
    SYSTEM_STATUS_KARIN_ROUTER = "/status/karin";
    GET_ONLINE_PLUGIN_LIST_ROUTER = "/plugin/index";
    GET_PLUGIN_LIST_ROUTER = "/plugin/list";
    GET_PLUGIN_APPS_ROUTER = "/plugin/apps";
    GET_PLUGIN_FILE_ROUTER = "/plugin/file";
    GET_UPDATABLE_PLUGINS_ROUTER = "/plugin/updates";
    BATCH_UPDATE_PLUGINS_ROUTER = "/plugin/update/batch";
    GET_PLUGIN_CONFIG_ROUTER = "/plugin/config/get";
    SAVE_PLUGIN_CONFIG_ROUTER = "/plugin/config/save";
    IS_PLUGIN_CONFIG_EXIST_ROUTER = "/plugin/config/is-exist";
    UPDATE_PLUGIN_ROUTER = "/plugin/update";
    INSTALL_PLUGIN_ROUTER = "/plugin/install";
    UNINSTALL_PLUGIN_ROUTER = "/plugin/uninstall";
    GET_TASK_STATUS_ROUTER = "/plugin/task";
    GET_TASK_LIST_ROUTER = "/plugin/task/list";
    UPDATE_TASK_STATUS_ROUTER = "/plugin/task/status";
    GET_LOCAL_PLUGIN_LIST_ROUTER = "/plugin/local";
    CREATE_TERMINAL_ROUTER = "/terminal/create";
    GET_TERMINAL_LIST_ROUTER = "/terminal/list";
    CLOSE_TERMINAL_ROUTER = "/terminal/close";
    CHECK_PLUGIN_ROUTER = "/system/check/plugin";
    INSTALL_WEBUI_PLUGIN_ROUTER = "/plugin/webui/install";
    GET_WEBUI_PLUGIN_LIST_ROUTER = "/plugin/webui/list";
    UNINSTALL_WEBUI_PLUGIN_ROUTER = "/plugin/webui/uninstall";
    GET_WEBUI_PLUGIN_VERSIONS_ROUTER = "/plugin/webui/versions";
    UPDATE_WEBUI_PLUGIN_VERSION_ROUTER = "/plugin/webui/update-version";
    TASK_LIST_ROUTER = "/task/list";
    TASK_RUN_ROUTER = "/task/run";
    TASK_LOGS_ROUTER = "/task/logs";
    TASK_DELETE_ROUTER = "/task/delete_record";
    PLUGIN_ADMIN_ROUTER = "/plugin/admin";
    GET_PLUGIN_LIST_PLUGIN_ADMIN_ROUTER = "/plugin/detail/list";
    GET_DEPENDENCIES_LIST_ROUTER = "/dependencies/list";
    MANAGE_DEPENDENCIES_ROUTER = "/dependencies/manage";
    GET_NPMRC_LIST_ROUTER = "/dependencies/npmrc/list";
    GET_NPM_CONFIG_ROUTER = "/dependencies/npmrc/get";
    GET_NPM_BASE_CONFIG_ROUTER = "/dependencies/npm/base";
    SAVE_NPMRC_ROUTER = "/dependencies/npmrc/save";
    GET_LOADED_COMMAND_PLUGIN_CACHE_LIST_ROUTER = "/plugin/loaded/command";
    GET_PLUGIN_MARKET_LIST_ROUTER = "/plugin/market";
    GET_LOCAL_PLUGIN_FRONTEND_LIST_ROUTER = "/plugin/local/frontend";
  }
});
var isWindows, tips, createHttpClient, request2, handleResponse, checkPort2, safeExecSync, getPm2Id, safeKillProcess, forceKillProcess, checkProcess;
var init_check = __esm({
  "src/service/process/check.ts"() {
    init_sleep();
    init_port();
    init_router();
    isWindows = () => process.platform === "win32";
    tips = (msg, isTrim = false) => `[init] ${isTrim ? "" : " "}${msg}`;
    createHttpClient = (baseURL, timeout2) => axios8.create({
      baseURL,
      timeout: timeout2,
      headers: { Authorization: `Bearer ${process.env.HTTP_AUTH_KEY}` },
      validateStatus: () => true
    });
    request2 = async (url, path36, method, timeout2, isPrint = true) => {
      const client = createHttpClient(url, timeout2);
      try {
        const result = await client[method](path36);
        return handleResponse(result, method, path36, isPrint);
      } catch (error) {
        logger.debug(
          tips(`${method.toUpperCase()} \u8BF7\u6C42\u5F02\u5E38:`, true) + ` ${path36} - ${error?.message || "\u672A\u77E5\u9519\u8BEF"}`
        );
        return { code: 500, success: false };
      }
    };
    handleResponse = (result, method, path36, isPrint) => {
      if (result.status === 200) {
        isPrint && logger.info(
          tips(`${method.toUpperCase()} \u8BF7\u6C42\u6210\u529F:`, true) + ` ${path36} -> ${JSON.stringify(result.data)}`
        );
        return { code: result.status, success: true, data: result.data };
      }
      if (result.status === 401) {
        logger.error(
          tips(`${method.toUpperCase()} \u9274\u6743\u5931\u8D25:`, true) + ` ${path36} -> ${JSON.stringify(result.data)}`
        );
        return { code: result.status, success: false };
      }
      const logMethod = path36 === "/ping" ? logger.debug : logger.error;
      logMethod.call(
        logger,
        tips(`${method.toUpperCase()} \u8BF7\u6C42\u5931\u8D25:`, true) + ` ${path36} -> ${JSON.stringify(result.data)}`
      );
      return { code: result.status, success: false };
    };
    checkPort2 = async (port2) => {
      try {
        const portAvailable = await waitPort(port2);
        if (!portAvailable) {
          logger.fatal(logger.red(tips(`\u7AEF\u53E3 ${port2} \u4ECD\u88AB\u5360\u7528\u4E14\u65E0\u6CD5\u91CA\u653E\uFF0C\u8BF7\u624B\u52A8\u7ED3\u675F\u5360\u7528\u8FDB\u7A0B\u6216\u66F4\u6362\u7AEF\u53E3`)));
          process.exit(1);
        }
        return true;
      } catch (error) {
        logger.error(logger.red(tips(`\u68C0\u67E5\u7AEF\u53E3 ${port2} \u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`)));
        return false;
      }
    };
    safeExecSync = (command2) => {
      try {
        return execSync(command2).toString().trim();
      } catch (error) {
        logger.error(logger.red(tips(`\u547D\u4EE4\u6267\u884C\u5931\u8D25 "${command2}": ${error.message || "\u672A\u77E5\u9519\u8BEF"}`)));
        return "";
      }
    };
    getPm2Id = (pid) => {
      try {
        const command2 = isWindows() ? "pm2 jlist" : "pm2 jlist";
        const listOutput = safeExecSync(command2);
        if (!listOutput) {
          return null;
        }
        const list2 = JSON.parse(listOutput);
        const pmProcess = list2.find((item) => String(item.pid) === String(pid));
        return pmProcess?.pm_id ?? null;
      } catch (error) {
        logger.error(logger.red(tips(`\u83B7\u53D6PM2\u8FDB\u7A0B\u4FE1\u606F\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`)));
        return null;
      }
    };
    safeKillProcess = (pid) => {
      try {
        process.kill(pid);
        return true;
      } catch (error) {
        logger.error(logger.red(tips(`\u65E0\u6CD5\u7EC8\u6B62\u8FDB\u7A0B PID:${pid}: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`)));
        return false;
      }
    };
    forceKillProcess = (pid, runtime) => {
      if (runtime === "pm2") {
        const pmId = getPm2Id(pid);
        if (!pmId) {
          logger.error(logger.red(tips(`\u627E\u4E0D\u5230PM2\u5BF9\u5E94\u7684\u8FDB\u7A0BID\uFF0CPID:${pid}`)));
          return false;
        }
        const command2 = isWindows() ? `pm2 delete ${pmId}` : `pm2 delete ${pmId}`;
        safeExecSync(command2);
        return true;
      } else {
        return safeKillProcess(pid);
      }
    };
    checkProcess = async (port2) => {
      const host2 = new URL$1(BASE_ROUTER, `http://127.0.0.1:${port2}`).toString();
      const ping = await request2(host2, PING_ROUTER, "get", 300);
      if (!ping || !ping.success) {
        logger.debug(logger.green(tips("\u672A\u68C0\u6D4B\u5230\u540E\u53F0\u8FDB\u7A0B")));
        return;
      }
      const status = await request2(host2, SYSTEM_STATUS_KARIN_ROUTER, "get", 300);
      if (!status || !status.success) {
        if (status?.code === 401) {
          logger.error(logger.red(tips("\u9274\u6743\u5931\u8D25\uFF0C\u540E\u53F0\u8FDB\u7A0B\u4E0E\u5F53\u524DBot\u4E0D\u5339\u914D")));
          process.exit(1);
        }
        return;
      }
      const processStatus = status.data.data;
      const { pid, karin_runtime: runtime } = processStatus;
      if (pid === process.pid) {
        logger.debug(logger.green(tips("\u540E\u53F0\u8FDB\u7A0BPID\u4E0E\u5F53\u524D\u8FDB\u7A0B\u4E00\u81F4\uFF0C\u8DF3\u8FC7\u68C0\u67E5")));
        return;
      }
      logger.error(logger.yellow(tips(`\u68C0\u6D4B\u5230\u540E\u53F0\u8FDB\u7A0B\uFF0C\u6B63\u5728\u5173\u95ED PID:${pid} \u8FD0\u884C\u65F6:${runtime}`)));
      const exit = await request2(host2, EXIT_ROUTER, "post", 500);
      if (!exit || !exit.success) {
        logger.fatal(logger.red(tips("\u540E\u53F0\u8FDB\u7A0B\u5173\u95ED\u5931\u8D25\uFF0C\u5982\u9700\u591A\u5F00\u8BF7\u66F4\u6362\u7AEF\u53E3")));
        process.exit(1);
      }
      const MAX_WAIT_COUNT = 100;
      const WAIT_INTERVAL = 500;
      for (let i = 0; i < MAX_WAIT_COUNT; i++) {
        const startResult = await request2(host2, SYSTEM_STATUS_KARIN_ROUTER, "get", 300, false);
        if (startResult && startResult.success) {
          const resultStatus = startResult.data.data;
          const { pid: pingPid, karin_runtime: pingRuntime } = resultStatus;
          if (pingPid === process.pid) {
            await checkPort2(port2);
            logger.mark(logger.green(tips(`\u540E\u53F0\u8FDB\u7A0B\u5DF2\u5173\u95ED PID:${pingPid} \u8FD0\u884C\u65F6:${pingRuntime}`)));
            return;
          }
          await sleep(WAIT_INTERVAL);
          continue;
        }
        await checkPort2(port2);
        logger.mark(logger.green(tips(`\u540E\u53F0\u8FDB\u7A0B\u5DF2\u5173\u95ED PID:${pid} \u8FD0\u884C\u65F6:${runtime}`)));
        return;
      }
      logger.warn(tips("API\u5173\u95ED\u5931\u8D25\uFF0C\u6B63\u5728\u5C1D\u8BD5\u5F3A\u5236\u5173\u95ED\u540E\u53F0\u8FDB\u7A0B..."));
      const killSuccess = forceKillProcess(pid, runtime);
      if (!killSuccess) {
        logger.error(logger.red(tips("\u5F3A\u5236\u5173\u95ED\u5931\u8D25\uFF0C\u65E0\u6CD5\u7EC8\u6B62\u540E\u53F0\u8FDB\u7A0B")));
        process.exit(1);
      }
      await sleep(WAIT_INTERVAL);
      const ping2 = await request2(host2, PING_ROUTER, "get", 300);
      if (!ping2 || !ping2.success) {
        await checkPort2(port2);
        logger.mark(logger.green(tips("\u540E\u53F0\u8FDB\u7A0B\u5F3A\u5236\u5173\u95ED\u6210\u529F")));
        return;
      }
      logger.error(logger.red(tips(`\u540E\u53F0\u8FDB\u7A0B\u5173\u95ED\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7AEF\u53E3 ${port2} \u5360\u7528\u60C5\u51B5`)));
      process.exit(1);
    };
  }
});

// src/core/db/redis/mock/key/index.ts
var init_key4 = __esm({
  "src/core/db/redis/mock/key/index.ts"() {
  }
});
var RedisClient;
var init_mock = __esm({
  "src/core/db/redis/mock/index.ts"() {
    init_key4();
    init_common();
    RedisClient = class extends EventEmitter {
      id;
      /** 键、类型、过期时间映射 */
      store = {};
      /** 键值对 */
      #str = {};
      /** 数字对 */
      #num = {};
      /** 哈希表 */
      #hash = {};
      /** 列表 */
      #list = {};
      /** 集合 */
      #set = {};
      /** 有序集合 */
      #zset = {};
      /** HyperLogLog */
      #pf = {};
      /** 位图 */
      #bit = {};
      /** sqlite3 */
      #sqlite;
      constructor(sqlite) {
        super();
        this.id = "mock";
        this.store = {};
        this.#str = {};
        this.#num = {};
        this.#hash = {};
        this.#list = {};
        this.#set = {};
        this.#zset = {};
        this.#pf = {};
        this.#bit = {};
        this.#sqlite = sqlite;
      }
      async init() {
        await this.loadData();
        setInterval(() => {
          const keys = Object.keys(this.store);
          keys.forEach((key) => this.checkExpire(key));
        }, 3e4);
        setInterval(() => this.save(), 5 * 60 * 1e3);
        return this;
      }
      /**
       * @description 加载数据
       */
      async loadData() {
        const list2 = await this.#sqlite.getAllData();
        const keyMap = {
          ["str" /* STR */]: (key, value) => {
            this.#str[key] = value;
          },
          ["num" /* NUM */]: (key, value) => {
            this.#num[key] = Number(value);
          },
          ["hash" /* HASH */]: (key, value) => {
            const hash = JSON.parse(value);
            for (const field in hash) {
              if (typeof hash[field] !== "string") {
                hash[field] = Buffer.from(hash[field]);
              }
            }
            this.#hash[key] = hash;
          },
          ["list" /* LIST */]: (key, value) => {
            this.#list[key] = JSON.parse(value);
          },
          ["set" /* SET */]: (key, value) => {
            this.#set[key] = new Set(JSON.parse(value));
          },
          ["zset" /* ZSET */]: (key, value) => {
            this.#zset[key] = JSON.parse(value);
          },
          ["pf" /* PF */]: (key, value) => {
            this.#pf[key] = new Set(JSON.parse(value));
          },
          ["bit" /* BIT */]: (key, value) => {
            this.#bit[key] = Buffer.from(value);
          }
        };
        const isKey = (type) => {
          return keyMap[type] !== void 0;
        };
        list2.forEach((item) => {
          const { key, type, expire, value } = item;
          if (isKey(type)) {
            this.store[key] = { type, expire };
            keyMap[type](key, value);
          } else {
            this.#sqlite.del(key);
          }
        });
        logger.debug(`[Redis-mock] \u52A0\u8F7D\u6570\u636E\u5B8C\u6210: ${list2.length}`);
      }
      /**
       * @description 检查过期
       * @param key 键
       * @param isRemove 是否删除 默认删除
       * @returns 是否过期或值
       */
      checkExpire(key, isRemove = true) {
        if (!this.store[key]) return false;
        if (this.store[key].expire !== -1 && this.store[key].expire < moment().valueOf()) {
          if (!isRemove) return true;
          this.#del(key);
          return true;
        }
        return false;
      }
      /**
       * @description 直接删除键 不检查是否存在
       * @param key 键
       */
      #del(key) {
        const { type } = this.store[key];
        delete this.store[key];
        switch (type) {
          case "str" /* STR */:
            delete this.#str[key];
            break;
          case "num" /* NUM */:
            delete this.#num[key];
            break;
          case "hash" /* HASH */:
            delete this.#hash[key];
            break;
          case "list" /* LIST */:
            delete this.#list[key];
            break;
          case "set" /* SET */:
            delete this.#set[key];
            break;
          case "zset" /* ZSET */:
            delete this.#zset[key];
            break;
          case "pf" /* PF */:
            delete this.#pf[key];
            break;
          case "bit" /* BIT */:
            delete this.#bit[key];
            break;
        }
        this.#sqlite.del(key);
        logger.trace(`[Redis-mock] \u5220\u9664\u952E ${key}`);
      }
      /**
       * @description 获取键的类型
       * @param key 键
       * @returns 键的类型
       */
      type(key) {
        return this.store[key]?.type;
      }
      /**
       * @description 存储键值对
       * @param key 键
       * @param value 值
       * @param options 其他参数
       */
      async set(key, value, options = {}) {
        let expire = -1;
        if (!Buffer.isBuffer(value) && typeof value !== "string") {
          value = String(value);
        } else if (Buffer.isBuffer(value)) {
          value = value.toString();
        }
        if (lodash3.isEmpty(options)) {
          this.store[key] = { type: "str" /* STR */, expire };
          this.#str[key] = value;
          this.#sqlite.set(key, value, "str" /* STR */, expire);
          return "OK";
        }
        if (options?.EX !== void 0) {
          const EX = Number(options.EX);
          if (!isNaN(EX)) expire = moment().add(EX, "seconds").valueOf();
          this.store[key] = { type: "str" /* STR */, expire };
          this.#str[key] = value;
        } else if (options?.PX !== void 0) {
          const PX = Number(options.PX);
          if (!isNaN(PX)) expire = moment().add(PX, "milliseconds").valueOf();
          this.store[key] = { type: "str" /* STR */, expire };
          this.#str[key] = value;
        } else if (options?.EXAT !== void 0) {
          const EXAT = Number(options.EXAT);
          if (!isNaN(EXAT)) expire = EXAT;
          this.store[key] = { type: "str" /* STR */, expire };
          this.#str[key] = value;
        } else if (options?.PXAT !== void 0) {
          const PXAT = Number(options.PXAT);
          if (!isNaN(PXAT)) expire = PXAT;
          this.store[key] = { type: "str" /* STR */, expire };
        } else if (options?.KEEPTTL) {
          if (this.#str[key]) {
            this.#str[key] = value;
          } else {
            this.store[key] = { type: "str" /* STR */, expire: -1 };
            this.#str[key] = value;
          }
        } else if (options?.NX) {
          if (!this.#str[key]) {
            this.store[key] = { type: "str" /* STR */, expire: -1 };
            this.#str[key] = value;
          }
        } else if (options?.XX) {
          if (this.#str[key]) {
            this.#str[key] = value;
          }
        } else if (options?.GET) {
          this.store[key] = { type: "str" /* STR */, expire: -1 };
          if (this.#str[key]) {
            const oldValue = this.#str[key];
            this.#str[key] = value;
            this.#sqlite.set(key, value, "str" /* STR */, expire);
            return oldValue;
          }
          this.#str[key] = value;
          this.#sqlite.set(key, value, "str" /* STR */, expire);
          return null;
        } else {
          this.store[key] = { type: "str" /* STR */, expire: -1 };
          this.#str[key] = value;
        }
        this.#sqlite.set(key, value, "str" /* STR */, expire);
        return "OK";
      }
      /**
       * @description 获取键值
       * @param key 键
       */
      async get(key) {
        if (!this.store[key]) return null;
        if (this.checkExpire(key)) return null;
        const { type } = this.store[key];
        if (type === "num" /* NUM */) {
          return String(this.#num[key]);
        } else {
          return this.#str[key].toString();
        }
      }
      /**
       * @description 删除键
       * @param key 键
       */
      async del(key) {
        if (!this.store[key]) return 0;
        this.#del(key);
        return 1;
      }
      /**
       * @description 检查键是否存在
       * @param key 键
       */
      async exists(key) {
        if (!this.store[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return 1;
      }
      /**
       * @description 设置键的过期时间
       * @param key 键
       * @param seconds 过期时间（秒）
       */
      async expire(key, seconds) {
        if (!this.store[key]) return 0;
        const expire = moment().add(seconds, "seconds").valueOf();
        this.store[key].expire = expire;
        this.#sqlite.expire(key, expire);
        return 1;
      }
      /**
       * @description 获取键的过期时间
       * @param key 键
       */
      async ttl(key) {
        if (!this.store[key]) return -2;
        if (this.store[key].expire === -1) return -1;
        if (this.checkExpire(key)) return -2;
        return moment(this.store[key].expire).diff(moment(), "seconds");
      }
      /**
       * @description 获取所有键
       * @param pattern 匹配规则
       */
      async keys(pattern) {
        const reg = new RegExp(pattern.replace(/\*/g, ".*"));
        const keys = Object.keys(this.store);
        const result = [];
        await Promise.all(keys.map(async (key) => {
          if (this.checkExpire(key)) return;
          if (reg.test(key)) {
            result.push(key);
          }
        }));
        return result;
      }
      /**
       * @description 清空所有键
       */
      async flushAll() {
        this.#str = {};
        this.#num = {};
        this.#hash = {};
        this.#list = {};
        this.#set = {};
        this.#zset = {};
        this.#pf = {};
        this.#bit = {};
        this.store = {};
        return "OK";
      }
      /**
       * @description 自增
       * @param key 键
       */
      async incr(key) {
        if (!this.#num[key]) {
          this.#num[key] = 0;
          this.store[key] = { type: "num" /* NUM */, expire: -1 };
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#num[key] = 0;
        }
        this.#num[key] += 1;
        this.#sqlite.set(key, String(this.#num[key]), "num" /* NUM */, this.store[key].expire);
        return this.#num[key];
      }
      /**
       * @description 自减
       * @param key 键
       */
      async decr(key) {
        if (!this.#num[key]) {
          this.#num[key] = 0;
          this.store[key] = { type: "num" /* NUM */, expire: -1 };
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#num[key] = 0;
        }
        this.#num[key] -= 1;
        this.#sqlite.set(key, String(this.#num[key]), "num" /* NUM */, this.store[key].expire);
        return this.#num[key];
      }
      /**
       * @description 追加字符串
       * @param key 键
       * @param value 值
       */
      async append(key, value) {
        if (!this.#str[key]) {
          this.#str[key] = "";
          this.store[key] = { type: "str" /* STR */, expire: -1 };
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#str[key] = "";
        }
        if (Buffer.isBuffer(value)) {
          this.#str[key] += Buffer.concat([Buffer.from(this.#str[key]), value]).toString();
        } else {
          this.#str[key] += value;
        }
        this.#sqlite.set(key, this.#str[key], "str" /* STR */, this.store[key].expire);
        return this.#str[key].length;
      }
      /**
      * @description
      * @param key
      * @param field
      * @param value
      * @returns
      */
      /**
       * 将字段和值设置到指定键的哈希表中
       * 如果键不存在，则创建一个新的哈希表
       * @param key 哈希表的键
       * @param field 哈希表中的字段
       * @param value 要设置的值，可以是字符串或缓冲区
       * @returns 返回 1 表示设置成功，0 表示设置失败
       */
      async hSet(key, field, value) {
        if (!this.#hash[key]) {
          this.store[key] = { type: "hash" /* HASH */, expire: -1 };
          this.#hash[key] = {};
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#hash[key] = {};
        }
        this.#hash[key][field] = value;
        this.#sqlite.set(key, JSON.stringify(this.#hash[key]), "hash" /* HASH */, this.store[key].expire);
        return 1;
      }
      /**
       * 获取哈希表字段的值
       * @param key 哈希表的键
       * @param field 哈希表中的字段
       * @returns 返回字段的值，如果字段不存在则返回 null
       */
      async hGet(key, field) {
        if (!this.#hash[key] || !this.#hash[key][field]) return null;
        if (this.checkExpire(key)) return null;
        return this.#hash[key][field].toString();
      }
      /**
       * 删除哈希表中的一个或多个字段
       * @param key 哈希表的键
       * @param field 要删除的字段
       * @returns 返回成功删除的字段数量
       */
      async hDel(key, field) {
        if (!this.#hash[key] || !this.#hash[key][field]) return 0;
        if (this.checkExpire(key)) return 0;
        delete this.#hash[key][field];
        this.#sqlite.set(key, JSON.stringify(this.#hash[key]), "hash" /* HASH */, this.store[key].expire);
        return 1;
      }
      /**
       * 获取哈希表中所有字段的值
       * @param key 哈希表的键
       * @returns 返回所有字段的值
       */
      async hGetAll(key) {
        if (!this.#hash[key]) return {};
        if (this.checkExpire(key)) return {};
        return lodash3.mapValues(this.#hash[key], (value) => value.toString());
      }
      /**
       * 将一个或多个值插入到列表的头部
       * @param key 列表的键
       * @param values 要插入的值
       */
      async lPush(key, ...values) {
        if (!this.#list[key]) {
          this.store[key] = { type: "list" /* LIST */, expire: -1 };
          this.#list[key] = [];
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#list[key] = [];
        }
        this.#list[key].unshift(...values);
        this.#sqlite.set(key, JSON.stringify(this.#list[key]), "list" /* LIST */, this.store[key].expire);
        return this.#list[key].length;
      }
      /**
       * 将一个或多个值插入到列表的尾部
       * @param key 列表的键
       * @param values 要插入的值
       */
      async rPush(key, ...values) {
        if (!this.#list[key]) {
          this.store[key] = { type: "list" /* LIST */, expire: -1 };
          this.#list[key] = [];
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#list[key] = [];
        }
        this.#list[key].push(...values);
        this.#sqlite.set(key, JSON.stringify(this.#list[key]), "list" /* LIST */, this.store[key].expire);
        return this.#list[key].length;
      }
      /**
       * 移除并返回列表的第一个元素
       * @param key 列表的键
       * @returns 返回列表的第一个元素，如果列表为空则返回 null
       */
      async lPop(key) {
        if (!this.#list[key] || this.#list[key].length === 0) return null;
        if (this.checkExpire(key)) return null;
        const value = this.#list[key].shift();
        this.#sqlite.set(key, JSON.stringify(this.#list[key]), "list" /* LIST */, this.store[key].expire);
        return value ? value.toString() : null;
      }
      /**
       * 移除并返回列表的最后一个元素
       * @param key 列表的键
       * @returns 返回列表的最后一个元素，如果列表为空则返回 null
       */
      async rPop(key) {
        if (!this.#list[key] || this.#list[key].length === 0) return null;
        if (this.checkExpire(key)) return null;
        const value = this.#list[key].pop();
        this.#sqlite.set(key, JSON.stringify(this.#list[key]), "list" /* LIST */, this.store[key].expire);
        return value ? value.toString() : null;
      }
      /**
       * 返回列表指定范围内的元素
       * @param key 列表的键
       * @returns 返回列表指定范围内的元素
       */
      async lRange(key, start3, stop) {
        if (!this.#list[key]) return [];
        if (this.checkExpire(key)) return [];
        const value = this.#list[key].slice(start3, stop + 1).map((value2) => value2.toString());
        this.#sqlite.set(key, JSON.stringify(this.#list[key]), "list" /* LIST */, this.store[key].expire);
        return value;
      }
      /**
       * 向集合添加一个或多个成员
       * @param key 集合的键
       * @param members 要添加的成员
       * @returns 返回成功添加的成员数量
       */
      async sAdd(key, ...members) {
        if (!this.#set[key]) {
          this.store[key] = { type: "set" /* SET */, expire: -1 };
          this.#set[key] = /* @__PURE__ */ new Set();
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#set[key] = /* @__PURE__ */ new Set();
        }
        let added = 0;
        for (const member of members) {
          if (!this.#set[key].has(member.toString())) {
            this.#set[key].add(member.toString());
            added++;
          }
        }
        this.#sqlite.set(key, JSON.stringify(this.#set[key]), "set" /* SET */, this.store[key].expire);
        return added;
      }
      /**
       * 从集合中移除一个或多个成员
       * @param key 集合的键
       * @param members 要移除的成员
       * @returns 返回成功移除的成员数量
       */
      async sRem(key, ...members) {
        if (!this.#set[key]) return 0;
        if (this.checkExpire(key)) return 0;
        let removed = 0;
        for (const member of members) {
          if (this.#set[key].has(member.toString())) {
            this.#set[key].delete(member.toString());
            removed++;
          }
        }
        this.#sqlite.set(key, JSON.stringify(this.#set[key]), "set" /* SET */, this.store[key].expire);
        return removed;
      }
      /**
       * 返回集合的所有成员
       * @param key 集合的键
       * @returns 返回集合的所有成员
       */
      async sMembers(key) {
        if (!this.#set[key]) return [];
        if (this.checkExpire(key)) return [];
        const members = Array.from(this.#set[key]);
        return members.map((member) => member.toString());
      }
      /**
       * 检查成员是否是集合的成员
       * @param key 集合的键
       * @param member 要检查的成员
       * @returns 返回 1 表示是集合的成员，0 表示不是集合的成员
       */
      async sismember(key, member) {
        if (!this.#set[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return this.#set[key].has(member.toString()) ? 1 : 0;
      }
      /**
       * 向有序集合添加一个或多个成员
       * @param key 有序集合的键
       * @param score 分数
       * @param member 成员
       * @returns 返回成功添加的成员数量
       */
      async zAdd(key, score, member) {
        if (!this.#zset[key]) {
          this.store[key] = { type: "zset" /* ZSET */, expire: -1 };
          this.#zset[key] = [];
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#zset[key] = [];
        }
        const index6 = this.#zset[key].findIndex((entry) => entry.member === member.toString());
        if (index6 === -1) {
          this.#zset[key].push({ score, member });
        } else {
          this.#zset[key][index6] = { score, member };
        }
        this.#sqlite.set(key, JSON.stringify(this.#zset[key]), "zset" /* ZSET */, this.store[key].expire);
        return 1;
      }
      /**
       * 返回有序集合的成员数量
       * @param key 有序集合的键
       * @returns 返回有序集合的成员数量
       */
      async zcard(key) {
        if (!this.#list[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return this.#list[key].length;
      }
      /**
       * 返回有序集合中指定成员的排名
       * @param key 有序集合的键
       * @param member 成员
       * @returns 返回成员的排名，如果成员不存在则返回 null
       */
      async zRank(key, member) {
        if (!this.#list[key]) return null;
        if (this.checkExpire(key)) return null;
        const index6 = this.#list[key].findIndex((entry) => entry === member.toString());
        return index6 !== -1 ? index6 : null;
      }
      /**
       * 返回有序集合中指定成员的分数
       * @param key 有序集合的键
       * @param member 成员
       * @returns 返回成员的分数，如果成员不存在则返回 null
       */
      async zScore(key, member) {
        if (!this.#list[key]) return null;
        if (this.checkExpire(key)) return null;
        const entry = this.#list[key].find((entry2) => entry2 === member.toString());
        return entry ? entry.length : null;
      }
      /**
       * 从 HyperLogLog 中添加一个或多个元素
       * @param key HyperLogLog 的键
       * @param elements 要添加的元素
       * @returns 返回 1 表示添加成功，0 表示添加失败
       */
      async pfAdd(key, ...elements) {
        if (!this.#pf[key]) {
          this.store[key] = { type: "pf" /* PF */, expire: -1 };
          this.#pf[key] = /* @__PURE__ */ new Set();
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#pf[key] = /* @__PURE__ */ new Set();
        }
        let added = 0;
        for (const element of elements) {
          if (!this.#pf[key].has(element.toString())) {
            this.#pf[key].add(element.toString());
            added++;
          }
        }
        this.#sqlite.set(key, JSON.stringify(this.#pf[key]), "pf" /* PF */, this.store[key].expire);
        return added > 0;
      }
      /**
       * 返回 HyperLogLog 的基数估算值
       * @param key HyperLogLog 的键
       * @returns 返回基数估算值
       */
      async pfCount(key) {
        if (!this.#pf[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return this.#pf[key].size;
      }
      /**
       * 合并多个 HyperLogLog
       * @param destKey 目标 HyperLogLog 的键
       * @param sourceKeys 源 HyperLogLog 的键
       * @returns 返回 1 表示合并成功，0 表示合并失败
       */
      async pExpire(key, seconds) {
        if (!this.#pf[key]) return false;
        this.store[key].expire = moment().add(seconds, "seconds").valueOf();
        this.#sqlite.set(key, JSON.stringify(this.#pf[key]), "pf" /* PF */, this.store[key].expire);
        return true;
      }
      /**
       * 设置 HyperLogLog 的过期时间
       * @param key HyperLogLog 的键
       * @param seconds 过期时间（秒）
       * @returns 返回 1 表示设置成功，0 表示设置失败
       */
      async pTTL(key) {
        if (!this.#pf[key]) return -2;
        if (this.store[key].expire === -1) return -1;
        if (this.checkExpire(key)) return -2;
        const ttl = moment(this.store[key].expire).diff(moment(), "seconds");
        this.store[key].expire = ttl;
        this.#sqlite.set(key, JSON.stringify(this.#pf[key]), "pf" /* PF */, this.store[key].expire);
        return ttl;
      }
      /**
       * 为键设置到某个特定时间点的过期时间
       * @param key HyperLogLog 的键
       * @param seconds 过期时间（毫秒）
       * @returns 返回布尔值
       */
      async pExpireAt(key, timestamp) {
        if (!this.#pf[key]) return false;
        if (this.checkExpire(key)) return false;
        this.store[key].expire = timestamp;
        this.#sqlite.set(key, JSON.stringify(this.#pf[key]), "pf" /* PF */, this.store[key].expire);
        return true;
      }
      /**
       * @description 发布消息到频道
       * @param channel 频道
       * @param message 消息
       * @returns 返回订阅者数量
       */
      async publish(channel, message2) {
        this.emit(channel, message2.toString());
        return this.listenerCount(channel);
      }
      /**
       * @description 订阅一个或多个频道
       * @param channels 频道
       * @param listener 监听器
       * @returns 返回订阅的频道数量
       */
      async subscribe(channels, listener) {
        channels.forEach((channel) => this.on(channel, listener));
        return channels.length;
      }
      /**
       * @description 取消订阅一个或多个频道
       * @param channels 频道
       * @param listener 监听器
       * @returns 返回取消订阅的频道数量
       */
      async unsubscribe(channels, listener) {
        channels.forEach((channel) => this.off(channel, listener));
        return channels.length;
      }
      /**
       * @description 设置位图指定偏移量的值
       * @param key 键
       * @param offset 偏移量
       * @param value 值
       * @returns 返回设置前的位
       */
      async setBit(key, offset, value) {
        if (!this.#bit[key]) {
          this.store[key] = { type: "bit" /* BIT */, expire: -1 };
          this.#bit[key] = Buffer.alloc(0);
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#bit[key] = Buffer.alloc(0);
        }
        const byteOffset = Math.floor(offset / 8);
        const bitOffset = offset % 8;
        const oldValue = this.#bit[key].readUInt8(byteOffset);
        const newValue = value ? oldValue | 1 << bitOffset : oldValue & ~(1 << bitOffset);
        this.#bit[key].writeUInt8(newValue, byteOffset);
        this.#sqlite.set(key, this.#bit[key].toString("base64"), "bit" /* BIT */, this.store[key].expire);
        return oldValue;
      }
      /**
       * @description 获取位图指定偏移量的值
       * @param key 键
       * @param offset 偏移量
       * @returns 返回位
       */
      async getBit(key, offset) {
        if (!this.#bit[key]) return 0;
        if (this.checkExpire(key)) return 0;
        const byteOffset = Math.floor(offset / 8);
        const bitOffset = offset % 8;
        const value = this.#bit[key].readUInt8(byteOffset);
        return value & 1 << bitOffset ? 1 : 0;
      }
      /**
       * @description 获取位图的指定范围内的位
       * @param key 键
       * @param start 起始偏移量
       * @param end 结束偏移量
       * @returns 返回位数组
       */
      async getRange(key, start3, end) {
        if (!this.#bit[key]) return [];
        if (this.checkExpire(key)) return [];
        const result = [];
        for (let i = start3; i <= end; i++) {
          result.push(await this.getBit(key, i));
        }
        return result;
      }
      /**
       * 获取哈希表中字段是否存在
       * @param key 哈希表的键
       * @param field 哈希表中的字段
       * @returns 返回1表示字段存在，0表示字段不存在
       */
      async hExists(key, field) {
        if (!this.#hash[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return this.#hash[key][field] !== void 0 ? 1 : 0;
      }
      /**
       * 获取哈希表中所有字段名
       * @param key 哈希表的键
       * @returns 返回所有字段名数组
       */
      async hKeys(key) {
        if (!this.#hash[key]) return [];
        if (this.checkExpire(key)) return [];
        return Object.keys(this.#hash[key]);
      }
      /**
       * 获取哈希表中所有值
       * @param key 哈希表的键
       * @returns 返回所有值数组
       */
      async hVals(key) {
        if (!this.#hash[key]) return [];
        if (this.checkExpire(key)) return [];
        return Object.values(this.#hash[key]).map((value) => value.toString());
      }
      /**
       * 获取哈希表中字段数量
       * @param key 哈希表的键
       * @returns 返回字段数量
       */
      async hLen(key) {
        if (!this.#hash[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return Object.keys(this.#hash[key]).length;
      }
      /**
       * 批量获取哈希表中字段的值
       * @param key 哈希表的键
       * @param fields 要获取的字段数组
       * @returns 返回字段值数组，不存在的字段返回null
       */
      async hMGet(key, ...fields) {
        if (!this.#hash[key]) return fields.map(() => null);
        if (this.checkExpire(key)) return fields.map(() => null);
        return fields.map((field) => {
          const value = this.#hash[key][field];
          return value !== void 0 ? value.toString() : null;
        });
      }
      /**
       * 批量设置哈希表中字段的值
       * @param key 哈希表的键
       * @param fieldValues 字段和值的数组，格式为[field1, value1, field2, value2, ...]
       * @returns 返回"OK"
       */
      async hMSet(key, ...fieldValues) {
        if (!this.#hash[key]) {
          this.store[key] = { type: "hash" /* HASH */, expire: -1 };
          this.#hash[key] = {};
        } else if (this.checkExpire(key, false)) {
          this.store[key].expire = -1;
          this.#hash[key] = {};
        }
        for (let i = 0; i < fieldValues.length; i += 2) {
          if (i + 1 < fieldValues.length) {
            const field = fieldValues[i].toString();
            const value = fieldValues[i + 1];
            this.#hash[key][field] = value;
          }
        }
        this.#sqlite.set(key, JSON.stringify(this.#hash[key]), "hash" /* HASH */, this.store[key].expire);
        return "OK";
      }
      /**
       * 获取列表长度
       * @param key 列表的键
       * @returns 返回列表长度
       */
      async lLen(key) {
        if (!this.#list[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return this.#list[key].length;
      }
      /**
       * 获取列表指定索引的元素
       * @param key 列表的键
       * @param index 索引，0表示第一个元素，-1表示最后一个元素
       * @returns 返回元素值，索引超出范围返回null
       */
      async lIndex(key, index6) {
        if (!this.#list[key]) return null;
        if (this.checkExpire(key)) return null;
        const list2 = this.#list[key];
        if (index6 < 0) {
          index6 = list2.length + index6;
        }
        if (index6 < 0 || index6 >= list2.length) {
          return null;
        }
        return list2[index6].toString();
      }
      /**
       * 设置列表指定索引的元素值
       * @param key 列表的键
       * @param index 索引
       * @param value 值
       * @returns 成功返回"OK"，失败返回错误
       */
      async lSet(key, index6, value) {
        if (!this.#list[key]) return null;
        if (this.checkExpire(key)) return null;
        const list2 = this.#list[key];
        if (index6 < 0) {
          index6 = list2.length + index6;
        }
        if (index6 < 0 || index6 >= list2.length) {
          return null;
        }
        list2[index6] = value;
        this.#sqlite.set(key, JSON.stringify(list2), "list" /* LIST */, this.store[key].expire);
        return "OK";
      }
      /**
       * 移除列表中与指定值相等的元素
       * @param key 列表的键
       * @param count 移除的数量，0表示移除所有匹配的元素，正数表示从头部开始移除，负数表示从尾部开始移除
       * @param value 要移除的值
       * @returns 返回移除的元素数量
       */
      async lRem(key, count3, value) {
        if (!this.#list[key]) return 0;
        if (this.checkExpire(key)) return 0;
        const list2 = this.#list[key];
        const strValue = value.toString();
        let removed = 0;
        if (count3 === 0) {
          const newList = list2.filter((item) => item.toString() !== strValue);
          removed = list2.length - newList.length;
          this.#list[key] = newList;
        } else if (count3 > 0) {
          for (let i = 0; i < list2.length && removed < count3; i++) {
            if (list2[i].toString() === strValue) {
              list2.splice(i, 1);
              removed++;
              i--;
            }
          }
        } else {
          count3 = Math.abs(count3);
          for (let i = list2.length - 1; i >= 0 && removed < count3; i--) {
            if (list2[i].toString() === strValue) {
              list2.splice(i, 1);
              removed++;
            }
          }
        }
        this.#sqlite.set(key, JSON.stringify(list2), "list" /* LIST */, this.store[key].expire);
        return removed;
      }
      /**
       * 获取集合中元素数量
       * @param key 集合的键
       * @returns 返回集合中元素数量
       */
      async sCard(key) {
        if (!this.#set[key]) return 0;
        if (this.checkExpire(key)) return 0;
        return this.#set[key].size;
      }
      /**
       * 计算集合的差集
       * @param keys 集合的键数组
       * @returns 返回差集数组
       */
      async sDiff(...keys) {
        if (keys.length === 0) return [];
        const firstKey = keys[0];
        if (!this.#set[firstKey]) return [];
        if (this.checkExpire(firstKey)) return [];
        const result = /* @__PURE__ */ new Set();
        for (const item of this.#set[firstKey]) {
          result.add(item.toString());
        }
        for (let i = 1; i < keys.length; i++) {
          const key = keys[i];
          if (!this.#set[key] || this.checkExpire(key)) continue;
          for (const item of this.#set[key]) {
            result.delete(item.toString());
          }
        }
        return Array.from(result);
      }
      /**
       * 计算集合的交集
       * @param keys 集合的键数组
       * @returns 返回交集数组
       */
      async sInter(...keys) {
        if (keys.length === 0) return [];
        const validKeys = keys.filter((key) => this.#set[key] && !this.checkExpire(key));
        if (validKeys.length === 0) return [];
        const result = /* @__PURE__ */ new Set();
        const firstKey = validKeys[0];
        for (const item of this.#set[firstKey]) {
          let inAllSets = true;
          for (let i = 1; i < validKeys.length; i++) {
            const key = validKeys[i];
            if (!this.#set[key].has(item.toString())) {
              inAllSets = false;
              break;
            }
          }
          if (inAllSets) {
            result.add(item.toString());
          }
        }
        return Array.from(result);
      }
      /**
       * 计算集合的并集
       * @param keys 集合的键数组
       * @returns 返回并集数组
       */
      async sUnion(...keys) {
        const result = /* @__PURE__ */ new Set();
        for (const key of keys) {
          if (!this.#set[key] || this.checkExpire(key)) continue;
          for (const item of this.#set[key]) {
            result.add(item.toString());
          }
        }
        return Array.from(result);
      }
      /**
       * 将多个键的值同时获取
       * @param keys 要获取的键数组
       * @returns 返回值数组，不存在的键返回null
       */
      async mGet(...keys) {
        return Promise.all(keys.map((key) => this.get(key)));
      }
      /**
       * 同时设置多个键值对
       * @param keyValues 键值对数组，格式为[key1, value1, key2, value2, ...]
       * @returns 返回"OK"
       */
      async mSet(...keyValues) {
        for (let i = 0; i < keyValues.length; i += 2) {
          if (i + 1 < keyValues.length) {
            const key = keyValues[i].toString();
            const value = keyValues[i + 1];
            await this.set(key, value);
          }
        }
        return "OK";
      }
      /**
       * 设置键的新值并返回旧值
       * @param key 键
       * @param value 新值
       * @returns 返回旧值，如果键不存在则返回null
       */
      async getSet(key, value) {
        const oldValue = await this.get(key);
        await this.set(key, value);
        return oldValue;
      }
      /**
       * 修复zRange方法，使用正确的zset数据结构
       * 返回有序集合的成员数量
       * @param key 有序集合的键
       * @returns 返回有序集合的成员数量
       */
      async zRange(key, start3, stop) {
        if (!this.#zset[key]) return [];
        if (this.checkExpire(key)) return [];
        const sortedEntries = [...this.#zset[key]].sort((a, b) => a.score - b.score);
        return sortedEntries.slice(start3, stop + 1).map((entry) => entry.member.toString());
      }
      /**
       * 按分数范围返回有序集合的成员
       * @param key 有序集合的键
       * @param min 最小分数
       * @param max 最大分数
       * @returns 返回指定分数范围的成员数组
       */
      async zRangeByScore(key, min, max) {
        if (!this.#zset[key]) return [];
        if (this.checkExpire(key)) return [];
        return this.#zset[key].filter((entry) => entry.score >= min && entry.score <= max).sort((a, b) => a.score - b.score).map((entry) => entry.member.toString());
      }
      /**
       * 按分数降序返回有序集合的成员
       * @param key 有序集合的键
       * @param start 起始索引
       * @param stop 结束索引
       * @returns 返回指定范围的成员数组（按分数降序）
       */
      async zRevRange(key, start3, stop) {
        if (!this.#zset[key]) return [];
        if (this.checkExpire(key)) return [];
        const sortedEntries = [...this.#zset[key]].sort((a, b) => b.score - a.score);
        return sortedEntries.slice(start3, stop + 1).map((entry) => entry.member.toString());
      }
      /**
       * 获取有序集合中指定成员的排名（按分数降序）
       * @param key 有序集合的键
       * @param member 成员
       * @returns 返回成员的排名，不存在返回null
       */
      async zRevRank(key, member) {
        if (!this.#zset[key]) return null;
        if (this.checkExpire(key)) return null;
        const strMember = member.toString();
        const sortedEntries = [...this.#zset[key]].sort((a, b) => b.score - a.score);
        for (let i = 0; i < sortedEntries.length; i++) {
          if (sortedEntries[i].member.toString() === strMember) {
            return i;
          }
        }
        return null;
      }
      /**
       * 从有序集合中移除一个或多个成员
       * @param key 有序集合的键
       * @param member 要移除的成员
       * @returns 返回成功移除的成员数量
       */
      async zRem(key, member) {
        if (!this.#zset[key]) return 0;
        if (this.checkExpire(key)) return 0;
        const strMember = member.toString();
        const index6 = this.#zset[key].findIndex((entry) => entry.member.toString() === strMember);
        if (index6 !== -1) {
          this.#zset[key].splice(index6, 1);
          this.#sqlite.set(key, JSON.stringify(this.#zset[key]), "zset" /* ZSET */, this.store[key].expire);
          return 1;
        }
        return 0;
      }
      /**
       * 根据键类型获取值的字符串表示
       * @param key 键名
       * @returns 值的字符串表示
       */
      getValueStringByKey(key) {
        const { type } = this.store[key];
        switch (type) {
          case "str" /* STR */:
            return this.#str[key];
          case "num" /* NUM */:
            return String(this.#num[key]);
          case "hash" /* HASH */:
            return JSON.stringify(this.#hash[key]);
          case "list" /* LIST */:
            return JSON.stringify(this.#list[key]);
          case "set" /* SET */:
            return JSON.stringify(Array.from(this.#set[key]));
          case "zset" /* ZSET */:
            return JSON.stringify(this.#zset[key]);
          case "pf" /* PF */:
            return JSON.stringify(Array.from(this.#pf[key]));
          case "bit" /* BIT */:
            return this.#bit[key].toString("base64");
          default:
            return "";
        }
      }
      async save() {
        const keys = await this.#sqlite.keys();
        const { removed, added, common } = diffSimpleArray(keys, Object.keys(this.store));
        removed.forEach((key) => {
          this.#sqlite.del(key);
        });
        added.forEach((key) => {
          const { type, expire } = this.store[key];
          const value = this.getValueStringByKey(key);
          this.#sqlite.set(key, value, type, expire);
        });
        await Promise.all(common.map(async (key) => {
          const data = this.store[key];
          if (!data) return;
          const { type, expire } = data;
          const currentValue = this.getValueStringByKey(key);
          const sql = await this.#sqlite.get(key);
          if (sql?.expire !== expire || sql?.value !== currentValue) {
            this.#sqlite.set(key, currentValue, type, expire);
          }
        }));
        return "OK";
      }
    };
  }
});

// src/core/db/redis/mock.ts
var init_mock2 = __esm({
  "src/core/db/redis/mock.ts"() {
    init_mock();
  }
});

// src/core/db/redis/redis.ts
var redis_exports = {};
__export(redis_exports, {
  createRedis: () => createRedis,
  redis: () => redis2
});
var redis2, create, start, createRedis, isArm64, mock;
var init_redis3 = __esm({
  "src/core/db/redis/redis.ts"() {
    init_env2();
    init_config();
    init_root();
    init_exec();
    init_mock2();
    init_sqlite();
    create = async (options) => {
      try {
        const client = createClient(options);
        await client.connect();
        Object.defineProperty(client, "id", { value: "Redis" });
        return client;
      } catch (error) {
        logger.debug(`${logger.red("[redis] \u542F\u52A8\u5931\u8D25:")} ${JSON.stringify(options)}`);
        logger.debug(error);
      }
    };
    start = async () => {
      logger.debug("[redis] \u6B63\u5728\u5C1D\u8BD5\u542F\u52A8 Redis...");
      if (isWin()) {
        const result = await exec("redis-server.exe redis.conf", { booleanResult: true });
        if (result) return result;
        const service = "net start Redis";
        return await exec(service, { booleanResult: true });
      }
      const cmd = "redis-server --save 300 10 --daemonize yes" + await isArm64();
      return await exec(cmd, { booleanResult: true });
    };
    createRedis = async () => {
      try {
        const options = redis();
        let client = await create(options);
        if (client) {
          logger.info(`[redis] ${logger.green("Redis \u8FDE\u63A5\u6210\u529F")}`);
          redis2 = client;
          return redis2;
        }
        const result = await start();
        if (result) {
          logger.debug(logger.green("[redis] \u4E3B\u52A8\u62C9\u8D77 Redis \u6210\u529F"));
          client = await create(options);
        } else {
          logger.debug(logger.red("[redis] \u4E3B\u52A8\u62C9\u8D77 Redis \u5931\u8D25"));
        }
        if (client) {
          redis2 = client;
          return redis2;
        }
        throw new Error("Redis \u542F\u52A8\u5931\u8D25");
      } catch (error) {
        logger.debug(`[redis] ${logger.red("Redis \u8FDE\u63A5\u5931\u8D25")}`);
        logger.debug(error);
        logger.debug(logger.yellow("[redis] \u5C06\u964D\u7EA7\u4E3A redis-mock \u5B9E\u73B0"));
        redis2 = await mock();
        return redis2;
      }
    };
    isArm64 = async () => {
      if (os.arch() !== "arm64") return "";
      const { stdout } = await exec("redis-server -v");
      const version2 = stdout.toString();
      if (!version2) return "";
      const RedisVersion = version2.match(/v=(\d)./);
      if (RedisVersion && Number(RedisVersion[1]) >= 6) return " --ignore-warnings ARM64-COW-BUG";
      return "";
    };
    mock = async () => {
      const sqlite = await new SQLiteWrapper(path4.join(redisSqlite3Path, "redis.db")).init();
      const redis3 = await new RedisClient(sqlite).init();
      Object.defineProperty(redis3, "id", { value: "mock" });
      return redis3;
    };
  }
});

// src/service/process/exit.ts
var exit_exports = {};
__export(exit_exports, {
  processExit: () => processExit
});
var exitStatus, processExit;
var init_exit = __esm({
  "src/service/process/exit.ts"() {
    init_check();
    init_exec();
    init_uptime();
    exitStatus = false;
    processExit = async (code, isKillPm2 = false) => {
      logger.debug("[child] \u5B50\u8FDB\u7A0B\u6536\u5230\u9000\u51FA\u7533\u8BF7:", code);
      try {
        if (exitStatus) return;
        exitStatus = true;
        logger.debug("[child] \u5F00\u59CB\u4FDD\u5B58redis\u6570\u636E");
        const { redis: redis3 } = await Promise.resolve().then(() => (init_redis3(), redis_exports));
        if (redis3.id === "mock") await redis3.save();
        logger.debug("[child] redis\u6570\u636E\u4FDD\u5B58\u5B8C\u6210");
        logger.mark(tips(`\u8FD0\u884C\u7ED3\u675F \u8FD0\u884C\u65F6\u95F4\uFF1A${uptime2()} \u9000\u51FA\u7801\uFF1A${code ?? "\u672A\u77E5"}`));
        if (process.env.pm_id && isKillPm2) {
          logger.mark(tips("[child] pm2\u73AF\u5883 \u5220\u9664pm2\u8FDB\u7A0B"));
          await exec(`pm2 delete ${process.env.pm_id}`);
        }
      } catch (error) {
        logger.error(new Error("[child] \u9000\u51FA\u4E8B\u4EF6\u53D1\u751F\u9519\u8BEF:", { cause: error }));
      } finally {
        setTimeout(() => {
          exitStatus = true;
        }, 200);
        process.exit();
      }
    };
  }
});

// src/utils/button/handle.ts
var buttonHandle;
var init_handle = __esm({
  "src/utils/button/handle.ts"() {
    init_cache();
    buttonHandle = async (reg, args) => {
      const button3 = [];
      for (const info of cache3.button) {
        const regExp = info.reg;
        if (regExp.test(reg)) {
          try {
            let isnext = false;
            const next = () => {
              isnext = true;
            };
            const list2 = await info.fnc(next, args);
            if (list2) {
              if (Array.isArray(list2)) {
                button3.push(...list2);
              } else {
                button3.push(list2);
              }
            }
            if (!isnext) return button3;
          } catch (error) {
            logger.error(`[Button][Error] ${info.pkg.name}:`);
            logger.error(error);
          }
        }
      }
      return button3;
    };
  }
});

// src/utils/button/index.ts
var init_button = __esm({
  "src/utils/button/index.ts"() {
    init_handle();
    init_convert2();
  }
});
var exec2, handleReturn;
var init_exec2 = __esm({
  "src/utils/git/exec.ts"() {
    exec2 = (cmd, options) => {
      return new Promise((resolve) => {
        const timeout2 = (options?.timeout || 30) * 1e3;
        const timer = setTimeout(() => {
          resolve({
            status: false,
            error: new Error("\u547D\u4EE4\u6267\u884C\u8D85\u65F6"),
            stdout: "",
            stderr: "\u547D\u4EE4\u6267\u884C\u8D85\u65F6"
          });
        }, timeout2);
        const child = exec$2(cmd, options, (error, stdout, stderr) => {
          clearTimeout(timer);
          stderr = stderr.toString().trim();
          stdout = stdout.toString().trim();
          const status = !error;
          resolve({ status, error, stdout, stderr });
        });
        child.stdin?.write("\n");
      });
    };
    handleReturn = (data, callback) => {
      if (data.error || typeof data.stdout !== "string") {
        throw data.error || new Error("stdout \u7C7B\u578B\u9519\u8BEF");
      }
      if (callback) {
        return callback();
      }
      return data.stdout;
    };
  }
});

// src/utils/git/branch.ts
var getLocalBranches, getDefaultBranch, getRemoteBranches, getLocalCommitHash, getRemoteCommitHash;
var init_branch = __esm({
  "src/utils/git/branch.ts"() {
    init_exec2();
    getLocalBranches = async (cwd = process.cwd()) => {
      const cmd = "git --no-pager branch";
      const data = await exec2(cmd, { cwd });
      return handleReturn(data, () => {
        let defaultBranch = "";
        const list2 = data.stdout.split("\n").map((line) => {
          line = line.trim();
          if (line.startsWith("*")) {
            line = line.replace("*", "").trim();
            defaultBranch = line;
          }
          return line;
        });
        return {
          defaultBranch,
          list: list2
        };
      });
    };
    getDefaultBranch = async (cwd = process.cwd()) => {
      const { defaultBranch } = await getLocalBranches(cwd);
      return defaultBranch;
    };
    getRemoteBranches = async (cwd) => {
      const cmd = "git ls-remote --heads origin";
      const data = await exec2(cmd, { cwd });
      return handleReturn(data, () => {
        return data.stdout.split("\n").map((line) => {
          const [hash, ref] = line.trim().split(/\s+/).map((v) => v.trim());
          const branch = ref.replace("refs/heads/", "");
          return { branch, short: hash.slice(0, 7), hash };
        });
      });
    };
    getLocalCommitHash = async (cwd, options) => {
      const branch = options?.branch || "HEAD";
      const short = options?.short ? "--short" : "";
      const cmd = `git rev-parse ${short} ${branch}`;
      const data = await exec2(cmd, { cwd });
      return handleReturn(data);
    };
    getRemoteCommitHash = async (cwd, options) => {
      let branch = options?.branch || "origin/HEAD";
      if (!branch.startsWith("origin/")) {
        branch = `origin/${branch}`;
      }
      const short = options?.short ? "--short" : "";
      const cmd = `git rev-parse ${short} ${branch}`;
      const data = await exec2(cmd, { cwd });
      return handleReturn(data);
    };
  }
});

// src/utils/git/pull.ts
var pullResult, gitPull;
var init_pull = __esm({
  "src/utils/git/pull.ts"() {
    init_exec2();
    init_branch();
    pullResult = (status, currentHash, remoteHash, data, prefix = "") => {
      return {
        status,
        data: typeof data === "string" ? data : `${prefix}${data.message || data.stack || "\u672A\u77E5\u9519\u8BEF"}`,
        hash: {
          before: currentHash,
          after: remoteHash
        }
      };
    };
    gitPull = async (cwd, options = {}) => {
      try {
        const currentHash = await getLocalCommitHash(cwd);
        const remoteHash = await getRemoteCommitHash(cwd);
        if (currentHash === remoteHash) {
          return pullResult(false, currentHash, remoteHash, "\u5F53\u524D\u5DF2\u7ECF\u662F\u6700\u65B0\u7248\u672C");
        }
        if (options.force) {
          const remote = options.remote || "origin/HEAD";
          const fetchResult = await exec2("git fetch origin", { cwd, ...options });
          if (fetchResult.error) {
            return pullResult(false, currentHash, remoteHash, fetchResult.error, "\u540C\u6B65\u8FDC\u7A0B\u5206\u652F\u5931\u8D25: ");
          }
          const resetResult = await exec2(`git reset --hard ${remote}`, { cwd, ...options });
          if (resetResult.error) {
            return pullResult(false, currentHash, remoteHash, resetResult.error, "\u5F3A\u5236\u540C\u6B65\u8FDC\u7A0B\u5206\u652F\u5931\u8D25: ");
          }
          const hash2 = await getLocalCommitHash(cwd);
          return pullResult(true, currentHash, hash2, "\u672C\u5730\u5206\u652F\u5DF2\u5F3A\u5236\u4E0E\u8FDC\u7A0B\u5206\u652F\u540C\u6B65");
        }
        const cmd = options.customCmd || "git pull";
        const { error } = await exec2(cmd, { ...options, cwd });
        if (error) {
          return pullResult(false, currentHash, remoteHash, error, "\u66F4\u65B0\u5931\u8D25: ");
        }
        const hash = await getLocalCommitHash(cwd);
        return pullResult(true, currentHash, hash, "\u66F4\u65B0\u6210\u529F");
      } catch (error) {
        return pullResult(false, "", "", error.message, "\u53D1\u751F\u9519\u8BEF: ");
      }
    };
  }
});

// src/utils/git/index.ts
var init_git = __esm({
  "src/utils/git/index.ts"() {
    init_branch();
    init_pull();
  }
});
var initLogger, addColor, createLogger, logger2;
var init_logger = __esm({
  "src/service/logger/index.ts"() {
    init_root();
    initLogger = () => {
      const level = process.env.LOG_LEVEL || "info";
      const daysToKeep = Number(process.env.LOG_DAYS_TO_KEEP) || 30;
      const config3 = {
        appenders: {
          console: {
            type: "console",
            layout: {
              type: "pattern",
              pattern: `%[[Karin][%d{hh:mm:ss.SSS}][%4.4p]%] ${process.env.RUNTIME === "tsx" ? "[%f{3}:%l] " : ""}%m`
            }
          },
          overall: {
            /** 输出到文件 */
            type: "dateFile",
            /** 日志文件名 */
            filename: "@karinjs/logs/logger",
            /** 日期后缀 */
            pattern: "yyyy-MM-dd.log",
            /** 日期后缀 */
            keepFileExt: true,
            /** 日志文件名中包含日期模式 */
            alwaysIncludePattern: true,
            /** 日志文件保留天数 */
            numBackups: daysToKeep,
            /** 日期后缀分隔符 */
            fileNameSep: ".",
            /** 压缩 */
            // compress: true,
            /** 日志输出格式 */
            layout: {
              type: "pattern",
              pattern: "[%d{hh:mm:ss.SSS}][%4.4p] %m"
            }
          },
          errorFile: {
            /** 输出到文件 */
            type: "dateFile",
            /** 日志文件名 */
            filename: "@karinjs/logs/error/logger",
            /** 日期后缀 */
            pattern: "yyyy-MM-dd.log",
            /** 日期后缀 */
            alwaysIncludePattern: true,
            /** 日志文件保留天数 */
            numBackups: daysToKeep,
            /** 压缩 */
            // compress: true,
            /** 保留文件扩展名 */
            keepFileExt: true,
            /** 日期后缀分隔符 */
            fileNameSep: ".",
            /** 日志输出格式 */
            layout: {
              type: "pattern",
              pattern: "[%d{hh:mm:ss.SSS}][%4.4p] %m"
            }
          },
          errors: {
            /** 错误日志过滤器 */
            type: "logLevelFilter",
            /** 目标appender */
            appender: "errorFile",
            /** 只记录错误级别及以上的日志 */
            level: "error"
          }
        },
        categories: {
          default: {
            appenders: ["console", "overall", "errors"],
            level,
            enableCallStack: process.env.RUNTIME === "tsx"
          }
        },
        levels: {
          handler: { value: 15e3, colour: "cyan" }
        }
      };
      return log4js.configure(config3);
    };
    addColor = (Logger, color) => {
      const logger3 = Logger;
      logger3.chalk = chalk2;
      logger3.red = chalk2.red;
      logger3.green = chalk2.green;
      logger3.yellow = chalk2.yellow;
      logger3.blue = chalk2.blue;
      logger3.magenta = chalk2.magenta;
      logger3.cyan = chalk2.cyan;
      logger3.white = chalk2.white;
      logger3.gray = chalk2.gray;
      logger3.violet = chalk2.hex("#868ECC");
      logger3.fnc = chalk2.hex(color || "#FFFF00");
      logger3.bot = (level, id, ...args) => {
        switch (level) {
          case "trace":
            return logger3.trace(logger3.violet(`[Bot:${id}]`), ...args);
          case "debug":
            return logger3.debug(logger3.violet(`[Bot:${id}]`), ...args);
          case "mark":
            return logger3.mark(logger3.violet(`[Bot:${id}]`), ...args);
          case "info":
            return logger3.info(logger3.violet(`[Bot:${id}]`), ...args);
          case "warn":
            return logger3.warn(logger3.violet(`[Bot:${id}]`), ...args);
          case "error":
            return logger3.error(logger3.violet(`[Bot:${id}]`), ...args);
          case "fatal":
            return logger3.fatal(logger3.violet(`[Bot:${id}]`), ...args);
          default:
            return logger3.info(logger3.violet(`[Bot:${id}]`), ...args);
        }
      };
      return logger3;
    };
    createLogger = () => {
      const dir = karinPathLogs;
      if (!fs5.existsSync(dir)) fs5.mkdirSync(dir, { recursive: true });
      initLogger();
      const logger3 = addColor(log4js.getLogger("default"));
      global.logger = logger3;
      return logger3;
    };
    logger2 = createLogger();
  }
});

// src/utils/logger/logger.ts
var init_logger2 = __esm({
  "src/utils/logger/logger.ts"() {
    init_logger();
  }
});
var raceRequest, pingRequest, raceMode, standardMode, getFastRegistry, getPackageJson;
var init_race = __esm({
  "src/utils/request/race.ts"() {
    raceRequest = async (urls, config3 = {
      method: "HEAD",
      timeout: 2e3,
      successCodes: [200]
    }) => {
      const successCodes = Array.isArray(config3.successCodes) && config3.successCodes.length > 0 ? config3.successCodes : [200];
      const requests = urls.map(
        (url) => new Promise((resolve, reject) => {
          axios8.request({ ...config3, url, timeout: config3.timeout || 2e3 }).then((response) => {
            if (successCodes.includes(response.status)) {
              resolve(response);
            } else {
              reject(new Error(`\u54CD\u5E94\u72B6\u6001\u7801 ${response.status} \u4E0D\u5728 successCodes \u8303\u56F4\u5185`));
            }
          }).catch(reject);
        })
      );
      try {
        const result = await Promise.any(requests);
        return result;
      } catch {
        return null;
      }
    };
    pingRequest = async (urls, config3 = {
      timeout: 2e3,
      successCodes: [200],
      detailed: false,
      isRace: false
    }) => {
      config3.timeout = typeof config3.timeout === "number" ? config3.timeout : 2e3;
      config3.successCodes = Array.isArray(config3.successCodes) && config3.successCodes.length > 0 ? config3.successCodes : [200];
      config3.detailed = typeof config3.detailed === "boolean" ? config3.detailed : false;
      config3.isRace = typeof config3.isRace === "boolean" ? config3.isRace : false;
      const sendRequest = async (url) => {
        const startTime = Date.now();
        try {
          const response = await axios8.request({ ...config3, url });
          const duration = Date.now() - startTime;
          if (!config3.successCodes.includes(response.status)) {
            throw new Error(`\u8BF7\u6C42\u5931\u8D25: ${response.status}`, { cause: response });
          }
          return { url, success: true, duration, error: null };
        } catch (error) {
          const duration = Date.now() - startTime;
          return { url, success: false, duration, error };
        }
      };
      if (config3.isRace) {
        const raceResult = await raceMode(urls, sendRequest, config3.detailed);
        return raceResult;
      }
      const result = await standardMode(urls, sendRequest, config3.detailed);
      return result;
    };
    raceMode = async (urls, sendRequest, detailed) => {
      return new Promise((resolve) => {
        let pendingCount = urls.length;
        urls.forEach(async (url) => {
          const res = await sendRequest(url);
          if (res.success) {
            if (detailed) {
              resolve(res);
            } else {
              resolve(url);
            }
            return;
          }
          pendingCount--;
          if (pendingCount === 0) {
            resolve(null);
          }
        });
      });
    };
    standardMode = async (urls, sendRequest, detailed) => {
      const results = await Promise.all(urls.map(sendRequest));
      const sortedResults = [...results].sort((a, b) => a.duration - b.duration);
      if (detailed) {
        return sortedResults;
      }
      const successUrls = sortedResults.filter((item) => item.success).map((item) => item.url);
      return successUrls;
    };
    getFastRegistry = async () => {
      const urls = [
        "https://registry.npmmirror.com",
        "https://registry.npmjs.com",
        "https://mirrors.cloud.tencent.com/npm"
      ];
      try {
        const result = await raceRequest(urls);
        return result?.config.url || urls[0];
      } catch (error) {
        console.error("\u83B7\u53D6\u6700\u5FEB\u7684npm registry\u5931\u8D25:", error);
        return urls[0];
      }
    };
    getPackageJson = async (owner, repo) => {
      try {
        const urls = [
          `https://jsd.cdn.zzko.cn/gh/${owner}/${repo}/package.json`,
          `https://jsd.onmicrosoft.cn/gh/${owner}/${repo}/package.json`,
          `https://raw.github.com/${owner}/${repo}/HEAD/package.json`,
          `https://gitproxy.click/https://raw.githubusercontent.com/${owner}/${repo}/HEAD/package.json`,
          `https://gh.qninq.cn/https://raw.githubusercontent.com/${owner}/${repo}/HEAD/package.json`,
          `https://github.starrlzy.cn/https://raw.githubusercontent.com/${owner}/${repo}/HEAD/package.json`,
          `https://gh-proxy.ygxz.in/https://raw.githubusercontent.com/${owner}/${repo}/HEAD/package.json`
        ];
        const result = await raceRequest(urls);
        return result?.data || { version: "0.0.0" };
      } catch (error) {
        console.error("\u83B7\u53D6package.json\u5931\u8D25:", error);
        return { version: "0.0.0" };
      }
    };
  }
});
var buildGithub, parseGithubUrl, getFastGithub;
var init_github = __esm({
  "src/utils/request/github.ts"() {
    init_race();
    buildGithub = (proxy) => {
      return {
        proxy,
        isClone: true,
        isRaw: true,
        raw: function(url) {
          return `${this.proxy}/${url}`;
        },
        clone: function(url) {
          return `${this.proxy}/${url}`;
        }
      };
    };
    parseGithubUrl = (url) => {
      const urlObj = new URL$1(url);
      const owner = urlObj.pathname.split("/")[1];
      const repo = urlObj.pathname.split("/")[2];
      const path36 = urlObj.pathname.split("/").slice(3).join("/");
      return { owner, repo, path: path36 };
    };
    getFastGithub = async (type) => {
      const list2 = [
        {
          proxy: "https://github.com",
          isClone: true,
          isRaw: true,
          raw: function(url) {
            return url;
          },
          clone: function(url) {
            return url;
          }
        },
        {
          proxy: "https://jsd.cdn.zzko.cn/gh",
          isClone: false,
          isRaw: true,
          raw: function(url) {
            const { owner, repo, path: path36 } = parseGithubUrl(url);
            return `${this.proxy}/${owner}/${repo}/${path36}`;
          },
          clone: function(url) {
            const { owner, repo } = parseGithubUrl(url);
            return `${this.proxy}/${owner}/${repo}`;
          }
        },
        {
          proxy: "https://jsd.onmicrosoft.cn/gh",
          isClone: false,
          isRaw: true,
          raw: function(url) {
            const { owner, repo, path: path36 } = parseGithubUrl(url);
            return `${this.proxy}/${owner}/${repo}/${path36}`;
          },
          clone: function(url) {
            const { owner, repo } = parseGithubUrl(url);
            return `${this.proxy}/${owner}/${repo}`;
          }
        },
        buildGithub("https://gitproxy.click"),
        buildGithub("https://gh.qninq.cn"),
        buildGithub("https://github.starrlzy.cn"),
        buildGithub("https://gh-proxy.ygxz.in")
      ];
      const urls = [];
      list2.forEach((item) => {
        if (type === "raw" && item.isRaw) {
          urls.push(item);
        } else if (type === "clone" && item.isClone) {
          urls.push(item);
        }
      });
      const rawUrl = "https://raw.githubusercontent.com/github/docs/refs/heads/main/README.md";
      const gitCloneUrl = "https://github.com/github/docs.git";
      const pingUrls = [];
      const map = {};
      urls.forEach((item) => {
        const url = type === "raw" ? item.raw(rawUrl) : item.clone(gitCloneUrl);
        pingUrls.push(url);
        map[url] = item;
      });
      const result = await pingRequest(pingUrls, { detailed: true, isRace: true });
      if (!result) {
        return list2[0];
      }
      return map[result.url];
    };
  }
});

// src/utils/request/index.ts
var init_request5 = __esm({
  "src/utils/request/index.ts"() {
    init_race();
    init_github();
  }
});
var createINIParser, ini;
var init_ini = __esm({
  "src/utils/ini/index.ts"() {
    createINIParser = () => {
      const parseINIContent = (content) => {
        const result = {};
        const lines = content.split(/\r?\n/);
        for (const line of lines) {
          const trimmedLine = line.trim();
          if (!trimmedLine || trimmedLine.startsWith("#") || trimmedLine.startsWith(";")) {
            continue;
          }
          const separatorIndex = trimmedLine.indexOf("=");
          if (separatorIndex !== -1) {
            const key = trimmedLine.slice(0, separatorIndex).trim();
            const value = trimmedLine.slice(separatorIndex + 1).trim();
            if (key) {
              result[key] = value;
            }
          }
        }
        return result;
      };
      const stringifyINI = (data) => {
        return Object.entries(data).map(([key, value]) => `${key}=${value}`).join("\n");
      };
      return {
        /**
         * 从指定路径读取并解析INI文件
         * @param filePath - 文件路径
         * @returns 解析后的键值对对象
         */
        read: (filePath) => {
          try {
            const resolvedPath = path.resolve(filePath);
            if (!fs24.existsSync(resolvedPath)) {
              return {};
            }
            const content = fs24.readFileSync(resolvedPath, "utf-8");
            return parseINIContent(content);
          } catch (error) {
            console.error(`\u8BFB\u53D6INI\u6587\u4EF6\u5931\u8D25: ${error}`);
            return {};
          }
        },
        /**
         * 将键值对对象保存到指定路径
         * @param data - 要保存的键值对数据
         * @param filePath - 保存的文件路径
         * @returns 是否保存成功
         */
        write: (data, filePath) => {
          try {
            const resolvedPath = path.resolve(filePath);
            const content = stringifyINI(data);
            const dirname = path.dirname(resolvedPath);
            if (!fs24.existsSync(dirname)) {
              fs24.mkdirSync(dirname, { recursive: true });
            }
            fs24.writeFileSync(resolvedPath, content, "utf-8");
            return true;
          } catch (error) {
            console.error(`\u4FDD\u5B58INI\u6587\u4EF6\u5931\u8D25: ${error}`);
            return false;
          }
        }
      };
    };
    ini = createINIParser();
  }
});

// src/utils/index.ts
var init_utils = __esm({
  "src/utils/index.ts"() {
    init_button();
    init_fs2();
    init_git();
    init_logger2();
    init_system2();
    init_message2();
    init_request5();
    init_ini();
    init_fs2();
    init_system2();
    init_common();
    init_config();
    init_changelog();
  }
});

// src/plugin/tools.ts
var createLogger2, createFile, createPkg2;
var init_tools2 = __esm({
  "src/plugin/tools.ts"() {
    createLogger2 = (enable, isBot) => {
      if (isBot) {
        const fnc2 = enable === false ? (id, log3) => logger.bot("debug", id, log3) : (id, log3) => logger.bot("mark", id, log3);
        return fnc2;
      }
      return enable === false ? (log3) => logger.debug(log3) : (log3) => logger.mark(log3);
    };
    createFile = (type, name) => {
      return {
        absPath: "",
        basename: "",
        dirname: "",
        method: "",
        type,
        name
      };
    };
    createPkg2 = () => {
      return {
        name: "",
        apps: [],
        dir: "",
        id: -1,
        pkgData: {},
        pkgPath: "",
        type: "app",
        allApps: []
      };
    };
  }
});
var seq, pkgLoads, loadMainFile, pkgLoadModule, isType, pkgCache, createFile2, cacheClassPlugin, findPkgByFile, pkgSort, pkgHotReload;
var init_load = __esm({
  "src/plugin/admin/load.ts"() {
    init_env2();
    init_cache();
    init_utils();
    init_tools2();
    init_class();
    init_file();
    init_import();
    init_internal();
    init_list();
    seq = 0;
    pkgLoads = async (pkg2, allPromises) => {
      pkg2.id = ++seq;
      cache3.index[pkg2.id] = pkg2;
      const files = [];
      if (pkg2.type === "app") {
        files.push("config", "data", "resources");
      } else if (Array.isArray(pkg2.pkgData.karin?.files)) {
        files.push(...pkg2.pkgData.karin.files);
      }
      await createPluginDir(pkg2.name, files);
      if (pkg2.type !== "app") {
        const main2 = pkg2.type === "npm" || !isTs() ? await loadMainFile(pkg2, pkg2.pkgData?.main) : await loadMainFile(pkg2, pkg2.pkgData?.karin?.main);
        if (main2 && main2.KARIN_PLUGIN_INIT) {
          try {
            await main2.KARIN_PLUGIN_INIT();
            logger.debug(`[load][${pkg2.name}] \u63D2\u4EF6\u6267\u884CKARIN_PLUGIN_INIT\u51FD\u6570\u6210\u529F`);
          } catch (error) {
            logger.error(new Error(`[load][${pkg2.name}] \u63D2\u4EF6\u6267\u884CKARIN_PLUGIN_INIT\u51FD\u6570\u5931\u8D25`, { cause: error }));
          }
        }
      }
      pkg2.apps.forEach((app5) => {
        const promise = async () => {
          const result = await pkgLoadModule(pkg2.name, app5);
          pkgCache(result, pkg2, app5);
        };
        allPromises.push(promise());
      });
      if (pkg2.type !== "app" && pkg2?.pkgData?.karin?.static) {
        const list2 = Array.isArray(pkg2.pkgData.karin.static) ? pkg2.pkgData.karin.static : [pkg2.pkgData.karin.static];
        cache3.static.push(...list2.map((file2) => path4.resolve(pkg2.dir, file2)));
      } else {
        cache3.static.push(path4.resolve(pkg2.dir, "resource"));
        cache3.static.push(path4.resolve(pkg2.dir, "resources"));
      }
    };
    loadMainFile = async (pkg2, dir) => {
      if (!dir) return;
      const file2 = path4.join(pkg2.dir, dir);
      if (fs5.existsSync(file2)) {
        return pkgLoadModule(pkg2.name, file2);
      }
      return null;
    };
    pkgLoadModule = async (name, file2, isRefresh = false) => {
      const { status, data } = await importModule(file2, isRefresh);
      if (status) return data;
      logger.debug(new Error(`\u52A0\u8F7D\u6A21\u5757\u5931\u8D25: ${name} ${file2}`, { cause: data }));
      errorHandler.loaderPlugin(name, file2, data);
      return {};
    };
    isType = (val, type) => {
      return val.file?.type === type;
    };
    pkgCache = (result, pkg2, app5) => {
      const cacheHandler = (val, key) => {
        if (typeof val !== "object") return;
        if (!val?.pkg || !val.file) return;
        val.pkg = pkg2;
        val.file = createFile2(app5, val.file.type, key, val.file.name);
        if (isType(val, "accept")) {
          cache3.count.accept++;
          cache3.accept.push(val);
          return;
        }
        if (isType(val, "command")) {
          cache3.count.command++;
          cache3.command.push(val);
          return;
        }
        if (isType(val, "button")) {
          cache3.count.button++;
          cache3.button.push(val);
          return;
        }
        if (isType(val, "handler")) {
          if (!cache3.handler[val.key]) {
            cache3.count.handler.key++;
            cache3.handler[val.key] = [];
          }
          cache3.count.handler.fnc++;
          cache3.handler[val.key].push(val);
          return;
        }
        if (isType(val, "task")) {
          val.schedule = schedule.scheduleJob(val.cron, async () => {
            try {
              val.log(`[\u5B9A\u65F6\u4EFB\u52A1][${val.name}][${val.cron}]: \u5F00\u59CB\u6267\u884C`);
              const result2 = val.fnc();
              if (util5.types.isPromise(result2)) await result2;
              val.log(`[\u5B9A\u65F6\u4EFB\u52A1][${val.name}][${val.cron}]: \u6267\u884C\u5B8C\u6210`);
            } catch (error) {
              errorHandler.taskStart(val.name, val.name, error);
            }
          });
          cache3.count.task++;
          cache3.task.push(val);
        }
      };
      for (const key of Object.keys(result)) {
        if (key === "default") continue;
        if (typeof result[key] === "function") {
          if (!isClass(result[key])) continue;
          cacheClassPlugin(result[key], pkg2, app5, key);
          continue;
        }
        const data = result[key];
        for (const val of Array.isArray(data) ? data : [data]) {
          cacheHandler(val, key);
        }
      }
    };
    createFile2 = (app5, type, method, name) => {
      return {
        absPath: app5,
        get dirname() {
          return path4.dirname(this.absPath);
        },
        get basename() {
          return path4.basename(this.absPath);
        },
        type,
        method,
        name: name || type
      };
    };
    cacheClassPlugin = (Method, pkg2, app5, _) => {
      const command2 = new Method();
      if (!command2.name) {
        logger.error(`[load][${app5}] plugin.name \u4E0D\u80FD\u4E3A\u7A7A`);
        return;
      }
      if (!command2.rule || !Array.isArray(command2.rule) || command2.rule?.length === 0) {
        logger.error(`[load][${app5}] ${command2.name} plugin.rule \u4E0D\u80FD\u4E3A\u7A7A`);
        return;
      }
      command2.rule.forEach((v) => {
        if (!(v.fnc in command2)) return;
        if (typeof v.reg !== "string" && !(v.reg instanceof RegExp)) return;
        cache3.command.push({
          pkg: pkg2,
          type: "class",
          log: createLogger2(v.log, true),
          adapter: v.adapter || [],
          dsbAdapter: v.dsbAdapter || [],
          Cls: Method,
          reg: v.reg instanceof RegExp ? v.reg : new RegExp(v.reg),
          permission: v.permission || "all",
          event: v.event || command2.event || "message",
          priority: v.priority || 1e4,
          file: createFile2(app5, "command", v.fnc, command2.name),
          authFailMsg: v.authFailMsg || true
        });
      });
    };
    findPkgByFile = (file2) => {
      file2 = formatPath(file2);
      return Object.values(cache3.index).find(
        (pkg2) => pkg2.apps.includes(file2) || pkg2.allApps.some((dir) => file2.startsWith(dir)) || /**
         * 第三种情况
         * - 例如karin-plugin-example文件夹为空 则需要判断pkg是否为app类型
         * - 并且文件是否处于karin-plugin-example文件夹下
         */
        pkg2.type === "app" && path4.normalize(file2).startsWith(path4.normalize(pkg2.dir))
      ) || null;
    };
    pkgSort = () => {
      cache3.accept = lodash3.sortBy(cache3.accept, ["rank"], ["asc"]);
      cache3.command = lodash3.sortBy(cache3.command, ["rank"], ["asc"]);
      cache3.task = lodash3.sortBy(cache3.task, ["rank"], ["asc"]);
      cache3.button = lodash3.sortBy(cache3.button, ["rank"], ["asc"]);
      for (const key of Object.keys(cache3.handler)) {
        cache3.handler[key] = lodash3.sortBy(cache3.handler[key], ["rank"], ["asc"]);
      }
    };
    pkgHotReload = async (type, name) => {
      const allPromises = [];
      const pkg2 = await getPluginsInfo([`${type}:${name}`], true, true);
      if (pkg2.length === 0) {
        throw new Error(`[load][${type}:${name}] \u63D2\u4EF6\u4E0D\u5B58\u5728`);
      }
      await pkgLoads(pkg2[0], allPromises);
      await Promise.allSettled(allPromises);
      allPromises.length = 0;
      pkgSort();
    };
  }
});

// src/core/db/index.ts
var init_db = __esm({
  "src/core/db/index.ts"() {
    init_redis3();
    init_mock2();
    init_kv();
  }
});
var createHttpRenderClient;
var init_http2 = __esm({
  "src/adapter/render/connect/http.ts"() {
    init_cache4();
    init_render();
    createHttpRenderClient = () => {
      const cfg = getRenderCfg();
      if (!cfg.http_server || !Array.isArray(cfg.http_server) || cfg.http_server.length === 0) {
        logger.trace("[render][http] \u672A\u914D\u7F6E\u4EFB\u4F55\u6B63\u5411HTTP \u5DF2\u8DF3\u8FC7\u521B\u5EFA");
        return;
      }
      return Promise.allSettled(cfg.http_server.map(async (item) => {
        let { url, token, enable, isSnapka } = item;
        if (!enable || isSnapka) return;
        url = url.replace("/puppeteer", "");
        const headers = { authorization: crypto.createHash("md5").update(`Bearer ${token}`).digest("hex") };
        try {
          const result = await axios8.get(`${url}/ping`, { timeout: 5e3 });
          if (result.status !== 200 || String(result.data.status) !== "200") {
            logger.error(`[render][http] \u521B\u5EFA\u6E32\u67D3\u5668\u5931\u8D25: \u65E0\u6CD5\u8FDE\u63A5 ${url}`);
          }
          const auth3 = await axios8.get(`${url}/auth`, { headers, timeout: 5e3 });
          if (auth3.status !== 200 || String(auth3.data.status) !== "200") {
            logger.error(`[render][http] \u521B\u5EFA\u6E32\u67D3\u5668\u5931\u8D25: \u9274\u6743\u9519\u8BEF ${url}`);
            return;
          }
        } catch (error) {
          if (axios8.isAxiosError(error)) {
            const { response } = error;
            logger.error(`[render][http] \u521B\u5EFA\u6E32\u67D3\u5668\u5931\u8D25: ${response?.status} ${response?.statusText} - ${JSON.stringify(response?.data || "\u672A\u77E5\u9519\u8BEF")}`);
          } else {
            logger.error(`[render][http] \u521B\u5EFA\u6E32\u67D3\u5668\u5931\u8D25: ${error}`);
          }
          return;
        }
        const index6 = registerRender("puppeteer", async (options) => {
          try {
            const result = await axios8.post(`${url}/puppeteer`, options, { headers });
            if (result.status !== 200) {
              throw new Error(`[render][http] \u6E32\u67D3\u5931\u8D25: ${result.status} ${result.statusText} - ${result.data?.message || "\u672A\u77E5\u9519\u8BEF"}`);
            }
            return result.data;
          } catch (error) {
            if (axios8.isAxiosError(error)) {
              if (!error.response) {
                unregisterRender(index6);
                throw new Error(`[render][http] \u7F51\u7EDC\u8FDE\u63A5\u5931\u8D25: ${error.message}`);
              }
              const { response } = error;
              throw new Error(`[render][http] \u6E32\u67D3\u5931\u8D25: ${response?.status} ${response?.statusText} - ${JSON.stringify(response?.data || "\u672A\u77E5\u9519\u8BEF")}`);
            }
            if (error instanceof Error) {
              throw error;
            }
            throw new Error(`[render][unknown] \u672A\u77E5\u9519\u8BEF: ${error}`);
          }
        });
      }));
    };
  }
});
var WebSocketRender;
var init_ws = __esm({
  "src/adapter/render/connect/ws.ts"() {
    init_template();
    init_cache4();
    init_static();
    WebSocketRender = class {
      /** websocket实例 */
      socket;
      /** 唯一标识符 */
      echo = 0;
      /** 索引 */
      index;
      constructor(socket) {
        this.socket = socket;
        this.index = -1;
      }
      async init() {
        this.socket.on("close", () => {
          unregisterRender(this.index);
          this.socket.removeAllListeners();
          this.socket.close();
        });
        this.socket.on("message", (event) => {
          const raw2 = event.toString();
          const { echo, action, status, data } = JSON.parse(raw2);
          logger.debug(`[WebSocket] ${echo} ${action} ${status}`);
          logger.trace(`[WebSocket] ${echo} ${raw2}`);
          if (action === "response") {
            this.socket.emit(echo, { action, status, data });
          } else if (action === "close") {
            logger.error(`[WebSocket] \u6536\u5230\u65AD\u5F00\u8FDE\u63A5\u8BF7\u6C42: ${raw2}`);
            this.socket.close();
          } else if (action === "static") {
            return this.static(echo, data);
          } else {
            logger.error(`[WebSocket] \u672A\u77E5\u7684\u8BF7\u6C42: ${raw2}`);
          }
        });
        this.index = registerRender("puppeteer", this.render.bind(this));
      }
      /**
       * @description 鉴权
       * @param token
       * @param targetToken 目标的token
       * @returns 是否鉴权成功
       */
      auth(token, targetToken) {
        if (token !== targetToken) {
          if (token.length !== 32) {
            token = crypto.createHash("md5").update(`Bearer ${token}`).digest("hex");
          }
          if (targetToken.length !== 32) {
            targetToken = crypto.createHash("md5").update(`Bearer ${targetToken}`).digest("hex");
          }
          if (token !== targetToken) {
            return false;
          }
        }
        return true;
      }
      /**
       * @description 处理静态资源请求
       * @param echo 唯一标识符
       * @param data 数据
       */
      async static(echo, data) {
        const result = isPublic(data.file);
        if (!result) {
          logger.warn(`[WebSocket] \u8BBF\u95EE\u7684\u8DEF\u5F84\u975E\u6CD5: echo: ${echo} data: ${JSON.stringify(data)}`);
          return this.socket.send(JSON.stringify({ echo, status: "error", data: "\u975E\u6CD5\u7684\u8BBF\u95EE\u8DEF\u5F84" }));
        }
        const fileData = fs5.readFileSync(data.file);
        return this.socket.send(JSON.stringify({ echo, status: "ok", data: fileData }));
      }
      render(data) {
        const options = renderTpl(data);
        return this.sendApi("render", options);
      }
      async sendApi(action, data) {
        const echo = ++this.echo;
        const str = JSON.stringify({ echo, action, data });
        logger.debug(`[sendApi][WebSocket] ${echo} ${action} ${str}`);
        this.socket.send(str);
        return new Promise((resolve, reject) => {
          const timeoutId = setTimeout(() => {
            reject(new Error(`[sendApi] \u8BF7\u6C42\u9519\u8BEF:
  action: ${action}
  params: ${str}
  error: \u8BF7\u6C42\u8D85\u65F6}`));
          }, 120 * 1e3);
          this.socket.once(echo + "", ({ status, data: data2 }) => {
            clearTimeout(timeoutId);
            if (status === "ok") {
              return resolve(data2);
            }
            reject(new Error(`[sendApi] \u8BF7\u6C42\u9519\u8BEF:
  action: ${action}
  params: ${str}`, { cause: data2 }));
          });
        });
      }
    };
  }
});
var WebSocketClientRenderer, createWebSocketRenderClient;
var init_client2 = __esm({
  "src/adapter/render/connect/client.ts"() {
    init_ws();
    init_render();
    WebSocketClientRenderer = class extends WebSocketRender {
      /** 重连次数 */
      reconnectCount = 0;
      /** 最大重连次数，设为-1表示无限重连 */
      maxReconnectAttempts = -1;
      /** 基连延迟(ms) */
      baseDelay = 5e3;
      /** WebSocket连接URL */
      url;
      /** 连接headers */
      headers;
      constructor(socket, url, headers) {
        super(socket);
        this.url = url;
        this.headers = headers;
      }
      /**
       * @description 重连逻辑
       * @param isPrint 是否打印日志
       */
      reconnect = (isPrint = false) => {
        if (this.maxReconnectAttempts !== -1 && this.reconnectCount >= this.maxReconnectAttempts) {
          logger.error(`[render][WebSocket] \u8FDE\u63A5\u5931\u8D25\u6B21\u6570\u8FC7\u591A(${this.reconnectCount}\u6B21), \u5DF2\u505C\u6B62\u91CD\u8FDE: ${this.url}`);
          return;
        }
        this.reconnectCount++;
        const delay = this.baseDelay;
        const delaySeconds = delay / 1e3;
        if (isPrint) {
          logger.warn(`[render][WebSocket][${this.reconnectCount}] \u8FDE\u63A5\u5931\u8D25\uFF0C${delaySeconds}\u79D2\u540E\u5C06\u91CD\u8FDE: ${this.url}`);
        }
        setTimeout(() => {
          try {
            const socket = new WebSocket(this.url, { headers: this.headers });
            this.socket = socket;
            socket.once("open", async () => {
              logger.info(`[render][WebSocket] \u8FDE\u63A5\u6210\u529F: ${this.url}`);
              await this.init();
              this.reconnectCount = 0;
            });
            socket.once("error", (error) => {
              logger.debug(error);
              logger.error(`[render][WebSocket][${this.reconnectCount}] \u8FDE\u63A5\u9519\u8BEF: ${error.message}\uFF0C${delaySeconds}\u79D2\u540E\u5C06\u91CD\u8FDE: ${this.url}`);
              socket.removeAllListeners();
              socket.close();
              this.reconnect(false);
            });
            socket.once("close", () => {
              this.reconnect(true);
            });
          } catch (error) {
            logger.debug(error);
            this.reconnect();
          }
        }, delay);
      };
    };
    createWebSocketRenderClient = () => {
      const cfg = getRenderCfg();
      if (!cfg.ws_client || !Array.isArray(cfg.ws_client) || cfg.ws_client.length === 0) {
        logger.trace("[render][WebSocket] \u672A\u914D\u7F6E\u4EFB\u4F55\u6B63\u5411WebSocket \u5DF2\u8DF3\u8FC7\u521B\u5EFA");
        return;
      }
      return Promise.allSettled(cfg.ws_client.map(async (item) => {
        const { url, token, enable, isSnapka } = item;
        if (!enable || isSnapka) return;
        const headers = { Authorization: crypto.createHash("md5").update(`Bearer ${token}`).digest("hex") };
        const socket = new WebSocket(url, { headers });
        const renderer = new WebSocketClientRenderer(socket, url, headers);
        socket.once("open", async () => {
          logger.info(`[render][WebSocket] \u8FDE\u63A5\u6210\u529F: ${url}`);
          await renderer.init();
        });
        socket.once("close", () => {
          renderer.reconnect(true);
        });
        socket.once("error", (error) => {
          logger.error(`[render][WebSocket] \u8FDE\u63A5\u9519\u8BEF: ${error.message}`);
          socket.close();
        });
      }));
    };
  }
});

// src/adapter/render/connect/server.ts
var server_exports = {};
__export(server_exports, {
  WebSocketServerRenderer: () => WebSocketServerRenderer
});
var WebSocketServerRenderer;
var init_server2 = __esm({
  "src/adapter/render/connect/server.ts"() {
    init_ws();
    init_internal();
    init_key2();
    WebSocketServerRenderer = class extends WebSocketRender {
      /** 请求实例 */
      request;
      constructor(socket, request3) {
        super(socket);
        this.request = request3;
      }
      connection() {
        const url = `ws://${this.request.headers.host}${this.request.url}`;
        if (process.env.WS_SERVER_AUTH_KEY) {
          const token = this.request.headers["authorization"];
          if (!token || !this.auth(process.env.WS_SERVER_AUTH_KEY, token)) {
            logger.error(`[WebSocket] \u9274\u6743\u5931\u8D25: authorization: ${token} url: ${url}`);
            this.socket.close();
            return false;
          }
        }
        logger.info(`[WebSocket] \u8FDE\u63A5\u6210\u529F: url: ${url}`);
        return true;
      }
    };
    listeners.on(WS_CONNECTION_PUPPETEER, (socket, request3, call2) => {
      call2();
      const server2 = new WebSocketServerRenderer(socket, request3);
      if (!server2.connection()) return;
      server2.init();
    });
  }
});

// src/adapter/render/index.ts
var initRender2;
var init_render2 = __esm({
  "src/adapter/render/index.ts"() {
    init_http2();
    init_client2();
    initRender2 = async () => {
      createHttpRenderClient();
      createWebSocketRenderClient();
      await Promise.resolve().then(() => (init_server2(), server_exports));
    };
  }
});

// src/server/log/index.ts
var logMiddleware;
var init_log = __esm({
  "src/server/log/index.ts"() {
    logMiddleware = async (req, _, next) => {
      logger.debug(
        `[express] \u6536\u5230\u8BF7\u6C42: 
method: ${req.method}
ip: ${req.ip}
path: ${req.path}
headers: ${JSON.stringify(req.headers)}
body: ${JSON.stringify(req.body)}
`
      );
      next();
    };
  }
});

// src/server/common/common.ts
var verifyToken, auth2;
var init_common2 = __esm({
  "src/server/common/common.ts"() {
    init_config();
    init_jwt();
    init_response();
    verifyToken = async (token, userId, res) => {
      if (!token) {
        createUnauthorizedResponse(res, "\u9274\u6743\u5931\u8D25: \u7F3A\u5C11authorization" /* MissingToken */);
        return false;
      }
      if (!userId) {
        if (authKey() === token) return true;
        createUnauthorizedResponse(res, "\u9274\u6743\u5931\u8D25: token\u9519\u8BEF" /* TokenError */);
        return false;
      }
      const verifyStatus = verifyJwt(token, userId);
      if (verifyStatus.status === 200 /* OK */) return true;
      if (authKey() === token) return true;
      switch (verifyStatus.status) {
        case 401 /* Unauthorized */:
          createUnauthorizedResponse(res, verifyStatus.data);
          return false;
        case 419 /* AccessTokenExpired */:
          createAccessTokenExpiredResponse(res);
          return false;
        case 500 /* InternalServerError */:
          createServerErrorResponse(res, verifyStatus.data);
          return false;
        default:
          createServerErrorResponse(res, "\u670D\u52A1\u5668\u5185\u90E8\u9519\u8BEF");
          return false;
      }
    };
    auth2 = {
      /**
       * get请求鉴权
       * @description 支持请求头中携带`Authorization`字段
       * @description 支持请求参数中携带`token`字段
       * @description 支持明文密码
       */
      getAuth: async (req, res) => {
        const token = req?.headers?.authorization?.replace("Bearer ", "") || req?.query?.token;
        const userId = req?.headers?.["x-user-id"];
        return verifyToken(token, userId, res);
      },
      /**
       * post请求鉴权
       * @description 仅支持请求头中携带`Authorization`字段
       * @description 除了支持jwt之外，还支持明文密码
       */
      postAuth: async (req, res) => {
        const token = req?.headers?.authorization?.replace("Bearer ", "");
        const userId = req?.headers?.["x-user-id"];
        return verifyToken(token, userId, res);
      },
      /**
       * 虚拟终端鉴权
       * @param token 令牌
       * @param userId 用户id
       * @returns 是否验证成功
       */
      terminalAuth: (token, userId) => {
        if (!token || !userId) {
          return false;
        }
        const verifyStatus = verifyJwt(token, userId);
        if (verifyStatus.status === 200 /* OK */) {
          return true;
        }
        return false;
      }
    };
  }
});

// src/server/auth/middleware.ts
var authMiddleware;
var init_middleware = __esm({
  "src/server/auth/middleware.ts"() {
    init_common2();
    init_response();
    authMiddleware = async (req, res, next) => {
      if (req.path === "/ping" || req.path === "/login" || req.path === "/refresh" || req.path.startsWith("/console")) {
        next();
        return;
      }
      if (req.method === "POST") {
        const verify2 = await auth2.postAuth(req, res);
        if (!verify2) return;
      } else if (req.method === "GET") {
        const verify2 = await auth2.getAuth(req, res);
        if (!verify2) return;
      } else {
        createMethodNotAllowedResponse(res);
        return;
      }
      next();
    };
  }
});

// src/server/auth/login.ts
var IP_LIMIT_CONFIG, ipRecords, cleanupIPRecords, checkIPBlocked, handleLoginFailure, handleLoginSuccess, validateCredentials, loginRouter;
var init_login = __esm({
  "src/server/auth/login.ts"() {
    init_response();
    init_jwt();
    IP_LIMIT_CONFIG = {
      /** 最大尝试次数 */
      maxAttempts: 5,
      /** 时间窗口 */
      timeWindow: 5 * 60 * 1e3,
      /** 封禁时长 */
      blockDuration: 30 * 60 * 1e3
    };
    ipRecords = /* @__PURE__ */ new Map();
    cleanupIPRecords = () => {
      const now = Date.now();
      for (const [ip, record2] of ipRecords.entries()) {
        if (record2.blockedUntil && record2.blockedUntil < now || now - record2.firstAttempt > IP_LIMIT_CONFIG.timeWindow) {
          ipRecords.delete(ip);
        }
      }
    };
    setInterval(cleanupIPRecords, 10 * 60 * 1e3);
    checkIPBlocked = (clientIP, res) => {
      const now = Date.now();
      const ipRecord = ipRecords.get(clientIP) || { attempts: 0, firstAttempt: now };
      if (ipRecord.blockedUntil && ipRecord.blockedUntil > now) {
        const additionalAttempts = ipRecord.attempts + 1 - IP_LIMIT_CONFIG.maxAttempts;
        const extraBlockTime = Math.min(
          IP_LIMIT_CONFIG.blockDuration * additionalAttempts,
          24 * 60 * 60 * 1e3
          // 最长封禁24小时
        );
        ipRecord.blockedUntil = now + extraBlockTime;
        ipRecord.attempts++;
        ipRecords.set(clientIP, ipRecord);
        const remainingTime = Math.ceil((ipRecord.blockedUntil - now) / 1e3 / 60);
        const tips2 = `\u767B\u5F55\u5C1D\u8BD5\u6B21\u6570\u8FC7\u591A,\u8BF7\u5728${remainingTime}\u5206\u949F\u540E\u91CD\u8BD5`;
        createForbiddenResponse(res, tips2);
        logger.warn(`${logger.red("login")}: ${clientIP} \u7EE7\u7EED\u5C1D\u8BD5\u767B\u5F55, \u5F53\u524D\u5C1D\u8BD5\u6B21\u6570:${ipRecord.attempts}, \u5C01\u7981\u65F6\u95F4\u5EF6\u957F\u81F3${remainingTime}\u5206\u949F`);
        return {
          isBlocked: true,
          ipRecord
        };
      }
      if (now - ipRecord.firstAttempt > IP_LIMIT_CONFIG.timeWindow) {
        ipRecord.attempts = 0;
        ipRecord.firstAttempt = now;
      }
      return { isBlocked: false, ipRecord };
    };
    handleLoginFailure = (clientIP, ipRecord, res) => {
      const now = Date.now();
      ipRecord.attempts++;
      if (ipRecord.attempts >= IP_LIMIT_CONFIG.maxAttempts) {
        ipRecord.blockedUntil = now + IP_LIMIT_CONFIG.blockDuration;
        ipRecords.set(clientIP, ipRecord);
        const remainingTime = Math.ceil(IP_LIMIT_CONFIG.blockDuration / 1e3 / 60);
        const tips2 = `\u767B\u5F55\u5C1D\u8BD5\u6B21\u6570\u8FC7\u591A,\u8BF7\u5728${remainingTime}\u5206\u949F\u540E\u91CD\u8BD5`;
        logger.warn(`${logger.red("login")}: ${clientIP} ${tips2}`);
        return createForbiddenResponse(res, tips2);
      }
      ipRecords.set(clientIP, ipRecord);
      logger.warn(`${logger.red("login")}: ${clientIP} \u5BC6\u7801\u9519\u8BEF`);
      return createBadRequestResponse(res, "\u5BC6\u7801\u9519\u8BEF");
    };
    handleLoginSuccess = (clientIP, res) => {
      ipRecords.delete(clientIP);
      const { userId, accessToken, refreshToken } = createJwt();
      return createSuccessResponse(res, { userId, accessToken, refreshToken }, "\u767B\u5F55\u6210\u529F");
    };
    validateCredentials = (authorization) => {
      const token = authorization?.replace("Bearer ", "");
      return token && token === getSecretOrPrivateKey();
    };
    loginRouter = async (req, res) => {
      try {
        const clientIP = req.ip || req.socket.remoteAddress || "unknown";
        logger.info(`${logger.green("login")}: ${clientIP} ${JSON.stringify(req.body)}`);
        const { isBlocked, ipRecord } = checkIPBlocked(clientIP, res);
        if (isBlocked) return;
        const { authorization } = req.body || {};
        const isValid = validateCredentials(authorization);
        if (!isValid) {
          handleLoginFailure(clientIP, ipRecord, res);
          return;
        }
        handleLoginSuccess(clientIP, res);
      } catch (error) {
        logger.error(error);
        createServerErrorResponse(res, error instanceof Error ? error.message : "\u670D\u52A1\u5668\u9519\u8BEF");
      }
    };
  }
});

// src/server/auth/refresh.ts
var refreshRouter;
var init_refresh = __esm({
  "src/server/auth/refresh.ts"() {
    init_jwt();
    init_response();
    refreshRouter = async (req, res) => {
      try {
        const { accessToken, refreshToken } = req.body || {};
        if (!accessToken || !refreshToken) return createBadRequestResponse(res);
        const { status, data } = verifyRefreshToken(refreshToken);
        if (!status) {
          if (data.includes("\u8FC7\u671F")) {
            return createRefreshTokenExpiredResponse(res);
          }
          return createUnauthorizedResponse(res, data);
        }
        const newAccessToken = refreshAccessToken(data);
        logger.mark(`[refresh] \u5237\u65B0\u8BBF\u95EE\u4EE4\u724C\u6210\u529F: ${accessToken} -> ${newAccessToken}`);
        createSuccessResponse(res, { accessToken: newAccessToken }, "\u5237\u65B0\u6210\u529F");
      } catch (error) {
        logger.error(error);
        createServerErrorResponse(res, error instanceof Error ? error.message : "\u670D\u52A1\u5668\u9519\u8BEF");
      }
    };
  }
});

// src/server/config/index.ts
var getConfig, saveConfig;
var init_config3 = __esm({
  "src/server/config/index.ts"() {
    init_root();
    init_response();
    init_config();
    getConfig = async (req, res) => {
      const { type } = req.body;
      if (type === "config") {
        const cfg = config2();
        return createSuccessResponse(res, cfg);
      }
      if (type === "adapter") {
        const cfg = adapter();
        return createSuccessResponse(res, cfg);
      }
      if (type === "groups") {
        const cfg = getGroupsFileData(karinPathConfig);
        return createSuccessResponse(res, cfg);
      }
      if (type === "privates") {
        const cfg = getPrivatesFileData(karinPathConfig);
        return createSuccessResponse(res, cfg);
      }
      if (type === "render") {
        const cfg = getRenderCfg();
        return createSuccessResponse(res, cfg);
      }
      if (type === "redis") {
        const cfg = redis();
        return createSuccessResponse(res, cfg);
      }
      if (type === "pm2") {
        const cfg = pm2();
        return createSuccessResponse(res, cfg);
      }
      if (type === "env") {
        const cfg = getEnv();
        return createSuccessResponse(res, cfg);
      }
      return createBadRequestResponse(res, "\u65E0\u6548\u7684\u914D\u7F6E\u7C7B\u578B");
    };
    saveConfig = async (req, res) => {
      const list2 = ["config", "adapter", "render", "pm2", "redis", "groups", "privates", "env"];
      const { type, data } = req.body;
      const save2 = () => {
        if (type === "env") {
          const result = Object.entries(data).map(([key, value]) => ({
            key,
            value: value.value,
            comment: value.comment
          }));
          writeEnv(result, void 0, true);
          return true;
        }
        if (list2.includes(type)) {
          return setConfig(type, data);
        }
        return false;
      };
      try {
        const result = save2();
        if (!result) {
          return createBadRequestResponse(res, "\u914D\u7F6E\u4FDD\u5B58\u5931\u8D25");
        }
        createSuccessResponse(res, "\u914D\u7F6E\u4FDD\u5B58\u6210\u529F");
      } catch (error) {
        logger.error(error);
        createServerErrorResponse(res, error.message);
      }
    };
  }
});

// src/server/system/ping.ts
var pingRouter;
var init_ping = __esm({
  "src/server/system/ping.ts"() {
    init_response();
    pingRouter = (_req, res) => {
      createSuccessResponse(
        res,
        {
          ping: "pong"
        },
        "\u6210\u529F"
      );
    };
  }
});
var fileExists, getWebConfigPathFromPkg, getNpmPluginConfigPath, getLocalPluginConfigPath, getConfigPath, loadConfig, getWebConfig, normalizeAuthor, pluginGetConfig, pluginSaveConfig, pluginIsConfigExist, getPluginType;
var init_config4 = __esm({
  "src/server/plugins/config.ts"() {
    init_env2();
    init_require();
    init_response();
    init_list();
    fileExists = (filepath) => {
      try {
        return fs5.existsSync(filepath);
      } catch (error) {
        return false;
      }
    };
    getWebConfigPathFromPkg = (pkg2, baseDir) => {
      if (!pkg2.karin) return null;
      if (baseDir.includes("node_modules")) {
        if (pkg2.karin.web) {
          const configPath3 = path4.join(baseDir, pkg2.karin.web);
          return fileExists(configPath3) ? configPath3 : null;
        }
        return null;
      }
      let configPath2 = null;
      if (isTs()) {
        if (pkg2.karin["ts-web"]) {
          configPath2 = path4.join(baseDir, pkg2.karin["ts-web"]);
          if (fileExists(configPath2)) return configPath2;
        }
      }
      if (pkg2.karin.web) {
        configPath2 = path4.join(baseDir, pkg2.karin.web);
        if (fileExists(configPath2)) return configPath2;
      }
      return null;
    };
    getNpmPluginConfigPath = (name) => {
      const dir = path4.join(process.cwd(), "node_modules", name);
      if (fileExists(dir)) {
        try {
          const pkgPath = path4.join(dir, "package.json");
          if (fileExists(pkgPath)) {
            const pkg2 = requireFileSync(pkgPath);
            const configPath2 = getWebConfigPathFromPkg(pkg2, dir);
            if (configPath2) return configPath2;
          }
        } catch (error) {
          return null;
        }
      }
      if (isDev()) {
        try {
          const rootPkgPath = path4.join(process.cwd(), "package.json");
          if (fileExists(rootPkgPath)) {
            const pkg2 = requireFileSync(rootPkgPath);
            if (pkg2?.name === name) {
              return getWebConfigPathFromPkg(pkg2, process.cwd());
            }
          }
        } catch (error) {
          return null;
        }
      }
      return null;
    };
    getLocalPluginConfigPath = (name) => {
      const pluginDir2 = path4.join(process.cwd(), "plugins", name);
      if (fileExists(pluginDir2)) {
        try {
          const pkgPath = path4.join(pluginDir2, "package.json");
          if (fileExists(pkgPath)) {
            const pkg2 = requireFileSync(pkgPath);
            const configPath2 = getWebConfigPathFromPkg(pkg2, pluginDir2);
            if (configPath2) return configPath2;
          }
        } catch (error) {
          return null;
        }
      }
      try {
        const pkgPath = path4.join(process.cwd(), "package.json");
        if (fileExists(pkgPath)) {
          const pkg2 = requireFileSync(pkgPath);
          return getWebConfigPathFromPkg(pkg2, process.cwd());
        }
      } catch (error) {
        return null;
      }
      return null;
    };
    getConfigPath = (type, name) => {
      try {
        switch (type) {
          case "npm":
            return getNpmPluginConfigPath(name);
          case "git":
            return getLocalPluginConfigPath(name);
          default:
            return null;
        }
      } catch (error) {
        return null;
      }
    };
    loadConfig = async (configPath2) => {
      try {
        const fileUrl = pathToFileURL(configPath2).toString();
        const result = await import(`${fileUrl}${isDev() ? "?t=" + Date.now() : ""}`);
        return result.default;
      } catch (error) {
        throw new Error(`\u52A0\u8F7D\u63D2\u4EF6\u914D\u7F6E\u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`);
      }
    };
    getWebConfig = async (type, id, _) => {
      if (!["git", "npm"].includes(type)) {
        return null;
      }
      const webConfig = getConfigPath(type, id);
      if (!webConfig) {
        return null;
      }
      const baseName = path4.basename(webConfig, path4.extname(webConfig));
      if (baseName !== "web.config") {
        return null;
      }
      const result = await loadConfig(webConfig);
      if (!result.info.version || !result.info.description) {
        let dir = "";
        if (type === "npm") {
          dir = path4.join(process.cwd(), "node_modules", id);
        } else {
          dir = path4.join(process.cwd(), "plugins", id);
          if (!fs5.existsSync(dir)) {
            dir = process.cwd();
          }
        }
        const pkg2 = requireFileSync(path4.join(dir, "package.json"));
        if (!pkg2 || pkg2.name !== id) {
          if (!result.info.version) result.info.version = "";
          if (!result.info.description) result.info.description = "";
        } else {
          if (!result.info.version && pkg2.version !== void 0) {
            result.info.version = pkg2.version;
          } else {
            result.info.version = "";
          }
          if (!result.info.description) result.info.description = "";
        }
      }
      return result;
    };
    normalizeAuthor = (author) => {
      const list2 = [];
      if (Array.isArray(author)) {
        list2.push(...author);
      } else if (author) {
        list2.push(author);
      }
      return list2;
    };
    pluginGetConfig = async (req, res) => {
      const options = req.body;
      if (!options.name) {
        createServerErrorResponse(res, "\u53C2\u6570\u9519\u8BEF");
        return;
      }
      const type = await getPluginType(options.name);
      if (!type) return createServerErrorResponse(res, "\u53C2\u6570\u9519\u8BEF");
      const config3 = await getWebConfig(type, options.name, () => {
        logger.error(`[plugin] \u63D2\u4EF6${options.name}\u7684web\u914D\u7F6E\u6587\u4EF6\u540D\u79F0\u4E0D\u6B63\u786E: \u9700\u8981\u4EE5 web.config \u547D\u540D`);
        createSuccessResponse(res, null);
      });
      if (!config3) {
        return createServerErrorResponse(res, "\u53C2\u6570\u9519\u8BEF");
      }
      if (typeof config3.components !== "function") {
        return createServerErrorResponse(res, "\u8BE5\u63D2\u4EF6\u672A\u63D0\u4F9B\u9ED8\u8BA4\u7EC4\u4EF6\u914D\u7F6E\u51FD\u6570");
      }
      const list2 = [];
      let result = config3.components();
      result = util5.types.isPromise(result) ? await result : result;
      result.forEach((item) => {
        if (typeof item?.toJSON === "function") {
          list2.push(item.toJSON());
        } else {
          if (typeof item === "object" && item !== null) {
            list2.push(item);
          }
        }
      });
      const data = {
        options: list2,
        info: {
          ...config3.info,
          author: normalizeAuthor(config3.info.author)
        }
      };
      createSuccessResponse(res, data);
    };
    pluginSaveConfig = async (req, res) => {
      const { name, config: config3 } = req.body;
      const type = await getPluginType(name);
      if (!type) return createServerErrorResponse(res, "\u53C2\u6570\u9519\u8BEF");
      const configPath2 = getConfigPath(type, name);
      if (!configPath2) return createServerErrorResponse(res, "\u53C2\u6570\u9519\u8BEF");
      const { save: save2 } = await loadConfig(configPath2);
      if (typeof save2 !== "function") {
        return createServerErrorResponse(res, "\u8BE5\u63D2\u4EF6\u672A\u63D0\u4F9B\u9ED8\u8BA4\u7EC4\u4EF6\u4FDD\u5B58\u5B8C\u6210");
      }
      const result = save2(config3);
      const response = util5.types.isPromise(result) ? await result : result;
      createSuccessResponse(res, response || { success: true, message: "\u6CA1\u6709\u8FD4\u56DE\u503C\u54E6 \u03C6(>\u03C9<*) " });
    };
    pluginIsConfigExist = async (req, res) => {
      const name = req.body.name;
      const type = await getPluginType(name);
      if (!name || !type) {
        return createServerErrorResponse(res, "\u53C2\u6570\u9519\u8BEF");
      }
      const configPath2 = getConfigPath(type, name);
      createSuccessResponse(res, typeof configPath2 === "string");
    };
    getPluginType = async (name) => {
      const list2 = await getPlugins("all", false);
      const npmName = `npm:${name}`;
      const gitName = `git:${name}`;
      const rootName = `root:${name}`;
      for (const item of list2) {
        if (item === npmName) return "npm";
        if (item === gitName) return "git";
        if (item === rootName) return "npm";
      }
      return null;
    };
  }
});

// src/server/plugins/local.ts
var pluginGetLocalList, isWebConfigPlugin, getWebConfigPlugins;
var init_local = __esm({
  "src/server/plugins/local.ts"() {
    init_env2();
    init_config4();
    init_list();
    init_response();
    pluginGetLocalList = async (req, res) => {
      const { isForce } = req.body;
      const [npm2, git2] = await Promise.all([
        getPlugins("npm", true, isForce ?? false),
        getPlugins("git", true, isForce ?? false)
      ]);
      const list2 = [...npm2, ...git2];
      const result = [];
      const promise = [];
      list2.forEach((val) => promise.push(isWebConfigPlugin(val, result)));
      await Promise.all(promise);
      createSuccessResponse(res, result);
    };
    isWebConfigPlugin = async (val, result) => {
      const pkg2 = val.pkgData;
      if (val.type === "npm") {
        if (!pkg2.karin?.web) return;
        return getWebConfigPlugins(pkg2, val, result);
      }
      if (isTs()) {
        if (!pkg2.karin?.["ts-web"]) return;
        return getWebConfigPlugins(pkg2, val, result);
      }
    };
    getWebConfigPlugins = async (pkg2, val, result) => {
      let config3 = null;
      config3 = await getWebConfig(val.type, val.name);
      if (!config3 && isDev() && val.type === "npm") {
        config3 = await getWebConfig("git", val.name);
      }
      if (!config3 || !config3.info) return;
      result.push({
        ...config3.info,
        id: val.name,
        version: config3.info.version ?? pkg2.version,
        description: config3.info.description ?? pkg2.description,
        hasConfig: true,
        type: val.type,
        author: normalizeAuthor(config3.info.author)
      });
    };
  }
});
var ALLOWED_TYPES, MAX_FILE_SIZE, consoleRouter;
var init_console = __esm({
  "src/server/console/index.ts"() {
    init_root();
    init_adapter();
    init_ip();
    init_response();
    ALLOWED_TYPES = {
      ".png": "image/png",
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".gif": "image/gif",
      ".mp3": "audio/mpeg",
      ".mp4": "video/mp4",
      ".wav": "audio/wav",
      ".webp": "image/webp",
      ".json": "application/json",
      ".txt": "text/plain",
      ".html": "text/html",
      ".css": "text/css"
    };
    MAX_FILE_SIZE = 1024 * 1024 * 1024;
    consoleRouter = async (req, res) => {
      try {
        const cfg = adapter();
        let url = decodeURIComponent(req.path).replace(/\/+/g, "/").replace(/^\/+|\/+$/g, "");
        url = url.split("/").pop() || "";
        if (!url) {
          return createBadRequestResponse(res, "\u6587\u4EF6\u540D\u4E0D\u80FD\u4E3A\u7A7A");
        }
        if (url.includes("..") || url.includes("~") || !url.match(/^[a-zA-Z0-9-_.]+$/)) {
          return createForbiddenResponse(res, "\u975E\u6CD5\u8BF7\u6C42");
        }
        const ext = path4.extname(url).toLowerCase();
        if (!ALLOWED_TYPES[ext]) {
          return createBadRequestResponse(res, "\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B");
        }
        const isLocal = await isLocalRequest(req);
        if (cfg.console.isLocal) {
          if (!isLocal) {
            return createForbiddenResponse(res, "\u975E\u6CD5\u8BF7\u6C42");
          }
        } else {
          if (!cfg.console.token) {
            return createServerErrorResponse(res, "\u7F3A\u5C11 token \u914D\u7F6E");
          }
          const token = req.query.token;
          if (!token || token !== cfg.console.token) {
            return createForbiddenResponse(res, "\u65E0\u6548\u7684 token");
          }
        }
        const file2 = path4.join(consolePath, url);
        try {
          if (!file2.startsWith(consolePath)) {
            return createForbiddenResponse(res, "\u975E\u6CD5\u8BF7\u6C42");
          }
          const stats = await promises.stat(file2);
          if (stats.size > MAX_FILE_SIZE) {
            return createPayloadTooLargeResponse(res, "\u6587\u4EF6\u8FC7\u5927");
          }
        } catch {
          return createNotFoundResponse(res, "\u6587\u4EF6\u4E0D\u5B58\u5728");
        }
        const data = await promises.readFile(file2);
        res.setHeader("Content-Type", ALLOWED_TYPES[ext]);
        res.setHeader("Content-Length", data.length);
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.send(data);
      } catch (error) {
        console.error("Console router error:", error);
        return createServerErrorResponse(res, "\u670D\u52A1\u5668\u9519\u8BEF");
      }
    };
  }
});

// src/server/system/botList.ts
var getBotsRouter;
var init_botList = __esm({
  "src/server/system/botList.ts"() {
    init_bot();
    init_response();
    getBotsRouter = async (_, res) => {
      createSuccessResponse(res, getBotCount());
    };
  }
});

// src/server/system/update.ts
var updateCoreRouter;
var init_update2 = __esm({
  "src/server/system/update.ts"() {
    init_system2();
    init_response();
    updateCoreRouter = async (_req, res) => {
      console.log("\u6536\u5230\u66F4\u65B0\u8BF7\u6C42");
      const result = await updatePkg("node-karin");
      if (result.status === "ok") {
        createSuccessResponse(res, result, "\u66F4\u65B0\u6210\u529F");
      } else {
        createServerErrorResponse(res, "\u66F4\u65B0\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u65E5\u5FD7");
      }
    };
  }
});

// src/server/system/network.ts
var network, networkStatusRouter;
var init_network = __esm({
  "src/server/system/network.ts"() {
    init_response();
    network = null;
    networkStatusRouter = async (_req, res) => {
      try {
        if (typeof network !== "function") {
          const name = "@karinjs/plugin-webui-network-monitor";
          const { calculateNetworkSpeed } = await import(name);
          network = calculateNetworkSpeed;
        }
        const data = await network();
        createSuccessResponse(res, data);
      } catch (error) {
        logger.debug(error);
        createServerErrorResponse(res, "@karinjs/plugin-webui-network-monitor \u63D2\u4EF6\u672A\u5B89\u88C5\uFF01");
      }
    };
  }
});

// src/server/system/manage.ts
var restartRouter, exitRouter;
var init_manage = __esm({
  "src/server/system/manage.ts"() {
    init_restart();
    init_response();
    restartRouter = async (req, res) => {
      try {
        const { isPm2 = false, reloadDeps = false } = req.body;
        restartDirect({ isPm2, reloadDeps });
        createSuccessResponse(res, null, "\u91CD\u542F\u6307\u4EE4\u53D1\u9001\u6210\u529F");
      } catch (error) {
        createServerErrorResponse(res, error.message);
      }
    };
    exitRouter = async (_req, res) => {
      logger.mark("\u6536\u5230\u9000\u51FA\u8BF7\u6C42\uFF0C\u6B63\u5728\u9000\u51FA...");
      createSuccessResponse(res, null, "\u9000\u51FA\u6307\u4EE4\u53D1\u9001\u6210\u529F");
      const { processExit: processExit2 } = await Promise.resolve().then(() => (init_exit(), exit_exports));
      await processExit2(0, true);
    };
  }
});

// src/server/system/info.ts
var wsOneBotSet, wsPuppeteerSet, statusRouter, infoRouter, systemStatusRealTimeHandler;
var init_info = __esm({
  "src/server/system/info.ts"() {
    init_internal();
    init_response();
    init_key2();
    init_env2();
    wsOneBotSet = /* @__PURE__ */ new Set();
    wsPuppeteerSet = /* @__PURE__ */ new Set();
    listeners.on(WS_CONNECTION_ONEBOT, (socket) => {
      wsOneBotSet.add(socket);
    });
    listeners.on(WS_CONNECTION_PUPPETEER, (socket) => {
      wsPuppeteerSet.add(socket);
    });
    listeners.on(WS_CLOSE_ONEBOT, (socket) => {
      wsOneBotSet.delete(socket);
    });
    listeners.on(WS_CLOSE_PUPPETEER, (socket) => {
      wsPuppeteerSet.delete(socket);
    });
    statusRouter = (_req, res) => {
      const data = {
        name: "karin",
        pid: process.pid,
        pm2_id: process.env.pm_id || "",
        uptime: process.uptime(),
        version: process.env.KARIN_VERSION,
        karin_dev: isDev(),
        karin_lang: process.env.RUNTIME === "tsx" ? "ts" : "js",
        karin_runtime: process.env.RUNTIME,
        platform: process.platform,
        arch: process.arch
      };
      createSuccessResponse(res, data, "\u6210\u529F");
    };
    infoRouter = async (_req, res) => {
      const wsOneBotInfo = Array.from(wsOneBotSet).map((ws) => {
        return {
          // 获取连接ws的信息
          readyState: ws.readyState,
          // 获取连接ws的信息
          url: ws.url,
          // 获取连接ws的信息
          protocol: ws.protocol
        };
      });
      const wsPuppeteerInfo = Array.from(wsPuppeteerSet).map((ws) => {
        return {
          // 获取连接ws的信息
          readyState: ws.readyState,
          // 获取连接ws的信息
          url: ws.url,
          // 获取连接ws的信息
          protocol: ws.protocol
        };
      });
      const wsInfo = {
        onebot: wsOneBotInfo,
        puppeteer: wsPuppeteerInfo
      };
      createSuccessResponse(res, wsInfo);
    };
    systemStatusRealTimeHandler = async (req, res) => {
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Connection", "keep-alive");
      const sendStatus = (status) => {
        try {
          res.write(`data: ${JSON.stringify(status)}

`);
        } catch (e) {
          logger.error(`An error occurred when writing sendStatus data to client: ${e}`);
        }
      };
      statusListener.on("statusUpdate", sendStatus);
      req.on("close", () => {
        statusListener.off("statusUpdate", sendStatus);
        res.end("data: end\n\n");
      });
    };
  }
});
var isStandardDate, logLevelRouter, activeConnections, getLogRouter, getLogFileListRouter, getLogFileRouter;
var init_getLog = __esm({
  "src/server/log/getLog.ts"() {
    init_root();
    init_config();
    init_response();
    isStandardDate = (date) => {
      return typeof date === "string" && /^\d{4}-\d{2}-\d{2}$/.test(date);
    };
    logLevelRouter = async (req, res) => {
      const level = req.body?.level;
      const list2 = ["trace", "debug", "info", "warn", "error", "fatal"];
      if (!level || !list2.includes(level)) {
        return createBadRequestResponse(res, "\u53C2\u6570\u9519\u8BEF");
      }
      updateLevel(level);
      createSuccessResponse(res, null, "\u4FEE\u6539\u6210\u529F");
    };
    activeConnections = 0;
    getLogRouter = async (req, res) => {
      const maxConnections = Number(process.env.LOG_API_MAX_CONNECTIONS) || 5;
      const MAX_CHUNK_SIZE = Number(process.env.LOG_API_MAX_CHUNK_SIZE) || 1024 * 1024;
      if (activeConnections >= maxConnections) {
        return createBadRequestResponse(res, "\u5F53\u524D\u8FDE\u63A5\u6570\u5DF2\u8FBE\u5230\u4E0A\u9650\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
      }
      activeConnections++;
      const date = moment();
      if (!date.isValid()) {
        activeConnections--;
        return createBadRequestResponse(res, "\u65E5\u671F\u683C\u5F0F\u9519\u8BEF");
      }
      const file2 = path4.join(logsPath, `logger.${date.format("YYYY-MM-DD")}.log`);
      res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      res.setHeader("X-Accel-Buffering", "no");
      let position = 0;
      let isStreaming = false;
      const isEventSource = req.headers.accept === "text/event-stream";
      const heartbeat = setInterval(() => {
        if (isEventSource) {
          res.write(":heartbeat\n\n");
        }
      }, 3e4);
      const tailFile = () => {
        if (isStreaming) return;
        fs5.stat(file2, (err, stats) => {
          if (err) {
            logger.error("\u8BFB\u53D6\u65E5\u5FD7\u6587\u4EF6\u72B6\u6001\u9519\u8BEF:", err);
            return;
          }
          if (position > stats.size) {
            position = 0;
          }
          if (position < stats.size) {
            isStreaming = true;
            const endPosition = Math.min(position + MAX_CHUNK_SIZE, stats.size);
            const stream2 = fs5.createReadStream(file2, {
              start: position,
              end: endPosition - 1,
              encoding: "utf-8",
              highWaterMark: 64 * 1024
              // 设置较小的缓冲区，减少内存使用
            });
            stream2.on("data", (data) => {
              const lines = data.toString().split("\n");
              for (const line of lines) {
                if (line) {
                  if (isEventSource) {
                    res.write(`data: ${line}

`);
                  } else {
                    res.write(`${line}
`);
                  }
                }
              }
            });
            stream2.on("end", () => {
              position = endPosition;
              isStreaming = false;
            });
            stream2.on("error", (error) => {
              logger.error("\u8BFB\u53D6\u65E5\u5FD7\u6587\u4EF6\u9519\u8BEF:", error.message);
              isStreaming = false;
            });
          }
        });
      };
      tailFile();
      const interval = setInterval(tailFile, 1e3);
      req.on("close", () => {
        clearInterval(interval);
        clearInterval(heartbeat);
        activeConnections--;
      });
      req.on("error", () => {
        clearInterval(interval);
        clearInterval(heartbeat);
        activeConnections--;
      });
    };
    getLogFileListRouter = async (_, res) => {
      const files = fs5.readdirSync(logsPath);
      const logFiles = files.filter((file2) => file2.startsWith("logger.") && file2.endsWith(".log")).map((file2) => file2.replace("logger.", "").replace(".log", ""));
      createSuccessResponse(res, logFiles, "\u6210\u529F");
    };
    getLogFileRouter = async (req, res) => {
      const file2 = req.query.file;
      if (!isStandardDate(file2)) {
        return createBadRequestResponse(res, "\u65E5\u671F\u683C\u5F0F\u9519\u8BEF");
      }
      const filePath = path4.join(logsPath, `logger.${file2}.log`);
      if (!fs5.existsSync(filePath)) {
        return createBadRequestResponse(res, "\u65E5\u5FD7\u6587\u4EF6\u4E0D\u5B58\u5728");
      }
      const stats = fs5.statSync(filePath);
      const FILE_SIZE_LIMIT = Number(process.env.LOG_FILE_SIZE_LIMIT) || 10 * 1024 * 1024;
      if (stats.size > FILE_SIZE_LIMIT) {
        return createBadRequestResponse(res, "\u65E5\u5FD7\u6587\u4EF6\u8FC7\u5927\uFF0C\u8BF7\u4F7F\u7528\u6D41\u5F0F\u63A5\u53E3\u83B7\u53D6\u6216\u4E0B\u8F7D\u6587\u4EF6");
      }
      const content = fs5.readFileSync(filePath, "utf-8");
      createSuccessResponse(res, content, "\u6210\u529F");
    };
  }
});

// src/server/plugins/cache.ts
var CACHE_KEY, deletePluginListCache;
var init_cache5 = __esm({
  "src/server/plugins/cache.ts"() {
    CACHE_KEY = "karin:web:plugin:list";
    deletePluginListCache = async () => {
      try {
        const { redis: redis3 } = await Promise.resolve().then(() => (init_redis3(), redis_exports));
        await redis3.del(CACHE_KEY);
      } catch (error) {
        logger.error("\u5220\u9664\u63D2\u4EF6\u5217\u8868\u7F13\u5B58\u5931\u8D25:", error);
      }
    };
  }
});
var taskQueue, spawnCommand, installNpmPlugin, installGitPlugin, installAppPlugin, installPluginTask, pluginInstall, uninstallNpmPlugin, uninstallGitPlugin, uninstallPluginTask, pluginUninstall, pluginGetTaskStatus, cleanupTasks, pluginGetTaskList, pluginUpdateTaskStatus;
var init_install = __esm({
  "src/server/plugins/install.ts"() {
    init_env2();
    init_cache5();
    init_response();
    taskQueue = /* @__PURE__ */ new Map();
    spawnCommand = (command2, args, task2) => {
      if (isWorkspace()) args.push("-w");
      return new Promise((resolve, reject) => {
        const child = spawn$1(command2, args, {
          stdio: ["ignore", "pipe", "pipe"],
          shell: true,
          cwd: process.cwd()
        });
        child.stdout.on("data", (data) => {
          const lines = data.toString().split("\n").filter(Boolean);
          lines.forEach((line) => {
            task2.logs.push(line);
          });
        });
        child.stderr.on("data", (data) => {
          const lines = data.toString().split("\n").filter(Boolean);
          lines.forEach((line) => {
            task2.logs.push(`[\u9519\u8BEF] ${line}`);
          });
        });
        child.on("close", (code) => {
          if (code === 0) {
            resolve();
          } else {
            reject(new Error(`\u547D\u4EE4\u6267\u884C\u5931\u8D25\uFF0C\u9000\u51FA\u7801: ${code}`));
          }
        });
        child.on("error", (error) => reject(error));
      });
    };
    installNpmPlugin = async (task2) => {
      task2.logs.push(`\u5F00\u59CB\u5B89\u88C5 NPM \u63D2\u4EF6: ${task2.name}`);
      task2.logs.push("\u6B63\u5728\u89E3\u6790\u4F9D\u8D56...");
      const command2 = ["add", task2.name, "--save"];
      await spawnCommand("pnpm", command2, task2);
    };
    installGitPlugin = async (task2, url) => {
      if (!url) throw new Error("Git \u63D2\u4EF6\u9700\u8981\u63D0\u4F9B\u4ED3\u5E93\u5730\u5740");
      const pluginDir2 = path4.join(process.cwd(), "plugins", task2.name);
      task2.logs.push(`\u5F00\u59CB\u514B\u9686\u4ED3\u5E93: ${url}`);
      task2.logs.push(`\u76EE\u6807\u76EE\u5F55: ${pluginDir2}`);
      await fs5.promises.mkdir(pluginDir2, { recursive: true });
      await spawnCommand("git", ["clone", "--depth=1", url, `./plugins/${task2.name}`], task2);
      const pkgPath = path4.join(pluginDir2, "package.json");
      if (fs5.existsSync(pkgPath)) {
        task2.logs.push("\u68C0\u6D4B\u5230 package.json\uFF0C\u5F00\u59CB\u5B89\u88C5\u4F9D\u8D56...");
        await spawnCommand("pnpm", ["install"], task2);
      }
    };
    installAppPlugin = async (task2, url) => {
      if (!url) throw new Error("App \u63D2\u4EF6\u9700\u8981\u63D0\u4F9B\u4E0B\u8F7D\u5730\u5740");
      if (!url.endsWith(".js") && !url.endsWith(".ts")) {
        throw new Error("\u975Ejs\u3001ts\u4E0D\u5141\u8BB8\u4E0B\u8F7D");
      }
      const pluginDir2 = path4.join(process.cwd(), "plugins", "karin-plugin-example");
      task2.logs.push(`\u5F00\u59CB\u4E0B\u8F7D\u63D2\u4EF6: ${url}`);
      task2.logs.push(`\u76EE\u6807\u76EE\u5F55: ${pluginDir2}`);
      await fs5.promises.mkdir(pluginDir2, { recursive: true });
      await spawnCommand(
        "curl",
        [
          "-L",
          "-o",
          pluginDir2,
          url
        ],
        task2
      );
    };
    installPluginTask = async (task2, url) => {
      try {
        task2.status = "running";
        task2.logs.push(`\u5F00\u59CB\u5B89\u88C5\u63D2\u4EF6: ${task2.name}`);
        task2.logs.push(`\u63D2\u4EF6\u7C7B\u578B: ${task2.type}`);
        task2.logs.push("-------------------");
        switch (task2.type) {
          case "npm":
            await installNpmPlugin(task2);
            break;
          case "git":
            await installGitPlugin(task2, url);
            break;
          case "app":
            await installAppPlugin(task2, url);
            break;
          default:
            throw new Error("\u4E0D\u652F\u6301\u7684\u63D2\u4EF6\u7C7B\u578B");
        }
        task2.logs.push("-------------------");
        task2.logs.push("\u{1F389} \u5B89\u88C5\u5B8C\u6210!");
        task2.status = "completed";
        await deletePluginListCache();
      } catch (error) {
        task2.status = "failed";
        task2.error = error.message;
        task2.logs.push("-------------------");
        task2.logs.push(`\u274C \u5B89\u88C5\u5931\u8D25: ${error.message}`);
        throw error;
      }
    };
    pluginInstall = async (req, res) => {
      try {
        const { name, type, url } = req.body;
        const taskId = `${type}-${name}-${Date.now()}`;
        const existingTask = Array.from(taskQueue.values()).find(
          (task3) => task3.name === name && task3.status === "running"
        );
        if (existingTask) {
          return createServerErrorResponse(res, "\u8BE5\u63D2\u4EF6\u6B63\u5728\u5B89\u88C5\u4E2D");
        }
        const task2 = {
          id: taskId,
          name,
          type,
          status: "pending",
          logs: [],
          minimized: false
        };
        taskQueue.set(taskId, task2);
        installPluginTask(task2, url).catch((error) => {
          task2.status = "failed";
          task2.error = error.message;
          task2.logs.push(`\u5B89\u88C5\u5931\u8D25: ${error.message}`);
        });
        createSuccessResponse(res, { taskId });
      } catch (error) {
        createServerErrorResponse(res, error.message);
        logger.error(error);
      }
    };
    uninstallNpmPlugin = async (task2) => {
      task2.logs.push(`\u5F00\u59CB\u5378\u8F7D NPM \u63D2\u4EF6: ${task2.name}`);
      await spawnCommand("pnpm", ["rm", task2.name], task2);
    };
    uninstallGitPlugin = async (task2) => {
      const pluginDir2 = path4.join(process.cwd(), "plugins", task2.name);
      task2.logs.push(`\u5F00\u59CB\u5220\u9664\u63D2\u4EF6\u76EE\u5F55: ${pluginDir2}`);
      await fs5.promises.rm(pluginDir2, { recursive: true, force: true });
      task2.logs.push("\u63D2\u4EF6\u76EE\u5F55\u5DF2\u5220\u9664");
      task2.logs.push("\u6B63\u5728\u6E05\u7406\u4F9D\u8D56\u7F13\u5B58...");
      await spawnCommand("pnpm", ["install", "-P"], task2);
    };
    uninstallPluginTask = async (task2) => {
      try {
        task2.status = "running";
        task2.logs.push(`\u5F00\u59CB\u5378\u8F7D\u63D2\u4EF6: ${task2.name}`);
        task2.logs.push(`\u63D2\u4EF6\u7C7B\u578B: ${task2.type}`);
        task2.logs.push("-------------------");
        switch (task2.type) {
          case "npm":
            await uninstallNpmPlugin(task2);
            break;
          case "git":
            await uninstallGitPlugin(task2);
            break;
          default:
            throw new Error("\u4E0D\u652F\u6301\u5378\u8F7D\u8BE5\u7C7B\u578B\u7684\u63D2\u4EF6");
        }
        task2.logs.push("-------------------");
        task2.logs.push("\u{1F389} \u5378\u8F7D\u5B8C\u6210!");
        task2.logs.push("\u26A0\uFE0F \u5EFA\u8BAE\u91CD\u542F Bot \u4EE5\u4F7F\u66F4\u6539\u751F\u6548");
        task2.status = "completed";
        await deletePluginListCache();
      } catch (error) {
        task2.status = "failed";
        task2.error = error.message;
        task2.logs.push("-------------------");
        task2.logs.push(`\u274C \u5378\u8F7D\u5931\u8D25: ${error.message}`);
        throw error;
      }
    };
    pluginUninstall = async (req, res) => {
      try {
        const { name, type } = req.body;
        const taskId = `uninstall-${type}-${name}-${Date.now()}`;
        const existingTask = Array.from(taskQueue.values()).find(
          (task3) => task3.name === name && task3.status === "running"
        );
        if (existingTask) {
          return createServerErrorResponse(res, "\u8BE5\u63D2\u4EF6\u6B63\u5728\u5378\u8F7D\u4E2D");
        }
        const task2 = {
          id: taskId,
          name,
          type,
          status: "pending",
          logs: [],
          minimized: false
        };
        taskQueue.set(taskId, task2);
        uninstallPluginTask(task2).catch((error) => {
          task2.status = "failed";
          task2.error = error.message;
          task2.logs.push(`\u5378\u8F7D\u5931\u8D25: ${error.message}`);
        });
        createSuccessResponse(res, { taskId });
      } catch (error) {
        createServerErrorResponse(res, error.message);
        logger.error(error);
      }
    };
    pluginGetTaskStatus = (req, res) => {
      try {
        const { taskId } = req.body;
        const task2 = taskQueue.get(taskId);
        if (!task2) {
          return createServerErrorResponse(res, "\u4EFB\u52A1\u4E0D\u5B58\u5728");
        }
        createSuccessResponse(res, task2);
      } catch (error) {
        createServerErrorResponse(res, error.message);
        logger.error(error);
      }
    };
    cleanupTasks = () => {
      const THIRTY_MINUTES = 30 * 60 * 1e3;
      for (const [taskId, task2] of taskQueue.entries()) {
        if ((task2.status === "completed" || task2.status === "failed") && Date.now() - parseInt(taskId.split("-").pop() || "0") > THIRTY_MINUTES) {
          taskQueue.delete(taskId);
        }
      }
    };
    pluginGetTaskList = (_req, res) => {
      cleanupTasks();
      const tasks = Array.from(taskQueue.values());
      createSuccessResponse(res, tasks);
    };
    pluginUpdateTaskStatus = (req, res) => {
      try {
        const { taskId, minimized } = req.body;
        const task2 = taskQueue.get(taskId);
        if (!task2) {
          return createServerErrorResponse(res, "\u4EFB\u52A1\u4E0D\u5B58\u5728");
        }
        task2.minimized = minimized;
        createSuccessResponse(res, task2);
      } catch (error) {
        createServerErrorResponse(res, error.message);
        logger.error(error);
      }
    };
  }
});

// src/server/pty/terminalManager.ts
var terminalManager_exports = {};
__export(terminalManager_exports, {
  closeTerminal: () => closeTerminal,
  createTerminal: () => createTerminal,
  getTerminal: () => getTerminal,
  getTerminalList: () => getTerminalList,
  initialize: () => initialize,
  isPtyInstalled: () => isPtyInstalled
});
var terminals, pty, isPtyInstalled, initialize, createTerminal, closeTerminal, getTerminal, getTerminalList;
var init_terminalManager = __esm({
  "src/server/pty/terminalManager.ts"() {
    init_common2();
    init_internal();
    init_utils();
    terminals = /* @__PURE__ */ new Map();
    pty = null;
    isPtyInstalled = async () => {
      try {
        const name = "@karinjs/node-pty";
        pty = await import(name);
        return true;
      } catch (error) {
        return false;
      }
    };
    initialize = async () => {
      const installed = await isPtyInstalled();
      if (!installed) {
        logger.debug("[terminal] PTY \u6A21\u5757\u672A\u5B89\u88C5\uFF0C\u7EC8\u7AEF\u529F\u80FD\u4E0D\u53EF\u7528");
        return;
      }
      listeners.on(WS_CONNECTION_TERMINAL, (socket, request3, call2) => {
        try {
          call2();
          const url = new URL$1(request3.url || "", "ws://localhost");
          const terminalId = url.searchParams.get("id");
          const userId = url.searchParams.get("user_id");
          const token = url.searchParams.get("token");
          if (!token || !terminalId || !userId) {
            socket.close();
            logger.info(`[terminal] \u975E\u6CD5\u8BF7\u6C42: ${request3.url}`);
            return;
          }
          const verifyStatus = auth2.terminalAuth(token, userId);
          if (!verifyStatus) {
            socket.close();
            logger.info(`[terminal] \u9274\u6743\u5931\u8D25: ${request3.url}`);
            return;
          }
          const instance = terminals.get(terminalId);
          if (!instance) {
            socket.close();
            logger.info(`[terminal] \u7EC8\u7AEF\u4E0D\u5B58\u5728: ${request3.url}`);
            return;
          }
          instance.sockets.add(socket);
          instance.lastAccess = Date.now();
          if (socket.readyState === WebSocket$1.OPEN) {
            socket.send(JSON.stringify({ type: "output", data: instance.buffer }));
          }
          socket.on("message", (data) => {
            if (instance && !instance.isClosing) {
              const result = JSON.parse(data.toString());
              if (result.type === "input") {
                instance.pty.write(result.data);
              }
              if (result.type === "resize") {
                instance.pty.resize(result.cols, result.rows);
              }
            }
          });
          socket.on("close", () => {
            logger.info(`[terminal] \u7EC8\u7AEF\u8FDE\u63A5\u5173\u95ED: ${terminalId}`);
            instance.sockets.delete(socket);
            if (instance.sockets.size === 0 && !instance.isClosing) {
              instance.isClosing = true;
              if (os.platform() === "win32") {
                process.kill(instance.pty.pid);
              } else {
                instance.pty.kill();
              }
            }
          });
        } catch (error) {
          logger.error(`[terminal] \u521D\u59CB\u5316\u5931\u8D25: ${request3.url}`);
          logger.error(error);
          socket.close();
        }
      });
    };
    createTerminal = async (name = "xterm-256color", shell, cols = 80, rows = 30) => {
      if (!pty) {
        throw new Error("\u7EC8\u7AEF\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316\u6216\u63D2\u4EF6\u672A\u5B89\u88C5");
      }
      const id = randomUUID();
      const term = pty.spawn(shell, [], {
        name: "xterm-256color",
        cols,
        rows,
        cwd: process.cwd(),
        env: {
          ...process.env,
          LANG: os.platform() === "win32" ? "chcp 65001" : "zh_CN.UTF-8",
          TERM: "xterm-256color"
        }
      });
      const instance = {
        pty: term,
        lastAccess: Date.now(),
        sockets: /* @__PURE__ */ new Set(),
        isClosing: false,
        buffer: "",
        name
      };
      term.onData((data) => {
        instance.buffer += data;
        instance.sockets.forEach((ws) => {
          if (ws.readyState === WebSocket$1.OPEN) {
            ws.send(JSON.stringify({ type: "output", data }));
          }
        });
      });
      term.onExit(() => {
        closeTerminal(id);
      });
      terminals.set(id, instance);
      return { id, instance };
    };
    closeTerminal = (id) => {
      const instance = terminals.get(id);
      if (instance) {
        if (!instance.isClosing) {
          instance.isClosing = true;
          if (os.platform() === "win32") {
            process.kill(instance.pty.pid);
          } else {
            instance.pty.kill();
          }
        }
        instance.sockets.forEach((ws) => ws.close());
        terminals.delete(id);
      }
    };
    getTerminal = (id) => {
      return terminals.get(id);
    };
    getTerminalList = () => {
      return Array.from(terminals.keys()).map((id) => ({
        id,
        lastAccess: terminals.get(id).lastAccess,
        name: terminals.get(id).name
      }));
    };
  }
});

// src/server/pty/index.ts
var createTerminalHandler, getTerminalListHandler, closeTerminalHandler;
var init_pty = __esm({
  "src/server/pty/index.ts"() {
    init_response();
    init_terminalManager();
    createTerminalHandler = async (req, res) => {
      try {
        const { cols, rows, shell, name } = req.body;
        const { id } = await createTerminal(name, shell, cols, rows);
        return createSuccessResponse(res, { id });
      } catch (error) {
        logger.error(`[terminal] \u521B\u5EFA\u7EC8\u7AEF\u5931\u8D25: ${req.body.shell}`);
        logger.error(error);
        return createServerErrorResponse(res, `\u521B\u5EFA\u7EC8\u7AEF\u5931\u8D25: ${error.message}`);
      }
    };
    getTerminalListHandler = (_, res) => {
      try {
        const list2 = getTerminalList();
        return createSuccessResponse(res, list2);
      } catch (error) {
        logger.error("[terminal] \u83B7\u53D6\u7EC8\u7AEF\u5217\u8868\u5931\u8D25");
        logger.error(error);
        return createServerErrorResponse(res, `\u83B7\u53D6\u7EC8\u7AEF\u5217\u8868\u5931\u8D25: ${error.message}`);
      }
    };
    closeTerminalHandler = (req, res) => {
      try {
        const id = req.body.id;
        if (!id) {
          return createServerErrorResponse(res, "ID\u4E0D\u80FD\u4E3A\u7A7A");
        }
        closeTerminal(id);
        return createSuccessResponse(res, {});
      } catch (error) {
        logger.error(`[terminal] \u5173\u95ED\u7EC8\u7AEF\u5931\u8D25: ${req.body.id}`);
        logger.error(error);
        return createServerErrorResponse(res, `\u5173\u95ED\u7EC8\u7AEF\u5931\u8D25: ${error.message}`);
      }
    };
  }
});

// src/server/system/check.ts
var checkPlugin;
var init_check2 = __esm({
  "src/server/system/check.ts"() {
    init_response();
    checkPlugin = async (req, res) => {
      try {
        await import(req.body.name);
        return createSuccessResponse(res, { installed: true }, "\u5DF2\u5B89\u88C5");
      } catch {
        return createSuccessResponse(res, { installed: false }, "\u672A\u5B89\u88C5");
      }
    };
  }
});
var versionCache, CACHE_TTL, plugins, installWebui, uninstallWebui, getWebuiPluginList, getWebuiPluginVersions, updateWebuiPluginVersion;
var init_webui = __esm({
  "src/server/plugins/webui.ts"() {
    init_env2();
    init_exec();
    init_terminalManager();
    init_response();
    versionCache = {};
    CACHE_TTL = 2 * 60 * 1e3;
    plugins = [
      {
        name: "@karinjs/node-pty",
        installed: false,
        // 会在运行时检测并更新
        description: "\u63D0\u4F9B\u7EC8\u7AEF\u529F\u80FD\u652F\u6301\uFF0C\u5141\u8BB8\u60A8\u5728WebUI\u4E2D\u4F7F\u7528\u547D\u4EE4\u884C\u7EC8\u7AEF\u3002\u9700\u8981\u6CE8\u610F\uFF0C\u6B64\u63D2\u4EF6\u5B58\u5728\u98CE\u9669\uFF0C\u5B89\u88C5\u540E\u53EF\u8FD0\u884C\u4E00\u5207\u547D\u4EE4\u3002"
      },
      {
        name: "@karinjs/plugin-webui-network-monitor",
        installed: false,
        // 会在运行时检测并更新
        description: "\u7F51\u7EDC\u76D1\u63A7\u63D2\u4EF6\uFF0C\u63D0\u4F9B\u7F51\u7EDC\u6D41\u91CF\u3001\u8FDE\u63A5\u7B49\u76D1\u63A7\u529F\u80FD\uFF0C\u53EF\u89C6\u5316\u5C55\u793A\u7CFB\u7EDF\u7F51\u7EDC\u72B6\u6001\u3002"
      }
    ];
    installWebui = async (req, res) => {
      try {
        const { name } = req.body;
        if (!name) {
          return createServerErrorResponse(res, "name\u4E0D\u80FD\u4E3A\u7A7A");
        }
        if (!plugins.some((p) => p.name === name)) {
          return createServerErrorResponse(res, "\u975E\u6CD5\u63D2\u4EF6");
        }
        const result = await exec(`pnpm install ${name}${isWorkspace() ? " -w" : ""}`);
        if (name === "@karinjs/node-pty") {
          await initialize();
        }
        if (result.error) {
          logger.error(new Error(`\u5B89\u88C5webui\u63D2\u4EF6\u53D1\u751F\u9519\u8BEF: ${name}`, { cause: result.error }));
        }
        logger.mark(`[webui] \u5B89\u88C5 ${name} \u63D2\u4EF6\u6210\u529F`);
        return createSuccessResponse(res, {
          status: result.status,
          data: result.status ? "\u5B89\u88C5\u6210\u529F" : result.error?.message || "\u5B89\u88C5\u5931\u8D25"
        });
      } catch (error) {
        logger.error(`[webui] \u5B89\u88C5webui\u63D2\u4EF6\u5931\u8D25: ${req.body.name}`);
        logger.error(error);
        return createServerErrorResponse(res, `\u5B89\u88C5webui\u63D2\u4EF6\u5931\u8D25: ${error.message}`);
      }
    };
    uninstallWebui = async (req, res) => {
      try {
        const { name } = req.body;
        if (!name) {
          return createServerErrorResponse(res, "name\u4E0D\u80FD\u4E3A\u7A7A");
        }
        if (!plugins.some((p) => p.name === name)) {
          return createServerErrorResponse(res, "\u975E\u6CD5\u63D2\u4EF6");
        }
        const result = await exec(`pnpm uninstall ${name}`);
        logger.mark(`[webui] \u5378\u8F7D ${name} \u63D2\u4EF6\u6210\u529F`);
        return createSuccessResponse(res, {
          status: result.status,
          data: result.status ? "\u5378\u8F7D\u6210\u529F" : result.error?.message || "\u5378\u8F7D\u5931\u8D25"
        });
      } catch (error) {
        logger.error(`[webui] \u5378\u8F7Dwebui\u63D2\u4EF6\u5931\u8D25: ${req.body.name}`);
        logger.error(error);
        return createServerErrorResponse(res, `\u5378\u8F7Dwebui\u63D2\u4EF6\u5931\u8D25: ${error.message}`);
      }
    };
    getWebuiPluginList = async (_, res) => {
      try {
        const pkg2 = JSON.parse(fs5.readFileSync(path4.join(process.cwd(), "package.json"), "utf-8"));
        const updatedPlugins = plugins.map((plugin) => {
          const isInstalled = pkg2.dependencies?.[plugin.name] || pkg2.devDependencies?.[plugin.name] || pkg2.peerDependencies?.[plugin.name];
          const version2 = isInstalled || null;
          return {
            ...plugin,
            installed: typeof version2 === "string",
            version: version2
          };
        });
        return createSuccessResponse(res, updatedPlugins);
      } catch (error) {
        logger.error("[webui] \u83B7\u53D6\u63D2\u4EF6\u5217\u8868\u5931\u8D25");
        logger.error(error);
        return createServerErrorResponse(res, `\u83B7\u53D6\u63D2\u4EF6\u5217\u8868\u5931\u8D25: ${error.message}`);
      }
    };
    getWebuiPluginVersions = async (req, res) => {
      try {
        const { name } = req.body;
        if (!name) {
          return createServerErrorResponse(res, "name\u4E0D\u80FD\u4E3A\u7A7A");
        }
        if (!plugins.some((p) => p.name === name)) {
          return createServerErrorResponse(res, "\u975E\u6CD5\u63D2\u4EF6");
        }
        const now = Date.now();
        const cachedData = versionCache[name];
        if (cachedData && now - cachedData.timestamp < CACHE_TTL) {
          logger.debug(`[webui] \u4F7F\u7528\u7F13\u5B58\u7684\u7248\u672C\u4FE1\u606F: ${name}`);
          return createSuccessResponse(res, cachedData.data);
        }
        let currentVersion = null;
        const pkgPath = path4.join(process.cwd(), "node_modules", name, "package.json");
        if (fs5.existsSync(pkgPath)) {
          try {
            const pkgContent = fs5.readFileSync(pkgPath, "utf-8");
            const pkg2 = JSON.parse(pkgContent);
            currentVersion = pkg2.version;
          } catch (error) {
            logger.error(`[webui] \u8BFB\u53D6\u63D2\u4EF6\u7248\u672C\u5931\u8D25: ${name}`);
          }
        }
        logger.info(`[webui] \u83B7\u53D6\u63D2\u4EF6 ${name} \u7684\u7248\u672C\u4FE1\u606F`);
        const result = await exec(`npm view ${name} versions --json`);
        if (!result.status) {
          return createServerErrorResponse(res, `\u83B7\u53D6\u7248\u672C\u4FE1\u606F\u5931\u8D25: ${result.error?.message}`);
        }
        try {
          let versions = JSON.parse(result.stdout);
          versions = Array.isArray(versions) ? versions : [versions];
          versions.reverse();
          const limitedVersions = versions.slice(0, 20);
          const responseData = {
            currentVersion,
            availableVersions: limitedVersions,
            hasMoreVersions: versions.length > 20
          };
          versionCache[name] = {
            data: responseData,
            timestamp: now
          };
          return createSuccessResponse(res, responseData);
        } catch (error) {
          return createServerErrorResponse(res, `\u89E3\u6790\u7248\u672C\u4FE1\u606F\u5931\u8D25: ${error.message}`);
        }
      } catch (error) {
        logger.error(`[webui] \u83B7\u53D6\u63D2\u4EF6\u7248\u672C\u5931\u8D25: ${req.body.name}`);
        logger.error(error);
        return createServerErrorResponse(res, `\u83B7\u53D6\u63D2\u4EF6\u7248\u672C\u5931\u8D25: ${error.message}`);
      }
    };
    updateWebuiPluginVersion = async (req, res) => {
      try {
        const { name, version: version2 } = req.body;
        if (!name || !version2) {
          return createServerErrorResponse(res, "name\u548Cversion\u4E0D\u80FD\u4E3A\u7A7A");
        }
        if (!plugins.some((p) => p.name === name)) {
          return createServerErrorResponse(res, "\u975E\u6CD5\u63D2\u4EF6");
        }
        const result = await exec(`pnpm install ${name}@${version2}${isWorkspace() ? " -w" : ""}`);
        return createSuccessResponse(res, {
          status: result.status,
          data: result.status ? "\u66F4\u65B0\u6210\u529F" : result.error?.message || "\u66F4\u65B0\u5931\u8D25"
        });
      } catch (error) {
        logger.error(`[webui] \u66F4\u65B0\u63D2\u4EF6\u7248\u672C\u5931\u8D25: ${req.body.name}@${req.body.version}`);
        logger.error(error);
        return createServerErrorResponse(res, `\u66F4\u65B0\u63D2\u4EF6\u7248\u672C\u5931\u8D25: ${error.message}`);
      }
    };
  }
});
var validatePluginRequest, spawnProcess, handleReturn2;
var init_tool = __esm({
  "src/server/plugins/admin/tool.ts"() {
    init_response();
    validatePluginRequest = (res, name, target, pluginType, allowedTypes) => {
      if (!name || !target) {
        createBadRequestResponse(res, "\u65E0\u6548\u8BF7\u6C42: \u63D2\u4EF6\u540D\u79F0\u6216\u4EFB\u52A1\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A");
        return false;
      }
      if (!allowedTypes.includes(pluginType)) {
        createBadRequestResponse(res, "\u65E0\u6548\u8BF7\u6C42: \u63D2\u4EF6\u7C7B\u578B\u9519\u8BEF");
        return false;
      }
      return true;
    };
    spawnProcess = (command2, args, options = {}, emitLog, pnpm) => {
      return new Promise((resolve) => {
        const proc = spawn(command2, args, {
          shell: true,
          cwd: options.cwd || process.cwd(),
          env: {
            ...process.env,
            ...options.env
          }
        });
        proc.stdout.on("data", (data) => {
          const message2 = data.toString();
          logger.debug(message2);
          emitLog(message2);
        });
        proc.stderr.on("data", (data) => {
          const message2 = data.toString();
          if (message2.includes("ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF")) {
            pnpm && pnpm();
          }
          logger.debug(message2);
          emitLog(message2);
        });
        proc.on("close", (code) => {
          proc.kill();
          emitLog(`\u6267\u884C\u5B8C\u6210\uFF0C\u9000\u51FA\u7801: ${code}`);
          resolve(true);
        });
        proc.on("error", (error) => {
          logger.debug(error);
          emitLog(`\u6267\u884C\u5931\u8D25: ${error.message}`);
          logger.error(error);
          resolve(error);
        });
        return proc;
      });
    };
    handleReturn2 = (res, success, message2, taskId) => {
      if (taskId) {
        return createSuccessResponse(res, { success, message: message2, taskId });
      }
      return createSuccessResponse(res, { success, message: message2 });
    };
  }
});
var update, updateAll;
var init_update3 = __esm({
  "src/server/plugins/admin/update.ts"() {
    init_env2();
    init_list();
    init_root();
    init_task();
    init_pull();
    init_tool();
    update = async (res, data, ip = "0.0.0.0") => {
      if (!Array.isArray(data.target) || data.target.length < 1 && !data.isAll) {
        return handleReturn2(res, false, "\u65E0\u6548\u8BF7\u6C42: \u63D2\u4EF6\u76EE\u6807\u9519\u8BEF");
      }
      if (data.isAll) {
        const id2 = await taskSystem.add(
          {
            type: "update",
            name: data.name,
            target: "all",
            operatorIp: ip
          },
          async (options, emitLog) => {
            await updateAll(options, emitLog, data.isAll);
            await taskSystem.update.logs(options.id, "\u4EFB\u52A1\u6267\u884C\u6210\u529F");
            return true;
          }
        );
        return handleReturn2(res, true, "\u66F4\u65B0\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1", id2);
      }
      const performUpdate = async (_, log3) => {
        const npm2 = [];
        const git2 = [];
        const notExist = [];
        const list2 = await getPlugins("all", false, true);
        for (const item of data.target) {
          if (item.type === "npm") {
            list2.includes(`${item.type}:${item.name}`) ? npm2.push({ name: item.name, version: item.version || "latest" }) : notExist.push(item.name);
            continue;
          }
          if (item.type === "git") {
            const force = typeof item.force === "boolean" ? item.force : false;
            list2.includes(`${item.type}:${item.name}`) ? git2.push({ name: item.name, version: item.version || "latest", force }) : notExist.push(item.name);
            continue;
          }
          notExist.push(item.name);
        }
        if (npm2.length > 0) {
          const args = npm2.map((item) => `${item.name}@${item.version}`);
          await spawnProcess("pnpm", ["update", ...args, "--save"], { timeout: 60 * 1e3 }, log3);
        }
        for (const item of git2) {
          const { name, force } = item;
          const cwd = path4.join(karinPathPlugins, name);
          const result = await gitPull(cwd, { force, timeout: 60 * 1e3 });
          if (result.status) {
            log3(`\u66F4\u65B0 ${name}(git) \u63D2\u4EF6\u6210\u529F: ${result.hash.before} -> ${result.hash.after}`);
          } else {
            log3(`\u66F4\u65B0 ${name}(git) \u63D2\u4EF6\u5931\u8D25: ${result.data}`);
          }
        }
        return true;
      };
      const id = await taskSystem.add(
        {
          type: "update",
          name: data.name,
          target: data.target.map((item) => `${item.type}:${item.name}`).join(","),
          operatorIp: ip
        },
        async (options, emitLog) => {
          try {
            await performUpdate(options, emitLog);
            await taskSystem.update.logs(options.id, "\u4EFB\u52A1\u6267\u884C\u6210\u529F");
            return true;
          } catch (error) {
            await taskSystem.update.logs(options.id, `\u4EFB\u52A1\u6267\u884C\u5931\u8D25: ${error.message}`);
            return false;
          }
        }
      );
      return handleReturn2(res, true, "\u66F4\u65B0\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1", id);
    };
    updateAll = async (_, log3, options) => {
      const categorizePlugins = async () => {
        const list2 = await getPlugins("all", true, true);
        const git3 = [];
        const npm3 = ["node-karin"];
        for (const item of list2) {
          if (item.type === "npm") {
            npm3.push(item.name);
          } else if (item.type === "git") {
            git3.push(item.name);
          }
        }
        return { npm: npm3, git: git3 };
      };
      const updateNpmPlugins = async (npmPlugins) => {
        if (npmPlugins.length === 0) return;
        log3(`* \u5F00\u59CB\u66F4\u65B0NPM\u63D2\u4EF6\uFF0C\u5171${npmPlugins.length}\u4E2A`);
        const args = ["update", npmPlugins.join("@latest "), "--save"];
        if (isWorkspace()) args.push("-w");
        await spawnProcess("pnpm", args, {}, log3);
      };
      const updateGitPlugin2 = async (pluginName) => {
        const cwd = path4.join(karinPathPlugins, pluginName);
        const result = await gitPull(cwd, { force: options?.force, timeout: 60 * 1e3 });
        if (result.status) {
          return `\u66F4\u65B0 ${pluginName}(git) \u63D2\u4EF6\u6210\u529F: ${result.hash.before} -> ${result.hash.after}`;
        }
        return `\u66F4\u65B0 ${pluginName}(git) \u63D2\u4EF6\u5931\u8D25: ${result.data}`;
      };
      const updateGitPlugins = async (gitPlugins) => {
        if (gitPlugins.length === 0) return;
        log3(`* \u5F00\u59CB\u66F4\u65B0Git\u63D2\u4EF6\uFF0C\u5171${gitPlugins.length}\u4E2A`);
        for (const item of gitPlugins) {
          const resultMessage = await updateGitPlugin2(item);
          log3(resultMessage);
        }
        log3("\u5168\u90E8git\u63D2\u4EF6\u66F4\u65B0\u5B8C\u6210");
      };
      const { npm: npm2, git: git2 } = await categorizePlugins();
      try {
        await updateNpmPlugins(npm2);
        await updateGitPlugins(git2);
      } catch (error) {
        log3(`* \u53D1\u751F\u9519\u8BEF: ${error instanceof Error ? error.message : String(error)}`);
      }
      return true;
    };
  }
});

// src/plugin/system/market.ts
var PLUGIN_SOURCES, CACHE_TTL2, getPluginMarket;
var init_market = __esm({
  "src/plugin/system/market.ts"() {
    init_key();
    init_request5();
    PLUGIN_SOURCES = [
      "https://registry.npmmirror.com/@karinjs/plugins-list/latest",
      "https://registry.npmjs.com/@karinjs/plugins-list/latest",
      "https://mirrors.cloud.tencent.com/npm/@karinjs/plugins-list/latest"
    ];
    CACHE_TTL2 = process.env.PLUGIN_MARKET_CACHE_TTL ? Number(process.env.PLUGIN_MARKET_CACHE_TTL) : 12 * 60 * 60;
    getPluginMarket = async (forceUpdate = false) => {
      const { redis: redis3 } = await Promise.resolve().then(() => (init_redis3(), redis_exports));
      if (!forceUpdate) {
        const cachedData = await redis3.get(REDIS_PLUGIN_LIST_CACHE_KEY);
        if (cachedData) {
          const data = JSON.parse(cachedData);
          if (data) return data;
        }
      }
      const results = await raceRequest(PLUGIN_SOURCES, { method: "get" });
      if (!results) throw new Error("\u65E0\u6CD5\u4ECE\u4EFB\u4F55\u6E90\u83B7\u53D6\u63D2\u4EF6\u5217\u8868");
      await redis3.set(REDIS_PLUGIN_LIST_CACHE_KEY, JSON.stringify(results.data), { EX: CACHE_TTL2 });
      logger.debug(`[\u63D2\u4EF6\u5217\u8868] \u6570\u636E\u5DF2\u7F13\u5B58\uFF0C\u6709\u6548\u671F${CACHE_TTL2}\u79D2`);
      return results.data;
    };
  }
});

// src/plugin/system/index.ts
var init_system3 = __esm({
  "src/plugin/system/index.ts"() {
    init_market();
    init_cache();
  }
});
var installMarket, installNpm, installGit, installApp;
var init_installMarket = __esm({
  "src/server/plugins/admin/installMarket.ts"() {
    init_env2();
    init_tool();
    init_root();
    init_request5();
    init_fsSync();
    init_file();
    init_task();
    init_system3();
    init_load();
    installMarket = async (res, data, ip) => {
      const market = await getPluginMarket(true);
      const plugin = market.plugins.find((item) => item.name === data.target);
      if (!plugin) {
        return handleReturn2(
          res,
          false,
          "\u63D2\u4EF6\u5305\u4E0D\u5B58\u5728"
        );
      }
      if (data.pluginType === "app" && plugin.type === "app") {
        return installApp(res, plugin, data, ip);
      }
      if (data.pluginType === "npm" && plugin.type === "npm") {
        if (Array.isArray(plugin.allowBuild) && plugin.allowBuild.length) {
          data.allowBuild = plugin.allowBuild;
        }
        return installNpm(res, plugin, data, ip);
      }
      if (data.pluginType === "git" && plugin.type === "git") {
        return installGit(res, plugin, data, ip);
      }
    };
    installNpm = async (res, _, data, ip) => {
      const id = await taskSystem.add(
        {
          type: "install",
          name: data.name,
          target: data.target,
          operatorIp: ip
        },
        async (_2, emitLog) => {
          const args = ["add", data.target, "--save"];
          if (isWorkspace()) args.push("-w");
          if (Array.isArray(data.allowBuild) && data.allowBuild.length && isPnpm10()) {
            data.allowBuild.forEach((pkg2) => args.unshift(`--allow-build=${pkg2}`));
          }
          let IS_ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF = false;
          await spawnProcess("pnpm", args, {}, emitLog, () => {
            IS_ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF = true;
          });
          if (IS_ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF) {
            emitLog("\u68C0\u6D4B\u5230 ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF \u9519\u8BEF\uFF0C\u5C1D\u8BD5\u4FEE\u590D...");
            emitLog("\u6267\u884C pnpm install -f \u5F3A\u5236\u91CD\u5EFA\u6A21\u5757\u76EE\u5F55");
            await spawnProcess("pnpm", ["install", "-f"], {}, emitLog);
            emitLog("\u6A21\u5757\u76EE\u5F55\u91CD\u5EFA\u5B8C\u6210\uFF0C\u91CD\u65B0\u5C1D\u8BD5\u5B89\u88C5\u63D2\u4EF6");
            await spawnProcess("pnpm", args, {}, emitLog);
            emitLog("\u5B89\u88C5\u5B8C\u6210\uFF0C\u5C1D\u8BD5\u52A0\u8F7D\u63D2\u4EF6");
          }
          await pkgHotReload("npm", data.target);
          return true;
        }
      );
      return handleReturn2(
        res,
        true,
        "\u5B89\u88C5\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1",
        id
      );
    };
    installGit = async (res, plugin, data, ip) => {
      const urls = [];
      plugin.repo.forEach((v) => {
        if (!v.type.includes("git")) return;
        urls.push(v.url);
      });
      const repo = await raceRequest(urls, {
        method: "HEAD",
        timeout: 5e3
      });
      if (repo?.status !== 200) {
        return handleReturn2(
          res,
          false,
          "\u6D4B\u8BD5\u8BBF\u95EE\u4ED3\u5E93\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u5F53\u524D\u7F51\u7EDC\u73AF\u5883\u662F\u5426\u6B63\u5E38"
        );
      }
      const id = await taskSystem.add(
        {
          type: "install",
          name: data.name,
          target: data.target,
          operatorIp: ip
        },
        async (_, emitLog) => {
          const args = ["clone", "--depth=1", repo.config.url, `./plugins/${plugin.name}`];
          await spawnProcess(
            "git",
            args,
            {},
            emitLog
          );
          await pkgHotReload("git", plugin.name);
          return true;
        }
      );
      return handleReturn2(
        res,
        true,
        "\u5B89\u88C5\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1",
        id
      );
    };
    installApp = async (res, plugin, data, ip) => {
      if (!data.urls || !Array.isArray(data.urls)) {
        return handleReturn2(
          res,
          false,
          "app\u63D2\u4EF6\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A"
        );
      }
      let urls = plugin.files.filter((item) => data.urls.includes(item.url));
      if (!urls.length) {
        return handleReturn2(
          res,
          false,
          "\u8BF7\u4F20\u9012\u6B63\u786E\u7684app\u63D2\u4EF6\u540D\u79F0"
        );
      }
      let isRace = false;
      for (const app5 of urls) {
        if (app5.url.startsWith("https://raw.githubusercontent.com")) {
          isRace = true;
          break;
        }
      }
      if (isRace) {
        const result = await getFastGithub("raw");
        urls = urls.map((item) => {
          return {
            ...item,
            url: item.url.startsWith("https://raw.githubusercontent.com") ? result.raw(item.url) : item.url
          };
        });
      }
      const id = await taskSystem.add(
        {
          type: "install",
          name: data.name,
          target: data.target,
          operatorIp: ip
        },
        async (_, emitLog) => {
          const msg = ["\u5B89\u88C5\u4EFB\u52A1\u6267\u884C\u4E2D"];
          const dir = path4.join(karinPathPlugins, "karin-plugin-example");
          mkdirSync(dir);
          emitLog("\u5F00\u59CB\u4E0B\u8F7D\u63D2\u4EF6\u6587\u4EF6...");
          await Promise.all(urls.map(async (app5) => {
            const filename2 = path4.basename(app5.url);
            const fileUrl = path4.join(dir, filename2);
            emitLog(`\u6B63\u5728\u4E0B\u8F7D: ${filename2}`);
            const result = await downloadFile(app5.url, fileUrl);
            if (!result.success) {
              let err = `${filename2} \u4E0B\u8F7D\u5931\u8D25: `;
              if (result.data instanceof AxiosError) {
                err += result.data.message;
              } else if (result.data instanceof Error) {
                err += result.data.message || result.data.stack || "\u672A\u77E5\u9519\u8BEF";
              } else {
                err += String(result.data);
              }
              logger.error(`[install] \u4E0B\u8F7Dapp\u63D2\u4EF6\u5931\u8D25:
  url: ${app5.url}
  message: ${err}`);
              msg.push(err);
              emitLog(err);
              return;
            }
            msg.push(`${app5.url} \u4E0B\u8F7D\u6210\u529F`);
            emitLog(`${app5.url} \u4E0B\u8F7D\u6210\u529F`);
          }));
          emitLog("\u5B89\u88C5\u5B8C\u6210");
          return true;
        }
      );
      return handleReturn2(
        res,
        true,
        "\u5B89\u88C5\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1",
        id
      );
    };
  }
});
var installCustom, installNpm2, installGit2, installApp2;
var init_installCustom = __esm({
  "src/server/plugins/admin/installCustom.ts"() {
    init_env2();
    init_tool();
    init_root();
    init_fsSync();
    init_file();
    init_task();
    init_load();
    installCustom = async (res, data, ip) => {
      if (data.pluginType === "app") {
        return installApp2(res, data, ip);
      }
      if (data.pluginType === "npm") {
        return installNpm2(res, data, ip);
      }
      if (data.pluginType === "git") {
        return installGit2(res, data, ip);
      }
    };
    installNpm2 = async (res, data, ip) => {
      const id = await taskSystem.add(
        {
          type: "install",
          name: data.name,
          target: data.target,
          operatorIp: ip
        },
        async (_, emitLog) => {
          let pkg2 = data.target;
          if (data.version) pkg2 += `@${data.version}`;
          const args = ["add", pkg2, "--save"];
          if (isWorkspace()) args.push("-w");
          if (data.registry) args.push(`--registry=${data.registry}`);
          if (Array.isArray(data.allowBuild) && data.allowBuild.length && isPnpm10()) {
            data.allowBuild.forEach((pkg3) => args.unshift(`--allow-build=${pkg3}`));
          }
          let IS_ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF = false;
          await spawnProcess("pnpm", args, {}, emitLog, () => {
            IS_ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF = true;
          });
          if (IS_ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF) {
            emitLog("\u68C0\u6D4B\u5230 ERR_PNPM_PUBLIC_HOIST_PATTERN_DIFF \u9519\u8BEF\uFF0C\u5C1D\u8BD5\u4FEE\u590D...");
            emitLog("\u6267\u884C pnpm install -f \u5F3A\u5236\u91CD\u5EFA\u6A21\u5757\u76EE\u5F55");
            await spawnProcess("pnpm", ["install", "-f"], {}, emitLog);
            emitLog("\u6A21\u5757\u76EE\u5F55\u91CD\u5EFA\u5B8C\u6210\uFF0C\u91CD\u65B0\u5C1D\u8BD5\u5B89\u88C5\u63D2\u4EF6");
            await spawnProcess("pnpm", args, {}, emitLog);
            emitLog("\u5B89\u88C5\u5B8C\u6210\uFF0C\u5C1D\u8BD5\u52A0\u8F7D\u63D2\u4EF6");
          }
          await pkgHotReload("npm", data.target);
          return true;
        }
      );
      return handleReturn2(res, true, "\u5B89\u88C5\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1", id);
    };
    installGit2 = async (res, data, ip) => {
      const pkgName = data.target || path4.basename(data.repo).replace(".git", "");
      if (!pkgName.startsWith("karin-plugin-")) {
        return handleReturn2(res, false, "\u63D2\u4EF6\u540D\u79F0\u5FC5\u987B\u4EE5karin-plugin-\u5F00\u5934");
      }
      const id = await taskSystem.add(
        {
          type: "install",
          name: data.name,
          target: data.target,
          operatorIp: ip
        },
        async (_, emitLog) => {
          const args = [
            data.branch ? `-b ${data.branch}` : "",
            "clone",
            "--depth=1",
            data.repo,
            `./plugins/${pkgName}`
          ];
          await spawnProcess("git", args, {}, emitLog);
          await pkgHotReload("git", pkgName);
          return true;
        }
      );
      return handleReturn2(res, true, "\u5B89\u88C5\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1", id);
    };
    installApp2 = async (res, data, ip) => {
      if (!data.jsUrl) {
        return handleReturn2(res, false, "jsUrl\u4E0D\u80FD\u4E3A\u7A7A");
      }
      let filename2 = data.target || path4.basename(data.jsUrl);
      if (!filename2.endsWith(".js")) {
        filename2 += ".js";
      }
      const id = await taskSystem.add(
        {
          type: "install",
          name: data.name,
          target: data.target,
          operatorIp: ip
        },
        async (_, emitLog) => {
          const dir = path4.join(karinPathPlugins, "karin-plugin-example");
          const fileUrl = path4.join(dir, filename2);
          mkdirSync(dir);
          emitLog(`\u5F00\u59CB\u4E0B\u8F7D\u63D2\u4EF6\u6587\u4EF6: ${filename2}`);
          const result = await downloadFile(data.jsUrl, fileUrl);
          if (!result.success) {
            let msg = "app\u63D2\u4EF6\u4E0B\u8F7D\u5931\u8D25: ";
            if (result.data instanceof AxiosError) {
              msg += result.data.message;
            } else if (result.data instanceof Error) {
              msg += result.data.message || result.data.stack || "\u672A\u77E5\u9519\u8BEF";
            } else {
              msg += String(result.data);
            }
            logger.error(`[install] \u4E0B\u8F7Dapp\u63D2\u4EF6\u5931\u8D25:
  url: ${data.jsUrl}
  message: ${msg}`);
            emitLog(msg);
            return false;
          }
          emitLog(`\u4E0B\u8F7D\u5B8C\u6210: ${data.jsUrl}`);
          return true;
        }
      );
      return handleReturn2(res, true, "\u5B89\u88C5\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1", id);
    };
  }
});

// src/server/plugins/admin/install.ts
var install;
var init_install2 = __esm({
  "src/server/plugins/admin/install.ts"() {
    init_installMarket();
    init_installCustom();
    init_tool();
    install = async (res, data, ip = "0.0.0.0") => {
      if (!validatePluginRequest(res, data.name, data.target, data.pluginType, ["npm", "git", "app"])) {
        return;
      }
      if (data.source === "market") {
        return installMarket(res, data, ip);
      }
      if (data.source === "custom") {
        return installCustom(res, data, ip);
      }
      return handleReturn2(res, false, "\u65E0\u6548\u7684\u5B89\u88C5\u6765\u6E90");
    };
  }
});
var uninstall;
var init_uninstall = __esm({
  "src/server/plugins/admin/uninstall.ts"() {
    init_list();
    init_root();
    init_task();
    init_tool();
    uninstall = async (res, name, target, operatorIp = "0.0.0.0") => {
      if (!Array.isArray(target) || target.length < 1) {
        return handleReturn2(res, false, "\u65E0\u6548\u8BF7\u6C42: \u63D2\u4EF6\u76EE\u6807\u9519\u8BEF");
      }
      const performUninstall = async (emitLog) => {
        const npm2 = [];
        const git2 = [];
        const app5 = [];
        const notExist = [];
        const list2 = await getPlugins("all");
        target.forEach(async (v) => {
          if (v.type === "npm") {
            list2.includes(`${v.type}:${v.name}`) ? npm2.push(v.name) : notExist.push(v.name);
            return;
          }
          if (v.type === "git") {
            list2.includes(`${v.type}:${v.name}`) ? git2.push(v.name) : notExist.push(v.name);
            return;
          }
          if (v.type === "app") {
            app5.push(v.name);
            return;
          }
          notExist.push(v.name);
        });
        await spawnProcess("pnpm", ["remove", ...npm2], { timeout: 60 * 1e3 }, emitLog);
        const pkg2 = path4.join(process.cwd(), "package.json");
        if (fs5.existsSync(pkg2)) {
          const content = fs5.readFileSync(pkg2, "utf-8");
          const data = JSON.parse(content);
          const delDep = (obj) => {
            Object.keys(obj).forEach((key) => {
              if (npm2.includes(key)) {
                delete obj[key];
              }
            });
          };
          delDep(data.dependencies);
          delDep(data.devDependencies);
          delDep(data.peerDependencies);
          fs5.writeFileSync(pkg2, JSON.stringify(data, null, 2), "utf-8");
        }
        for (const v of git2) {
          emitLog("-----------------------");
          emitLog(`\u5F00\u59CB\u5378\u8F7D git \u63D2\u4EF6: ${v}`);
          if (v.includes("..")) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: \u6587\u4EF6\u540D\u79F0\u5B58\u5728\u8DEF\u5F84\u7A7F\u8D8A\u98CE\u9669`);
            continue;
          }
          const dir = path4.join(karinPathPlugins, v);
          if (!fs5.existsSync(path4.join(dir, ".git"))) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: \u975Egit\u4ED3\u5E93`);
            continue;
          }
          try {
            await fs5.promises.rm(dir, { recursive: true, force: true });
            emitLog(`\u5378\u8F7D ${v} \u6210\u529F`);
          } catch (error) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: ${error.message}`);
          }
          emitLog("-----------------------\n\n");
        }
        for (const v of app5) {
          emitLog("-----------------------");
          emitLog(`\u5F00\u59CB\u5378\u8F7D app \u63D2\u4EF6: ${v}`);
          if (v.includes("..")) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: \u6587\u4EF6\u540D\u79F0\u5B58\u5728\u8DEF\u5F84\u7A7F\u8D8A\u98CE\u9669`);
            continue;
          }
          const arr = v.split("/");
          const [pkg3, file2] = arr;
          if (arr.length !== 2 || !pkg3 || !file2) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: \u683C\u5F0F\u9519\u8BEF`);
            continue;
          }
          if (!list2.includes(`app:${pkg3}`)) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: \u63D2\u4EF6\u4E0D\u5B58\u5728`);
            continue;
          }
          const dir = path4.join(karinPathPlugins, pkg3);
          if (!fs5.existsSync(path4.join(dir, file2))) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: \u6587\u4EF6\u4E0D\u5B58\u5728`);
            continue;
          }
          const ext = path4.extname(file2);
          if (![".js", ".mjs", ".cjs", ".ts", ".cts", ".mts"].includes(ext)) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: \u9519\u8BEF\u7684\u6587\u4EF6\u7C7B\u578B`);
            continue;
          }
          try {
            await fs5.promises.unlink(path4.join(dir, file2));
            emitLog(`\u5378\u8F7D ${v} \u6210\u529F`);
          } catch (error) {
            emitLog(`\u5378\u8F7D ${v} \u5931\u8D25: ${error.message}`);
          }
          emitLog("-----------------------\n\n");
        }
        if (notExist.length) {
          notExist.unshift("\u4EE5\u4E0B\u63D2\u4EF6\u4E0D\u5B58\u5728:");
          emitLog(notExist.join("\n") + "\n\n");
        }
        emitLog("\u5378\u8F7D\u4EFB\u52A1\u5B8C\u6210");
      };
      const id = await taskSystem.add(
        {
          type: "uninstall",
          name,
          target: target.map((v) => `${v.type}:${v.name}`).join(","),
          operatorIp
        },
        async (options, emitLog) => {
          try {
            await performUninstall(emitLog);
            await taskSystem.update.logs(options.id, "\u4EFB\u52A1\u6267\u884C\u6210\u529F");
            return true;
          } catch (error) {
            await taskSystem.update.logs(options.id, `\u4EFB\u52A1\u6267\u884C\u5931\u8D25: ${error.message}`);
            return false;
          }
        }
      );
      return handleReturn2(res, true, "\u5378\u8F7D\u4EFB\u52A1\u5DF2\u521B\u5EFA\uFF0C\u8BF7\u901A\u8FC7taskId\u6267\u884C\u4EFB\u52A1", id);
    };
  }
});

// src/server/plugins/admin/router.ts
var pluginAdminRouter;
var init_router2 = __esm({
  "src/server/plugins/admin/router.ts"() {
    init_update3();
    init_install2();
    init_uninstall();
    init_tool();
    pluginAdminRouter = (req, res) => {
      if (req.body.type === "uninstall") {
        return uninstall(res, req.body.name, req.body.target, req.ip);
      }
      if (req.body.type === "update") {
        return update(res, req.body, req.ip);
      }
      if (req.body.type !== "install") {
        return handleReturn2(res, false, "\u65E0\u6548\u8BF7\u6C42: \u63D2\u4EF6\u7C7B\u578B\u9519\u8BEF");
      }
      return install(res, req.body, req.ip);
    };
  }
});
var getRegistry, getNpmRegistry, getNpmLatestVersion;
var init_registry = __esm({
  "src/utils/npm/registry.ts"() {
    init_exec();
    getRegistry = async () => {
      if (process.env.npm_config_registry) {
        return process.env.npm_config_registry;
      }
      const registry = await exec("npm config get registry");
      process.env.npm_config_registry = registry.stdout;
      return registry.stdout;
    };
    getNpmRegistry = async (name) => {
      const registry = await getRegistry();
      const response = await axios8.get(`${registry}/${name}`);
      return response.data;
    };
    getNpmLatestVersion = async (name) => {
      try {
        const result = await getNpmRegistry(name);
        return result["dist-tags"].latest;
      } catch (error) {
        logger.debug(new Error(`\u83B7\u53D6${name}\u6700\u65B0\u7248\u672C\u5931\u8D25`, { cause: error }));
        return null;
      }
    };
    getRegistry();
  }
});
var getDependenciesListRouter, getDependenciesInfo, getCache, setCache;
var init_list2 = __esm({
  "src/server/dependencies/list.ts"() {
    init_exec();
    init_list();
    init_require();
    init_response();
    init_redis();
    init_registry();
    getDependenciesListRouter = async (req, res) => {
      try {
        const cache10 = await getCache(req, res);
        if (cache10) {
          return createSuccessResponse(res, cache10);
        }
        const { stdout, error } = await exec("pnpm list --depth=0 --json");
        if (error) {
          return createBadRequestResponse(res, error.message);
        }
        const promises = [];
        let list2 = [];
        const pkg2 = requireFileSync("./package.json", { force: true });
        const dependencies = JSON.parse(stdout);
        for (const dependency of dependencies) {
          Object.entries(dependency).forEach(([key, value]) => {
            if (typeof value !== "object") {
              return;
            }
            Object.entries(value).forEach(([k, v]) => {
              promises.push(getDependenciesInfo(
                pkg2,
                list2,
                k,
                v,
                key
              ));
            });
          });
        }
        await Promise.allSettled(promises);
        const npmPlugin = await getPlugins("npm");
        list2.forEach((item) => {
          item.isKarinPlugin = npmPlugin.some((plugin) => plugin === `npm:${item.name}`);
        });
        const typeWeightMap = {
          dependencies: 1,
          // 生产依赖
          devDependencies: 2,
          // 开发依赖
          peerDependencies: 3,
          // 对等依赖
          optionalDependencies: 4,
          // 可选依赖
          unsavedDependencies: 5
          // 临时依赖
        };
        list2 = lodash3.sortBy(list2, [
          // 1. 首先按照是否是node-karin插件排序（取反，使node-karin排在前面）
          (item) => !(item.name === "node-karin"),
          // 2. 然后按照是否是karin插件排序
          "isKarinPlugin",
          // 3. 然后按照依赖类型权重排序
          (item) => typeWeightMap[item.type],
          // 4. 最后按照名称排序
          "name"
        ]);
        await setCache(list2);
        return createSuccessResponse(res, list2);
      } catch (error) {
        logger.error("[getDependenciesListRouter]", error);
        return createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
    getDependenciesInfo = async (pkg2, list2, key, value, type) => {
      if (!key || !value?.version) {
        return;
      }
      try {
        const registry = await getNpmRegistry(value.from);
        const versions = Object.keys(registry.versions);
        const latest = versions.slice(-15).filter(Boolean);
        let packageValue = "";
        if (pkg2.dependencies?.[key]) {
          type = "dependencies";
          packageValue = pkg2.dependencies?.[key];
        } else if (pkg2.devDependencies?.[key]) {
          type = "devDependencies";
          packageValue = pkg2.devDependencies?.[key];
        } else if (pkg2.peerDependencies?.[key]) {
          type = "peerDependencies";
          packageValue = pkg2.peerDependencies?.[key];
        } else if (pkg2.optionalDependencies?.[key]) {
          type = "optionalDependencies";
          packageValue = pkg2.optionalDependencies?.[key];
        }
        list2.push({
          name: key,
          type,
          from: value.from,
          current: value.version,
          isKarinPlugin: false,
          latest,
          packageValue
        });
      } catch (error) {
        logger.debug(`[getDependenciesInfo] \u83B7\u53D6${key}\u7684\u7248\u672C\u4FE1\u606F\u5931\u8D25`, error);
      }
    };
    getCache = async (req, _) => {
      if (req.body?.force) {
        return null;
      }
      const { redis: redis3 } = await Promise.resolve().then(() => (init_redis3(), redis_exports));
      const cache10 = await redis3.get(REDIS_DEPENDENCIES_LIST_CACHE_KEY);
      if (cache10) {
        const data = JSON.parse(cache10);
        if (!Array.isArray(data)) {
          await redis3.del(REDIS_DEPENDENCIES_LIST_CACHE_KEY);
          return null;
        }
        return data;
      }
      return null;
    };
    setCache = async (data) => {
      const { redis: redis3 } = await Promise.resolve().then(() => (init_redis3(), redis_exports));
      await redis3.set(
        REDIS_DEPENDENCIES_LIST_CACHE_KEY,
        JSON.stringify(data),
        { EX: REDIS_DEPENDENCIES_LIST_CACHE_EXPIRE }
      );
    };
  }
});
var manageDependenciesRouter, installDependencies, removeDependencies, addDependencies;
var init_manage2 = __esm({
  "src/server/dependencies/manage.ts"() {
    init_env2();
    init_task();
    init_tool();
    manageDependenciesRouter = async (req, res) => {
      const { type, data } = req.body;
      if (type === "add") {
        return await addDependencies(res, data, req.ip);
      }
      if (type === "upgrade") {
        return await installDependencies(res, data, req.ip);
      }
      if (type === "remove") {
        return await removeDependencies(res, data, req.ip);
      }
      return handleReturn2(res, false, "\u65E0\u6548\u8BF7\u6C42\uFF1A\u4E0D\u652F\u6301\u7684\u64CD\u4F5C\u7C7B\u578B");
    };
    installDependencies = async (res, dependencies, ip) => {
      try {
        const packagesToInstall = dependencies.map((dep) => `${dep.name}@${dep.version || "latest"}`).join(" ");
        const id = await taskSystem.add(
          {
            type: "install-dependencies",
            name: "\u5B89\u88C5\u4F9D\u8D56",
            target: packagesToInstall,
            operatorIp: ip
          },
          async (_, emitLog) => {
            const args = ["install", ...packagesToInstall.split(" ")];
            if (isWorkspace()) args.push("-w");
            await spawnProcess("pnpm", args, {}, emitLog);
            logger.mark(`\u5B89\u88C5\u4F9D\u8D56 ${logger.green(packagesToInstall)} \u5B8C\u6210`);
            return true;
          }
        );
        return handleReturn2(res, true, "\u5B89\u88C5\u4EFB\u52A1\u5DF2\u521B\u5EFA", id);
      } catch (error) {
        logger.error("[installDependencies]", error);
        logger.mark(`\u5B89\u88C5\u4F9D\u8D56 ${logger.red(dependencies.join(" "))} \u5931\u8D25`);
        return handleReturn2(res, false, `\u5B89\u88C5\u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`);
      }
    };
    removeDependencies = async (res, dependencies, ip) => {
      try {
        const packagesToRemove = dependencies.join(" ");
        const id = await taskSystem.add(
          {
            type: "remove-dependencies",
            name: "\u5220\u9664\u4F9D\u8D56",
            target: packagesToRemove,
            operatorIp: ip
          },
          async (_, emitLog) => {
            const args = ["remove", ...packagesToRemove.split(" ")];
            if (isWorkspace()) args.push("-w");
            await spawnProcess("pnpm", args, {}, emitLog);
            logger.mark(`\u5220\u9664\u4F9D\u8D56 ${logger.yellow(packagesToRemove)} \u5B8C\u6210`);
            return true;
          }
        );
        return handleReturn2(res, true, "\u5220\u9664\u4EFB\u52A1\u5DF2\u521B\u5EFA", id);
      } catch (error) {
        logger.error("[removeDependencies]", error);
        logger.mark(`\u5220\u9664\u4F9D\u8D56 ${logger.red(dependencies.join(" "))} \u5931\u8D25`);
        return handleReturn2(res, false, `\u5220\u9664\u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`);
      }
    };
    addDependencies = async (res, dependencies, ip) => {
      try {
        if (!dependencies.name || !dependencies.location) {
          return handleReturn2(res, false, "\u65E0\u6548\u8BF7\u6C42\uFF1A\u7F3A\u5C11\u5FC5\u8981\u53C2\u6570");
        }
        const name = `${dependencies.name}@${dependencies.version || "latest"}`;
        const id = await taskSystem.add(
          {
            type: "add-dependencies",
            name: "\u4F9D\u8D56\u65B0\u589E",
            target: name,
            operatorIp: ip
          },
          async (_, emitLog) => {
            const args = ["add", name];
            if (Array.isArray(dependencies.allowBuild) && dependencies.allowBuild.length && isPnpm10()) {
              dependencies.allowBuild.forEach((pkg2) => args.unshift(`--allow-build=${pkg2}`));
            }
            if (dependencies.location === "devDependencies") {
              args.push("-D");
            } else if (dependencies.location === "optionalDependencies") {
              args.push("-O");
            }
            if (isWorkspace()) args.push("-w");
            await spawnProcess("pnpm", args, {}, emitLog);
            const depDir = path4.join(process.cwd(), "packages", dependencies.name, "package.json");
            try {
              const pkg2 = JSON.parse(fs5.readFileSync(depDir, "utf-8"));
              if (!pkg2.peerDependencies) return true;
              await spawnProcess("pnpm", ["install"], {}, emitLog);
            } catch (error) {
              logger.error("[addDependencies]", error);
              emitLog(util5.format(error));
            }
            logger.mark(`\u65B0\u589E\u4F9D\u8D56 ${logger.green(dependencies.name)} \u5B8C\u6210`);
            return true;
          }
        );
        return handleReturn2(res, true, "\u6DFB\u52A0\u4EFB\u52A1\u5DF2\u521B\u5EFA", id);
      } catch (error) {
        logger.error("[addDependencies]", error);
        logger.mark(`\u65B0\u589E\u4F9D\u8D56 ${logger.red(dependencies.name)} \u5931\u8D25`);
        return handleReturn2(res, false, `\u6DFB\u52A0\u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`);
      }
    };
  }
});

// src/server/task/list.ts
var taskStatusMap, activeConnections2, MAX_CONNECTIONS, taskListRouter, taskRunRouter, taskLogsRouter, taskDeleteRouter;
var init_list3 = __esm({
  "src/server/task/list.ts"() {
    init_task();
    init_response();
    taskStatusMap = {
      pending: "\u5F85\u6267\u884C(pending)",
      running: "\u6267\u884C\u4E2D(running)",
      success: "\u6210\u529F(success)",
      failed: "\u5931\u8D25(failed)",
      canceled: "\u5DF2\u53D6\u6D88(canceled)",
      timeout: "\u8D85\u65F6(timeout)"
    };
    activeConnections2 = /* @__PURE__ */ new Map();
    MAX_CONNECTIONS = 3;
    taskListRouter = async (_req, res) => {
      const list2 = await taskSystem.list();
      createSuccessResponse(res, list2);
    };
    taskRunRouter = async (req, res) => {
      const id = req.query.id;
      const lastIndex = req.query.lastIndex;
      if (typeof id !== "string" || id.length === 0) {
        return createServerErrorResponse(res, "id \u4E3A\u7A7A");
      }
      const task2 = await taskSystem.get(id);
      if (!task2) {
        return createServerErrorResponse(res, "\u4EFB\u52A1\u4E0D\u5B58\u5728");
      }
      const totalConnections = [...activeConnections2.values()].reduce((sum, connection) => sum + connection.count, 0);
      if (!lastIndex && totalConnections >= MAX_CONNECTIONS) {
        return createServerErrorResponse(res, `\u670D\u52A1\u5668\u8D1F\u8F7D\u8FC7\u9AD8\uFF0C\u5F53\u524D\u8FDE\u63A5\u6570\u5DF2\u8FBE\u4E0A\u9650(${MAX_CONNECTIONS})\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5`);
      }
      if (await taskSystem.exists(task2.type, task2.target, ["running"])) {
        return createServerErrorResponse(res, "\u5DF2\u6709\u76F8\u540C\u4EFB\u52A1\u6B63\u5728\u6267\u884C\uFF0C\u8BF7\u52FF\u91CD\u590D\u521B\u5EFA\u4EFB\u52A1...");
      }
      try {
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.flushHeaders();
        if (!activeConnections2.has(id)) {
          activeConnections2.set(id, {
            count: 0,
            logs: [],
            status: task2.status
          });
        }
        const connectionInfo = activeConnections2.get(id);
        connectionInfo.count++;
        if (lastIndex && connectionInfo.logs.length > 0) {
          const lastPos = parseInt(lastIndex, 10) || 0;
          if (lastPos < connectionInfo.logs.length) {
            const missedLogs = connectionInfo.logs.slice(lastPos);
            missedLogs.forEach((log3) => res.write(`data: ${log3}

`));
          }
        } else {
          res.write("data: \u4EFB\u52A1\u521B\u5EFA\u6210\u529F: \u5F00\u59CB\u6267\u884C...\n\n");
        }
        let sseOpen = true;
        req.on("close", () => {
          sseOpen = false;
          if (activeConnections2.has(id)) {
            const info = activeConnections2.get(id);
            info.count = Math.max(0, info.count - 1);
            if (info.count === 0 && info.status !== "running" && info.status !== "pending") {
              activeConnections2.delete(id);
            }
          }
          logger.debug(`[task][${id}] \u5BA2\u6237\u7AEF\u65AD\u5F00\u8FDE\u63A5\uFF0C\u5F53\u524D\u8FDE\u63A5\u6570: ${activeConnections2.get(id)?.count || 0}`);
        });
        taskSystem.run(
          id,
          (log3) => {
            if (activeConnections2.has(id)) {
              activeConnections2.get(id).logs.push(log3);
            }
            sseOpen && res.write(`data: ${log3}

`);
          },
          (status) => {
            const tips2 = taskStatusMap[status];
            logger.debug(`[task][${id}] \u72B6\u6001\u53D8\u66F4: ${tips2}`);
            if (activeConnections2.has(id)) {
              activeConnections2.get(id).status = status;
            }
            if (!sseOpen) {
              logger.debug(`[task][${id}] sse\u5DF2\u5173\u95ED \u505C\u6B62\u53D1\u9001\u65E5\u5FD7`);
              return;
            }
            res.write(`data: \u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${tips2}

`);
            if (status !== "running" && status !== "pending") {
              res.write("data: \u4EFB\u52A1\u6267\u884C\u5B8C\u6210\uFF0C\u7ED3\u675F\u8FDE\u63A5\n\n");
              res.end("data: end\n\n");
              if (activeConnections2.has(id) && activeConnections2.get(id).count <= 1) {
                activeConnections2.delete(id);
              }
            }
          }
        );
      } catch (error) {
        if (activeConnections2.has(id)) {
          activeConnections2.get(id).count = Math.max(0, activeConnections2.get(id).count - 1);
        }
        if (res.headersSent) {
          res.write(`data: ${error instanceof Error ? error.message : String(error)} 

`);
          res.end("data: end\n\n");
          return;
        }
        createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
    taskLogsRouter = async (req, res) => {
      const { id } = req.params;
      if (!id || typeof id !== "string" || id.length === 0) {
        return createServerErrorResponse(res, "\u4EFB\u52A1ID\u4E0D\u80FD\u4E3A\u7A7A");
      }
      try {
        const task2 = await taskSystem.get(id);
        if (!task2) {
          return createServerErrorResponse(res, "\u4EFB\u52A1\u4E0D\u5B58\u5728");
        }
        if (task2.status === "running" || task2.status === "pending") {
          const logs2 = await taskSystem.logs(id);
          return createSuccessResponse(res, { logs: logs2 || "" });
        }
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.flushHeaders();
        let sseOpen = true;
        let timer = null;
        req.on("close", () => {
          sseOpen = false;
          timer && clearInterval(timer);
          logger.debug(`[task][${id}] sse\u5DF2\u5173\u95ED \u505C\u6B62\u53D1\u9001\u65E5\u5FD7`);
        });
        res.write(`data: ${[
          `\u5F53\u524D\u72B6\u6001: ${taskStatusMap[task2.status]}`,
          `ID: ${task2.id}`,
          `\u540D\u79F0: ${task2.name}`,
          `\u7C7B\u578B: ${task2.type}`,
          `\u76EE\u6807: ${task2.target}`,
          `\u521B\u5EFA\u65F6\u95F4: ${task2.createTime}`,
          `\u66F4\u65B0\u65F6\u95F4: ${task2.updateTime}`
        ].join("\n")} 

`);
        timer = setInterval(async () => {
          try {
            const info = await taskSystem.get(id);
            if (!info) {
              timer && clearInterval(timer);
              sseOpen && res.write("data: \u4EFB\u52A1\u4E0D\u5B58\u5728\uFF0C\u65E0\u6CD5\u83B7\u53D6\u4EFB\u52A1\u8BE6\u60C5 \n\n");
              return res.end("data: end\n\n");
            }
            if (info.status !== task2.status) {
              const logs2 = info.logs.split("\n");
              logs2.forEach((log3) => res.write(`data: ${log3} 

`));
              timer && clearInterval(timer);
              return res.end("data: end\n\n");
            }
            sseOpen && res.write("data: \u4EFB\u52A1\u6267\u884C\u4E2D\uFF0C\u8BF7\u8010\u5FC3\u7B49\u5F85... \n\n");
          } catch (error) {
            logger.error(new Error("sse\u83B7\u53D6\u65E5\u5FD7\u5931\u8D25", { cause: error }));
            timer && clearInterval(timer);
            sseOpen && res.write("data: \u83B7\u53D6\u65E5\u5FD7\u5931\u8D25 \n\n");
            return res.end("data: end\n\n");
          }
        }, 1e3);
      } catch (error) {
        logger.error(new Error("sse\u83B7\u53D6\u65E5\u5FD7\u5931\u8D25", { cause: error }));
        createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
    taskDeleteRouter = async (req, res) => {
      const { id } = req.params;
      if (!id || typeof id !== "string" || id.length === 0) {
        return createServerErrorResponse(res, "\u4EFB\u52A1ID\u4E0D\u80FD\u4E3A\u7A7A");
      }
      try {
        await taskSystem.delete(id);
        createSuccessResponse(res, "\u4EFB\u52A1\u8BB0\u5F55\u5220\u9664\u6210\u529F");
      } catch (error) {
        createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
  }
});
var getNpmrcPath, getPnpmConfigPath, getNpmConfigList, getNpmConfig, setNpmConfig;
var init_npmrc = __esm({
  "src/utils/npm/npmrc.ts"() {
    init_exec();
    getNpmrcPath = async (type, isCheck) => {
      let dir = "";
      if (type === "global") {
        const { stdout } = await exec("npm config get userconfig");
        dir = stdout.trim();
      } else {
        dir = join(process.cwd(), ".npmrc");
      }
      if (isCheck && !existsSync$1(dir)) {
        return null;
      }
      return dir;
    };
    getPnpmConfigPath = (isCheck) => {
      let dir = "";
      if (process.env.XDG_CONFIG_HOME) {
        dir = join(process.env.XDG_CONFIG_HOME, "pnpm", "rc");
      }
      const homeDir = homedir();
      const platform = process.platform;
      if (platform === "win32") {
        dir = join(homeDir, "AppData", "Local", "pnpm", "config", "rc");
      } else if (platform === "darwin") {
        dir = join(homeDir, "Library", "preferences", "pnpm", "rc");
      } else {
        dir = join(homeDir, ".config", "pnpm", "rc");
      }
      if (isCheck && !existsSync$1(dir)) {
        return null;
      }
      return dir;
    };
    getNpmConfigList = async () => {
      const list2 = [];
      const npmrc = await getNpmrcPath("global", true);
      const npmrcProject = await getNpmrcPath("project", true);
      const pnpmrc = getPnpmConfigPath(true);
      if (npmrc) list2.push({ path: npmrc, type: "global", description: "npm\u5168\u5C40\u914D\u7F6E" });
      if (pnpmrc) list2.push({ path: pnpmrc, type: "pnpm", description: "pnpm\u5168\u5C40\u914D\u7F6E" });
      if (npmrcProject) list2.push({ path: npmrcProject, type: "project", description: "\u5F53\u524D\u9879\u76EE\u914D\u7F6E" });
      return list2;
    };
    getNpmConfig = async (keys) => {
      if (typeof keys === "string") {
        const { stdout } = await exec(`npm config get ${keys}`, { env: {} });
        return stdout.trim();
      }
      const listResult = [];
      for (const key of keys) {
        const { stdout: value } = await exec(`npm config get ${key}`);
        listResult.push({ key, value: value.trim() });
      }
      return listResult;
    };
    setNpmConfig = async (key, value) => {
      await exec(`npm config set "${key}" "${value}"`);
    };
  }
});

// src/utils/npm/index.ts
var init_npm = __esm({
  "src/utils/npm/index.ts"() {
    init_npmrc();
    init_registry();
  }
});

// src/server/dependencies/config.ts
var getNpmrcListRouter, getNpmrcContentRouter, getNpmBaseConfigRouter, saveNpmrcRouter;
var init_config5 = __esm({
  "src/server/dependencies/config.ts"() {
    init_ini();
    init_npm();
    init_response();
    getNpmrcListRouter = async (_, res) => {
      try {
        const list2 = await getNpmConfigList();
        return createSuccessResponse(res, list2);
      } catch (error) {
        logger.error("[getNpmrcListRouter]", error);
        return createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
    getNpmrcContentRouter = async (req, res) => {
      try {
        const { path: path36 } = req.body;
        const list2 = await getNpmConfigList();
        if (!list2.find((item) => item.path === path36)) {
          return createBadRequestResponse(res, "\u6587\u4EF6\u4E0D\u5B58\u5728");
        }
        const content = ini.read(path36);
        return createSuccessResponse(res, content);
      } catch (error) {
        logger.error("[getNpmrcContentRouter]", error);
        return createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
    getNpmBaseConfigRouter = async (_, res) => {
      try {
        const [registry, proxy, httpsProxy] = await Promise.all([
          getNpmConfig("registry"),
          getNpmConfig("proxy"),
          getNpmConfig("https-proxy")
        ]);
        const data = {
          registry,
          proxy,
          "https-proxy": httpsProxy
        };
        return createSuccessResponse(res, data);
      } catch (error) {
        logger.error("[getNpmConfigRouter]", error);
        return createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
    saveNpmrcRouter = async (req, res) => {
      try {
        const { path: path36, content, baseConfig } = req.body;
        const list2 = await getNpmConfigList();
        const promises = [];
        if (baseConfig.registry) {
          promises.push(setNpmConfig("registry", baseConfig.registry));
        }
        if (baseConfig.proxy) {
          promises.push(setNpmConfig("proxy", baseConfig.proxy));
        }
        if (baseConfig["https-proxy"]) {
          promises.push(setNpmConfig("https-proxy", baseConfig["https-proxy"]));
        }
        await Promise.all(promises);
        if (path36 && content) {
          if (!list2.find((item) => item.path === path36)) {
            return createBadRequestResponse(res, "\u6587\u4EF6\u4E0D\u5B58\u5728");
          }
          ini.write(content, path36);
        }
        return createSuccessResponse(res, "\u4FDD\u5B58\u6210\u529F");
      } catch (error) {
        logger.error("[saveNpmrcRouter]", error);
        return createServerErrorResponse(res, error instanceof Error ? error.message : String(error));
      }
    };
  }
});
var getWebConfig2, defaultWebConfig, getWebConfigPath, getWebConfigMore;
var init_webConfig = __esm({
  "src/server/plugins/config/webConfig.ts"() {
    init_env2();
    init_utils();
    init_list();
    getWebConfig2 = async (name) => {
      const list2 = await getPlugins("all", true);
      const plugin = list2.find((v) => v.name === name);
      if (!plugin) return defaultWebConfig();
      if (plugin.type === "npm" || plugin.type === "git") {
        const filepath = getWebConfigPath(plugin);
        if (!filepath) return defaultWebConfig();
        return getWebConfigMore(filepath);
      }
      return defaultWebConfig();
    };
    defaultWebConfig = (exists2, path36, customComponent, defaultComponent, icon) => {
      return {
        exists: exists2 ?? false,
        path: path36 || "",
        customComponent: customComponent ?? false,
        defaultComponent: defaultComponent ?? false,
        icon: icon || {
          color: "",
          name: "star",
          size: 16
        }
      };
    };
    getWebConfigPath = (plugin) => {
      const dev = isDev();
      const pkg2 = plugin.pkgData;
      if (!pkg2.karin?.web) return null;
      if (dev) {
        if (!pkg2.karin["ts-web"]) return null;
        const filepath2 = path.join(plugin.dir, pkg2.karin["ts-web"]);
        if (!fs24.existsSync(filepath2)) return null;
        return filepath2;
      }
      const filepath = path.join(plugin.dir, pkg2.karin.web);
      if (!fs24.existsSync(filepath)) return null;
      return filepath;
    };
    getWebConfigMore = async (filepath) => {
      try {
        const web2 = await imports(filepath, { isImportDefault: true, isRefresh: isDev() });
        return defaultWebConfig(
          true,
          filepath,
          typeof web2?.customComponent === "function",
          typeof web2?.components === "function",
          web2?.icon
        );
      } catch (error) {
        logger.error(new Error("\u83B7\u53D6\u63D2\u4EF6web.config\u6587\u4EF6\u5931\u8D25", { cause: error }));
        return defaultWebConfig();
      }
    };
  }
});
var git, npm, app3, getPluginLocalList, getPluginListPluginAdmin, getLoadedCommandPluginCacheList, getFrontendInstalledPluginList;
var init_list4 = __esm({
  "src/server/plugins/detail/list.ts"() {
    init_system3();
    init_list();
    init_db();
    init_npm();
    init_webConfig();
    init_git();
    init_response();
    init_env2();
    git = async (plugin) => {
      try {
        const version2 = await getLocalCommitHash(plugin.dir, { short: true });
        const latestHash = await getRemoteCommitHash(plugin.dir, { short: true });
        return {
          type: "git",
          id: plugin.pkgData.name,
          name: plugin.name,
          version: version2,
          latestVersion: latestHash,
          webConfig: await getWebConfig2(plugin.name)
        };
      } catch (error) {
        logger.debug(`\u83B7\u53D6\u63D2\u4EF6${plugin.name}\u63D0\u4EA4\u54C8\u5E0C\u5931\u8D25`, { cache: error });
        return {
          type: "git",
          id: plugin.pkgData.name,
          name: plugin.name,
          version: "0.0.0",
          latestVersion: "0.0.0",
          webConfig: await getWebConfig2(plugin.name)
        };
      }
    };
    npm = async (plugin) => {
      return {
        type: "npm",
        id: plugin.pkgData.name,
        name: plugin.name,
        version: plugin.pkgData.version,
        latestVersion: await getNpmLatestVersion(plugin.pkgData.name) || "0.0.0",
        webConfig: defaultWebConfig()
      };
    };
    app3 = async (plugin) => {
      return plugin.apps.map((v) => {
        return {
          type: "app",
          id: plugin.name,
          name: `${plugin.name}/${path4.basename(v)}`,
          version: "",
          latestVersion: "",
          webConfig: defaultWebConfig()
        };
      });
    };
    getPluginLocalList = async (isRefresh = false) => {
      if (!isRefresh) {
        const cachedData = await redis2.get(REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY);
        if (cachedData) {
          return JSON.parse(cachedData);
        }
      }
      const list2 = [];
      const plugin = await getPlugins("all", true);
      await Promise.all(plugin.map(async (plugin2) => {
        if (plugin2.type === "git") {
          return list2.push(await git(plugin2));
        }
        if (plugin2.type === "npm") {
          return list2.push(await npm(plugin2));
        }
        if (plugin2.type === "app") {
          const result = await app3(plugin2);
          return list2.push(...result);
        }
      }));
      await redis2.set(REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY, JSON.stringify(list2), {
        EX: REDIS_PLUGIN_LIST_CACHE_EXPIRE
      });
      return list2;
    };
    getPluginListPluginAdmin = async (req, res) => {
      try {
        const { isRefresh = false } = req.body;
        const result = await getPluginLocalList(isRefresh);
        createSuccessResponse(res, result);
      } catch (error) {
        createServerErrorResponse(res, error.message);
        logger.error(error);
      }
    };
    getLoadedCommandPluginCacheList = async (_, res) => {
      try {
        const list2 = [];
        const map = {};
        cache3.command.forEach((plugin) => {
          const { name: key } = plugin.pkg;
          if (!map[key]) {
            map[key] = {};
          }
          if (!map[key][plugin.file.basename]) {
            map[key][plugin.file.basename] = [];
          }
          map[key][plugin.file.basename].push({
            pluginName: plugin.file.name,
            method: plugin.file.method
          });
        });
        Object.keys(map).forEach((key) => {
          const files = [];
          Object.keys(map[key]).forEach((file2) => {
            files.push({
              fileName: file2,
              command: map[key][file2]
            });
          });
          list2.push({
            name: key,
            files
          });
        });
        createSuccessResponse(res, list2);
      } catch (error) {
        createServerErrorResponse(res, error.message);
        logger.error(error);
      }
    };
    getFrontendInstalledPluginList = async (req, res) => {
      const isRefresh = req.body.isRefresh || false;
      try {
        if (!isRefresh) {
          const cachedData = await redis2.get(REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY_FRONTEND);
          if (cachedData) {
            return createSuccessResponse(res, JSON.parse(cachedData));
          }
        }
        const [list2, marketResult] = await Promise.all([
          getPlugins("all", false, isRefresh),
          getPluginMarket(isRefresh)
        ]);
        const marketMap = {};
        marketResult.plugins.forEach((item) => {
          marketMap[item.name] = item;
        });
        const result = await Promise.all(
          list2.map(
            async (item) => {
              const [type, name] = item.split(":");
              const market = marketMap[name];
              const webConfig = await getWebConfig2(name);
              return {
                id: name,
                name,
                type,
                isMarketPlugin: !!market,
                description: market?.description || "",
                author: {
                  name: market?.author[0].name || "",
                  home: market?.author[0].home || "",
                  avatar: market?.author[0].avatar || market?.author[0].home ? `${market?.author[0].home}.png` : ""
                },
                repoUrl: market?.repo[0].url || "",
                hasConfig: webConfig.defaultComponent,
                hasCustomComponent: false,
                icon: webConfig?.icon
              };
            }
          )
        );
        createSuccessResponse(res, result);
        await redis2.set(REDIS_LOCAL_PLUGIN_LIST_CACHE_KEY_FRONTEND, JSON.stringify(result), {
          EX: REDIS_LOCAL_PLUGIN_LIST_CACHE_EXPIRE_FRONTEND
        });
      } catch (error) {
        createServerErrorResponse(res, error.message);
        logger.error(error);
      }
    };
  }
});

// src/server/plugins/detail/index.ts
var init_detail = __esm({
  "src/server/plugins/detail/index.ts"() {
    init_list4();
  }
});
var getPluginMarketList, getCache2, setCache2, handleLocalPlugins, handleMarketPlugins, getAuthorInfo, handlePluginVersion;
var init_market2 = __esm({
  "src/server/plugins/market/index.ts"() {
    init_list();
    init_system3();
    init_request5();
    init_response();
    init_redis();
    getPluginMarketList = async (req, res) => {
      try {
        const list2 = [];
        const isForce = Boolean(req.body.refresh ?? false);
        if (!isForce) {
          const cache10 = await getCache2();
          if (cache10) {
            return createSuccessResponse(res, JSON.parse(cache10));
          }
        }
        const [
          local,
          { plugins: market }
        ] = await Promise.all([getPlugins("all", true), getPluginMarket(isForce)]);
        const registry = await getFastRegistry();
        handleLocalPlugins(list2, local, market);
        await handleMarketPlugins(list2, local, market, registry);
        setCache2(list2);
        return createSuccessResponse(res, list2);
      } catch (error) {
        logger.error(error);
        return createServerErrorResponse(res, error.message);
      }
    };
    getCache2 = async () => {
      const { redis: redis3 } = await Promise.resolve().then(() => (init_redis3(), redis_exports));
      const cache10 = await redis3.get(REDIS_PLUGIN_MARKET_LIST_CACHE_KEY);
      return cache10;
    };
    setCache2 = async (data) => {
      const { redis: redis3 } = await Promise.resolve().then(() => (init_redis3(), redis_exports));
      await redis3.set(
        REDIS_PLUGIN_MARKET_LIST_CACHE_KEY,
        JSON.stringify(data),
        { EX: REDIS_PLUGIN_MARKET_LIST_CACHE_EXPIRE }
      );
    };
    handleLocalPlugins = (list2, local, market) => {
      const localPlugins = local.filter((plugin) => !market.some((m) => m.name === plugin.name));
      for (const plugin of localPlugins) {
        const author = getAuthorInfo();
        const local2 = {
          name: plugin.name,
          installed: true,
          type: plugin.type,
          version: "",
          description: "",
          home: ""
        };
        if (plugin.type !== "app") {
          const pkg2 = plugin.pkgData;
          local2.version = pkg2.version;
          local2.description = pkg2.description;
          local2.home = pkg2.homepage || pkg2?.repository?.url;
          if (local2.home) {
            const url = new URL$1(local2.home);
            const [owner] = url.pathname.split("/").filter(Boolean);
            author.name = pkg2.author || owner;
            author.home = `${url.origin}/${owner}`;
            if (url.hostname.includes("github") || url.hostname.includes("gitee")) {
              author.avatar = `${url.origin}/${owner}.png`;
            }
          }
        }
        list2.push({ type: "local", local: local2, author });
      }
    };
    handleMarketPlugins = async (list2, local, market, registry) => {
      await Promise.all(market.map(async (plugin) => {
        const data = {
          installed: false,
          type: plugin.type,
          version: "",
          name: plugin.name,
          description: plugin.description,
          home: plugin.home
        };
        const pkg2 = local.find((p) => p.name === plugin.name);
        if (pkg2) {
          data.installed = true;
          data.type = pkg2.type;
          data.version = pkg2.pkgData.version;
        } else {
          data.version = await handlePluginVersion(plugin, registry);
        }
        const author = getAuthorInfo();
        if (plugin.author?.length) {
          author.name = plugin.author[0].name;
          author.home = plugin.author[0].home;
          author.avatar = plugin.author[0].avatar || `${plugin.author[0].home}.png`;
        }
        list2.push({ type: "market", market: plugin, local: data, author });
      }));
    };
    getAuthorInfo = () => {
      return {
        name: "\u795E\u79D8\u7684\u4E09\u6708\u4E03",
        home: "",
        avatar: "https://bbs-static.miyoushe.com/static/2025/03/05/fed22237b02cf398ef993b98b83989b3_7330898026089067872.png"
      };
    };
    handlePluginVersion = async (plugin, registry) => {
      if (plugin.type === "npm") {
        const result = await axios8.get(`${registry}/${plugin.name}/latest`);
        if (result) {
          return result.data.version;
        }
      } else {
        const github = plugin.repo.find((r) => r.type === "github");
        if (github) {
          const [owner, repo] = new URL$1(github.url).pathname.split("/").filter(Boolean);
          const { version: version2 } = await getPackageJson(owner, repo);
          return version2;
        }
        return "0.0.0";
      }
    };
  }
});
var router;
var init_router3 = __esm({
  "src/server/router/index.ts"() {
    init_router();
    init_log();
    init_middleware();
    init_login();
    init_refresh();
    init_config3();
    init_ping();
    init_local();
    init_console();
    init_botList();
    init_update2();
    init_network();
    init_manage();
    init_info();
    init_getLog();
    init_config4();
    init_install();
    init_pty();
    init_check2();
    init_webui();
    init_router2();
    init_list2();
    init_manage2();
    init_list3();
    init_config5();
    init_detail();
    init_market2();
    router = Router();
    router.use(logMiddleware);
    router.use(authMiddleware);
    router.use(express2.json());
    router.post(LOGIN_ROUTER, loginRouter);
    router.post(REFRESH_ROUTER, refreshRouter);
    router.post(GET_CONFIG_ROUTER, getConfig);
    router.post(SAVE_CONFIG_ROUTER, saveConfig);
    router.get(GET_LOG_ROUTER, getLogRouter);
    router.get(SET_LOG_LEVEL_ROUTER, logLevelRouter);
    router.get(GET_LOG_FILE_LIST_ROUTER, getLogFileListRouter);
    router.get(GET_LOG_FILE_ROUTER, getLogFileRouter);
    router.post(EXIT_ROUTER, exitRouter);
    router.post(RESTART_ROUTER, restartRouter);
    router.get(GET_NETWORK_STATUS_ROUTER, networkStatusRouter);
    router.get(UPDATE_CORE_ROUTER, updateCoreRouter);
    router.get(GET_BOTS_ROUTER, getBotsRouter);
    router.get(CONSOLE_ROUTER, consoleRouter);
    router.get(SYSTEM_STATUS_WS_ROUTER, infoRouter);
    router.get(PING_ROUTER, pingRouter);
    router.get(SYSTEM_STATUS_KARIN_ROUTER, statusRouter);
    router.get(SYSTEM_STATUS_ROUTER, systemStatusRealTimeHandler);
    router.post(CHECK_PLUGIN_ROUTER, checkPlugin);
    router.post(GET_PLUGIN_CONFIG_ROUTER, pluginGetConfig);
    router.post(SAVE_PLUGIN_CONFIG_ROUTER, pluginSaveConfig);
    router.post(IS_PLUGIN_CONFIG_EXIST_ROUTER, pluginIsConfigExist);
    router.post(PLUGIN_ADMIN_ROUTER, pluginAdminRouter);
    router.post(INSTALL_PLUGIN_ROUTER, pluginInstall);
    router.post(UNINSTALL_PLUGIN_ROUTER, pluginUninstall);
    router.post(GET_TASK_STATUS_ROUTER, pluginGetTaskStatus);
    router.post(GET_TASK_LIST_ROUTER, pluginGetTaskList);
    router.post(UPDATE_TASK_STATUS_ROUTER, pluginUpdateTaskStatus);
    router.post(GET_LOCAL_PLUGIN_LIST_ROUTER, pluginGetLocalList);
    router.post(GET_PLUGIN_LIST_PLUGIN_ADMIN_ROUTER, getPluginListPluginAdmin);
    router.post(CREATE_TERMINAL_ROUTER, createTerminalHandler);
    router.get(GET_TERMINAL_LIST_ROUTER, getTerminalListHandler);
    router.post(CLOSE_TERMINAL_ROUTER, closeTerminalHandler);
    router.get(GET_WEBUI_PLUGIN_LIST_ROUTER, getWebuiPluginList);
    router.post(INSTALL_WEBUI_PLUGIN_ROUTER, installWebui);
    router.post(UNINSTALL_WEBUI_PLUGIN_ROUTER, uninstallWebui);
    router.post(GET_WEBUI_PLUGIN_VERSIONS_ROUTER, getWebuiPluginVersions);
    router.post(UPDATE_WEBUI_PLUGIN_VERSION_ROUTER, updateWebuiPluginVersion);
    router.post(GET_DEPENDENCIES_LIST_ROUTER, getDependenciesListRouter);
    router.post(MANAGE_DEPENDENCIES_ROUTER, manageDependenciesRouter);
    router.post(GET_NPMRC_LIST_ROUTER, getNpmrcListRouter);
    router.post(GET_NPM_CONFIG_ROUTER, getNpmrcContentRouter);
    router.post(GET_NPM_BASE_CONFIG_ROUTER, getNpmBaseConfigRouter);
    router.post(SAVE_NPMRC_ROUTER, saveNpmrcRouter);
    router.post(TASK_LIST_ROUTER, taskListRouter);
    router.get(TASK_RUN_ROUTER, taskRunRouter);
    router.post(TASK_LOGS_ROUTER, taskLogsRouter);
    router.post(TASK_DELETE_ROUTER, taskDeleteRouter);
    router.post(GET_LOADED_COMMAND_PLUGIN_CACHE_LIST_ROUTER, getLoadedCommandPluginCacheList);
    router.post(GET_PLUGIN_MARKET_LIST_ROUTER, getPluginMarketList);
    router.post(GET_LOCAL_PLUGIN_FRONTEND_LIST_ROUTER, getFrontendInstalledPluginList);
  }
});

// src/server/system/root.ts
var rootRouter;
var init_root2 = __esm({
  "src/server/system/root.ts"() {
    init_response();
    rootRouter = async (_req, res) => {
      createSuccessResponse(res, null, "\u96EA\u9701\u94F6\u5986\u7D20\uFF0C\u6854\u9AD8\u6620\u743C\u679D\u3002");
    };
  }
});
var getMimeType, getMimeType_default;
var init_getMimeType = __esm({
  "src/server/utils/getMimeType.ts"() {
    getMimeType = (filePath) => {
      const ext = path4.extname(filePath).toLowerCase();
      switch (ext) {
        case ".js":
          return "application/javascript";
        case ".css":
          return "text/css";
        case ".html":
          return "text/html";
        case ".json":
          return "application/json";
        case ".png":
          return "image/png";
        case ".jpg":
        case ".jpeg":
          return "image/jpeg";
        case ".gif":
          return "image/gif";
        case ".bmp":
          return "image/bmp";
        case ".svg":
          return "image/svg+xml";
        case ".ico":
          return "image/x-icon";
        case ".mp3":
          return "audio/mpeg";
        case ".wav":
          return "audio/wav";
        case ".mp4":
          return "video/mp4";
        case ".webm":
          return "video/webm";
        case ".pdf":
          return "application/pdf";
        case ".doc":
        case ".docx":
          return "application/msword";
        case ".xls":
        case ".xlsx":
          return "application/vnd.ms-excel";
        case ".ppt":
        case ".pptx":
          return "application/vnd.ms-powerpoint";
        case ".xml":
          return "application/xml";
        case ".zip":
          return "application/zip";
        case ".rar":
          return "application/x-rar-compressed";
        case ".tar":
          return "application/x-tar";
        case ".gz":
          return "application/gzip";
        case ".txt":
          return "text/plain";
        case ".csv":
          return "text/csv";
        case ".ts":
          return "application/typescript";
        case ".woff":
          return "font/woff";
        case ".woff2":
          return "font/woff2";
        case ".ttf":
          return "font/ttf";
        case ".otf":
          return "font/otf";
        case ".eot":
          return "application/vnd.ms-fontobject";
        default:
          return "application/octet-stream";
      }
    };
    getMimeType_default = getMimeType;
  }
});

// src/server/app/ws.ts
var ws_exports = {};
__export(ws_exports, {
  emitEvent: () => emitEvent,
  wss: () => wss
});
var wss, emitEvent;
var init_ws2 = __esm({
  "src/server/app/ws.ts"() {
    init_app();
    init_internal();
    init_config();
    init_key2();
    wss = new WebSocketServer({ server });
    emitEvent = (key, socket, request3) => {
      let isClose = true;
      const call2 = () => {
        isClose = false;
        timer && clearTimeout(timer);
      };
      const timer = setTimeout(() => {
        if (!isClose) return;
        socket.close();
        logger.warn(
          `[WebSocket] \u94FE\u63A5\u65E0\u51FD\u6570\u63A5\u7BA1 \u5DF2\u81EA\u52A8\u65AD\u5F00ip: ${request3.socket.remoteAddress}
host: ${request3.headers.host}${request3.url}
headers: ${JSON.stringify(request3.headers, null, 2)}`
        );
      }, 3e3);
      listeners.emit(key, socket, request3, call2);
    };
    wss.on("error", (error) => {
      if (error.code === "EADDRINUSE") {
        logger.fatal(`[server] \u7AEF\u53E3 ${process.env.HTTP_PORT} \u5DF2\u88AB\u5360\u7528\uFF0C\u65E0\u6CD5\u542F\u52A8 http WebSocket \u670D\u52A1`);
      } else {
        logger.fatal(`[server] http\u670D\u52A1\u542F\u52A8\u5931\u8D25: ${error.message}`);
      }
      throw error;
    });
    wss.on("connection", (socket, request3) => {
      const url = (request3.url || "").replace(/token=[^&]+/, "token=******").replace(/user_id=[^&]+/, "user_id=******").replace(/access_token=[^&]+/, "access_token=******");
      logger.mark(
        `[WebSocket] ${logger.green("connection")}:
ip: ${request3.socket.remoteAddress}
host: ${request3.headers.host}${url}
headers: ${JSON.stringify(request3.headers, null, 2)}`
      );
      if (request3.url === "/" || request3.url === "/onebot/v11/ws" || request3.url === "/onebot/v11/ws/") {
        emitEvent(WS_CONNECTION_ONEBOT, socket, request3);
        socket.on("close", (code, reason) => {
          listeners.emit(WS_CLOSE_ONEBOT, socket, request3, code, reason);
        });
        return;
      }
      if (request3.url === "/puppeteer" || request3.url === "/snapka") {
        const cfg = getRenderCfg();
        if (!cfg.ws_server.enable) {
          logger.warn("[WebSocket] snapkaServer \u672A\u542F\u7528");
          socket.close();
          return;
        }
        if (request3.headers["x-client-id"] === "snapka") {
          emitEvent(WS_SNAPKA, socket, request3);
        } else {
          emitEvent(WS_CONNECTION_PUPPETEER, socket, request3);
        }
        socket.once("close", (code, reason) => {
          listeners.emit(WS_CLOSE_PUPPETEER, socket, request3, code, reason);
        });
        return;
      }
      if (request3.url?.startsWith("/terminal/create")) {
        emitEvent(WS_CONNECTION_TERMINAL, socket, request3);
        return;
      }
      if (request3.url?.startsWith("/sandbox")) {
        emitEvent(WS_CONNECTION_SANDBOX, socket, request3);
        return;
      }
      emitEvent(WS_CONNECTION, socket, request3);
      socket.on("close", (code, reason) => {
        listeners.emit(WS_CLOSE, socket, request3, code, reason);
      });
    });
  }
});

// src/server/app/app.ts
var app_exports = {};
__export(app_exports, {
  app: () => app4,
  initExpress: () => initExpress,
  server: () => server
});
var app4, server, listen, web, initExpress;
var init_app = __esm({
  "src/server/app/app.ts"() {
    init_env2();
    init_router3();
    init_root2();
    init_getMimeType();
    init_router();
    init_listeners();
    app4 = express2();
    server = createServer(app4);
    listen = (port2, host2) => {
      server.listen(port2, host2, () => {
        logger.info(`[server] express \u6B63\u5728\u76D1\u542C: http://${host2}:${port2}`);
      });
      listeners.once(ONLINE, () => {
        logger.info("\n--------------------^_^--------------------");
        logger.info(`[server] ${logger.yellow("WebUI \u8BBF\u95EE\u5730\u5740:")} ${logger.green(`http://127.0.0.1:${port2}/web/login?token=${process.env.HTTP_AUTH_KEY}`)}`);
        logger.info(`[server] HTTP  \u9274\u6743\u79D8\u94A5: ${logger.green(process.env.HTTP_AUTH_KEY)}`);
        logger.info(`[server] WS    \u9274\u6743\u79D8\u94A5: ${logger.green(process.env.WS_SERVER_AUTH_KEY) || logger.yellow("\u6CA1\u6709\u8BBE\u7F6E\u9274\u6743\u79D8\u94A5")}`);
        logger.info("-------------------------------------------");
        logger.info(`[OneBot] ${logger.yellow("\u534F\u8BAE\u7AEF\u8FDE\u63A5\u5730\u5740:")} ${logger.green(`ws://127.0.0.1:${process.env.HTTP_PORT}`)}`);
        logger.info(`[puppet] \u6E32\u67D3\u5668\u8FDE\u63A5\u5730\u5740: ${logger.green(`ws://127.0.0.1:${process.env.HTTP_PORT}/puppeteer`)}`);
        logger.info("\n-------------------------------------------");
      });
    };
    web = (dir) => {
      const webDir = path4.join(dir.karinDir, "dist/web");
      app4.use("/web", express2.static(webDir));
      app4.use("/sandbox/data", express2.static(dir.sandboxDataPath));
      app4.use("/sandbox/file", express2.static(dir.sandboxTempPath));
      app4.get("/web/{*splat}", (_, res) => {
        res.sendFile("index.html", {
          root: path4.resolve(webDir)
        });
      });
      listeners.once(ONLINE, () => {
        setTimeout(() => {
          app4.all("/{*splat}", (_, res) => {
            res.redirect("/web");
          });
        }, 5e3);
      });
    };
    initExpress = async (dir, port2, host2) => {
      const webDir = path4.join(dir.karinDir, "dist/web");
      app4.use("/web", (req, res, next) => {
        const filePath = path4.join(webDir, req.path);
        const brPath = `${filePath}.br`;
        const acceptEncoding = req.headers["accept-encoding"] || "";
        if (fs5.existsSync(brPath)) {
          if (acceptEncoding.includes("br")) {
            res.set({
              "Content-Encoding": "br",
              "Content-Type": getMimeType_default(req.path),
              "Cache-Control": "public, max-age=604800"
            });
            req.url = `${req.url}.br`;
            return express2.static(webDir)(req, res, next);
          } else {
            res.set({
              "Content-Encoding": "identity",
              "Content-Type": getMimeType_default(req.path),
              "Cache-Control": "public, max-age=604800"
            });
            const readStream = fs5.createReadStream(brPath);
            const decompressStream = createBrotliDecompress();
            readStream.pipe(decompressStream).pipe(res);
            return;
          }
        }
        next();
      });
      await Promise.resolve().then(() => (init_ws2(), ws_exports));
      app4.use(BASE_ROUTER, router);
      app4.get("/", rootRouter);
      web(dir);
      listen(port2, host2);
    };
  }
});
var index5, botID, AdapterConsole, adapter2;
var init_input = __esm({
  "src/adapter/input/index.ts"() {
    init_base();
    init_listeners();
    init_data();
    init_root();
    init_service();
    init_message2();
    init_config();
    init_create();
    init_event2();
    index5 = 0;
    botID = "console";
    AdapterConsole = class extends AdapterBase {
      constructor() {
        super();
        listeners.on(
          "karin:adapter:open",
          () => process.stdin.on("data", (data) => this.createEvent(data))
        );
        listeners.on("karin:adapter:close", () => process.stdin.removeAllListeners("data"));
        this.adapter.name = "@karinjs/console";
        this.adapter.communication = "other";
        this.adapter.platform = "other";
        this.adapter.standard = "other";
        this.adapter.version = process.env.KARIN_VERSION;
        this.account.name = botID;
        this.account.uid = botID;
        this.account.uin = botID;
        this.account.selfId = botID;
        this.account.avatar = "https://p.qlogo.cn/gh/967068507/967068507/0";
        listeners.emit("karin:adapter:open");
      }
      get selfId() {
        return this.account.selfId;
      }
      async createEvent(data) {
        const text2 = data.toString().trim();
        const seq2 = Math.floor(Math.random() * 1e9);
        const time2 = Date.now();
        if (text2.startsWith("log")) {
          const level = text2.replace(/^log/, "").trim();
          if (level) {
            const list2 = ["trace", "debug", "info", "warn", "error", "fatal"];
            if (list2.includes(level)) {
              const { updateLevel: updateLevel2 } = await Promise.resolve().then(() => (init_admin(), admin_exports));
              updateLevel2(level);
              logger.info(`\u65E5\u5FD7\u7B49\u7EA7\u5DF2\u66F4\u65B0\u4E3A: ${level}`);
              return;
            }
          }
        }
        if (text2 === "rs" || text2 === "restart") {
          process.send(JSON.stringify({ type: "restart" }));
          return;
        }
        if (text2 === "stop") {
          process.send(JSON.stringify({ type: "stop" }));
          return;
        }
        if (text2.startsWith("group")) {
          const contact4 = contactGroup("10010");
          createGroupMessage({
            bot: this,
            contact: contact4,
            elements: [segment_exports.text(text2.replace(/^group/, "").trim())],
            eventId: `${botID}${time2}`,
            messageId: `${botID}${time2}`,
            messageSeq: seq2,
            rawEvent: { data },
            sender: senderGroup(botID, "member"),
            time: time2,
            srcReply: (elements) => this.sendMsg(contact4, elements)
          });
          return;
        }
        const contact3 = contactFriend(botID);
        createFriendMessage({
          bot: this,
          contact: contact3,
          elements: [segment_exports.text(text2.replace(/^group/, "").trim())],
          eventId: `${botID}.${time2}`,
          messageId: `${botID}.${time2}`,
          messageSeq: seq2,
          rawEvent: { data },
          sender: senderFriend(botID, ""),
          time: time2,
          srcReply: (elements) => this.sendMsg(contact3, elements)
        });
      }
      async sendMsg(contact3, elements, _) {
        const time2 = Date.now();
        const messageId = (++index5).toString();
        const result = {
          message_id: messageId,
          messageId,
          time: time2,
          messageTime: time2,
          rawData: {}
        };
        const msg = [];
        for (const v of elements) {
          if (v.type === "at") {
            msg.push(`[at:${v.targetId}]`);
            continue;
          }
          if (v.type === "text") {
            msg.push(v.text);
            continue;
          }
          if (v.type === "image" || v.type === "record" || v.type === "video") {
            const url = v.file.startsWith("http") ? v.file : await this.getUrl(v.file, ".png");
            msg.push(`[${v.type}: ${logger.blue(url)} ]`);
            continue;
          }
          msg.push(JSON.stringify(v));
        }
        if (contact3.scene === "group") {
          msg.unshift(logger.green("Send group message: "));
          logger.info(msg.join(""));
        } else {
          msg.unshift(logger.green("Send private message: "));
          logger.info(msg.join(""));
        }
        return result;
      }
      async getUrl(data, ext) {
        const cfg = adapter();
        const name = (++index5).toString();
        const file2 = path4.join(consolePath, `${name}${ext}`);
        await fs5.promises.writeFile(file2, await buffer(data));
        if (cfg.console.isLocal) {
          return `http://127.0.0.1:${process.env.HTTP_PORT}/api/v1/console/${name}${ext}`;
        }
        if (cfg.console.host) {
          return `${cfg.console.host}/api/v1/console/${name}${ext}?token=${cfg.console.token}`;
        }
        return `http://127.0.0.1:${process.env.HTTP_PORT}/api/v1/console/${name}${ext}?token=${cfg.console.token}`;
      }
      async getAvatarUrl(userId, _) {
        if (userId === botID) {
          return process.env.ADAPTER_CONSOLE_AVATAR || "https://p.qlogo.cn/gh/967068507/967068507/0";
        }
        return "";
      }
      async getGroupAvatarUrl(_, __, ___) {
        return "https://p.qlogo.cn/gh/967068507/967068507/0";
      }
      async recallMsg(_, messageId) {
        logger.info(`[recallMsg] ${messageId}`);
      }
      async sendLike(targetId, count3) {
        logger.info(`[sendLike] ${targetId} ${count3}`);
      }
      async groupKickMember(groupId, targetId, rejectAddRequest, kickReason) {
        logger.info(`[groupKickMember] ${groupId} ${targetId} ${rejectAddRequest} ${kickReason}`);
      }
      async setGroupMute(groupId, targetId, duration) {
        logger.info(`[setGroupMute] ${groupId} ${targetId} ${duration}`);
      }
      async setGroupAllMute(groupId, isBan) {
        logger.info(`[setGroupAllMute] ${groupId} ${isBan}`);
      }
      async setGroupAdmin(groupId, targetId, isAdmin) {
        logger.info(`[setGroupAdmin] ${groupId} ${targetId} ${isAdmin}`);
      }
      async setGroupMemberCard(groupId, targetId, card) {
        logger.info(`[setGroupMemberCard] ${groupId} ${targetId} ${card}`);
      }
      async setGroupName(groupId, groupName) {
        logger.info(`[setGroupName] ${groupId} ${groupName}`);
      }
      async setGroupQuit(groupId, isDismiss) {
        logger.info(`[setGroupQuit] ${groupId} ${isDismiss}`);
      }
      async setGroupMemberTitle(groupId, targetId, title) {
        logger.info(`[setGroupMemberTitle] ${groupId} ${targetId} ${title}`);
      }
      async getFriendList(refresh) {
        logger.info(`[getFriendList] ${refresh}`);
        return [];
      }
      async getGroupList(refresh) {
        logger.info(`[getGroupList] ${refresh}`);
        return [];
      }
      async getGroupMemberList(groupId, refresh) {
        logger.info(`[getGroupMemberList] ${groupId} ${refresh}`);
        return [];
      }
      async getGroupHonor(groupId) {
        logger.info(`[getGroupHonor] ${groupId}`);
        return [];
      }
      async setFriendApplyResult(requestId, isApprove, remark) {
        logger.info(`[setFriendApplyResult] ${requestId} ${isApprove} ${remark}`);
      }
      async setGroupApplyResult(requestId, isApprove, denyReason) {
        logger.info(`[setGroupApplyResult] ${requestId} ${isApprove} ${denyReason}`);
      }
      async setInvitedJoinGroupResult(requestId, isApprove) {
        logger.info(`[setInvitedJoinGroupResult] ${requestId} ${isApprove}`);
      }
      async setMsgReaction(contact3, messageId, faceId, isSet) {
        logger.info(`[setMsgReaction] ${contact3} ${messageId} ${faceId} ${isSet}`);
      }
      async uploadFile(contact3, file2, name, folder) {
        logger.info(`[uploadFile] ${contact3} ${file2} ${name} ${folder}`);
      }
    };
    adapter2 = new AdapterConsole();
    registerBot("other", adapter2);
  }
});

// src/adapter/index.ts
var adapter_exports = {};
__export(adapter_exports, {
  AdapterBase: () => AdapterBase,
  initRender: () => initRender2
});
var init_adapter2 = __esm({
  "src/adapter/index.ts"() {
    init_input();
    init_base();
    init_render2();
  }
});
var time = Date.now();
var debugEnabled = false;
var isDebugMode = () => {
  return debugEnabled || typeof process.env.DEBUG === "string" || process.argv.some((arg) => arg.includes("debug"));
};
var createDebug = (prefix) => {
  let color = (text2) => chalk2.hex("#0cafff")(text2);
  const setColor = (fnc2) => {
    color = fnc2;
  };
  const debugFn = (...args) => {
    process.stderr.write(`${color(prefix)} ${util5.format(...args)} ${color(`+${Date.now() - time}ms`)}
`);
  };
  const noop = () => {
  };
  let debug3 = isDebugMode() ? debugFn : noop;
  return Object.assign(debug3, {
    chalk: chalk2,
    setColor,
    enable: (bool) => {
      debugEnabled = bool;
      debug3 = isDebugMode() ? debugFn : noop;
    }
  });
};

// src/service/debug.ts
var debug2 = createDebug("core");
global.debug = debug2;

// src/index.ts
init_dotenv();
init_root();
init_env2();

// src/utils/config/init.ts
init_env2();
init_pkg();
init_default();
init_file2();
var env2 = () => {
  const list2 = [
    {
      key: "LOG_MAX_CONNECTIONS",
      value: "5",
      comment: "\u65E5\u5FD7\u5B9E\u65F6Api\u6700\u591A\u652F\u6301\u540C\u65F6\u8FDE\u63A5\u6570"
    }
  ];
  const file2 = `${process.cwd()}/${process.env.EBV_FILE}`;
  if (!fs5.existsSync(file2)) {
    logger.error(logger.yellow("\u68C0\u67E5\u5230\u9879\u76EE\u914D\u7F6E\u6587\u4EF6\u7F3A\u5931\uFF0C\u6B63\u5728\u521D\u59CB\u5316..."));
    const cwd = fileURLToPath$1(new URL$1("./cli/index.mjs", import.meta.url));
    execSync(`node ${cwd} init`, {
      cwd: process.cwd(),
      stdio: "inherit"
    });
    logger.info(logger.green("\u521D\u59CB\u5316\u6210\u529F~"));
  }
  const content = fs5.readFileSync(file2, "utf-8");
  list2.forEach((v) => {
    if (!content.includes(v.key)) {
      fs5.appendFileSync(file2, `
${v.comment}
${v.key}=${v.value}`);
      process.env[v.key] = v.value;
    }
  });
};
var initConfig2 = async (dir) => {
  const files = [
    dir.basePath,
    dir.configPath,
    dir.dataPath,
    dir.tempPath,
    dir.htmlPath,
    dir.consolePath,
    dir.resourcePath,
    dir.sandboxDataPath,
    dir.sandboxTempPath,
    `${dir.sandboxDataPath}/avatar`
  ];
  await Promise.all(files.map((v) => {
    if (!fs5.existsSync(v)) fs5.mkdirSync(v, { recursive: true });
    return Promise.resolve();
  }));
  setVersion(pkg().version);
  env2();
  if (process.env.pm_id) setRuntime("pm2");
  const list2 = await fs5.promises.readdir(dir.consolePath);
  await Promise.all(list2.map((v) => {
    if (fs5.statSync(`${dir.consolePath}/${v}`).isDirectory()) {
      fs5.rmdirSync(`${dir.consolePath}/${v}`, { recursive: true });
    } else {
      fs5.unlinkSync(`${dir.consolePath}/${v}`);
    }
    return Promise.resolve();
  }));
  await Promise.all(Object.keys(defaultConfig).map(async (key) => {
    const file2 = `${dir.configPath}/${key}.json`;
    if (fs5.existsSync(file2)) return;
    const data = JSON.stringify(defaultConfig[key], null, 2);
    await fs5.promises.writeFile(file2, data, "utf-8");
    return true;
  }));
  initConfigCache(dir.configPath);
};

// src/service/process/index.ts
init_check();

// src/service/process/signalCapture.ts
init_exit();
init_listeners();
var processHandler = () => {
  process.title = `karin v${process.env.KARIN_VERSION} \xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} - Karinjs`;
  process.once("SIGHUP", (code) => processExit(code));
  process.once("SIGINT", (code) => processExit(code));
  process.once("SIGTERM", (code) => processExit(code));
  process.once("SIGBREAK", (code) => processExit(code));
  process.once("SIGQUIT", (code) => processExit(code));
  process.on("warning", (warning) => listeners.emit("warn", warning));
  process.on("uncaughtException", (error, origin) => {
    listeners.emit("error", error, origin);
  });
  process.on("unhandledRejection", (error, promise) => {
    listeners.emit("error", error, promise);
  });
  process.on("rejectionHandled", (error) => {
    listeners.emit("error", error);
  });
  listeners.on("error", (...args) => {
    logger.error(...args);
  });
  if (process.env.pm_id) process.env.RUNTIME = "pm2";
  if (typeof process.send === "function") {
    process.on("disconnect", () => {
      logger.fatal("IPC\u901A\u9053\u5DF2\u65AD\u5F00\uFF0C\u7236\u8FDB\u7A0B\u53EF\u80FD\u5DF2\u9000\u51FA\uFF0CKarin\u5C06\u7ED3\u675F\u8FD0\u884C");
      process.exit(1);
    });
  }
};

// src/service/process/index.ts
var initProcess = async (port2) => {
  processHandler();
  await checkProcess(port2);
};

// src/plugin/admin/index.ts
init_load();

// src/plugin/admin/uninstall.ts
init_cache();
init_path();
var pkgRemoveModule = async (file2) => {
  cache3.accept = cache3.accept.filter((p) => !isPathEqual(p.file.absPath, file2));
  cache3.command = cache3.command.filter((p) => !isPathEqual(p.file.absPath, file2));
  cache3.task = cache3.task.filter((p) => {
    const isEqual = isPathEqual(p.file.absPath, file2);
    if (isEqual && p.schedule) {
      p.schedule.cancel();
    }
    return !isEqual;
  });
  cache3.button = cache3.button.filter((p) => !isPathEqual(p.file.absPath, file2));
  Object.keys(cache3.handler).forEach((key) => {
    cache3.handler[key] = cache3.handler[key].filter((p) => !isPathEqual(p.file.absPath, file2));
  });
};

// src/plugin/admin/init.ts
init_cache();
init_list();

// src/plugin/admin/hmr.ts
init_cache();
init_env2();
init_path();
init_load();
var watcher;
var initPluginHmr = async () => {
  const watchDirs = /* @__PURE__ */ new Set();
  Object.values(cache3.index).forEach((pkg2) => {
    if (!isDev() && pkg2.type !== "app") return;
    pkg2.allApps.forEach((dir) => watchDirs.add(dir));
  });
  watcher = chokidar.watch(Array.from(watchDirs), {
    ignoreInitial: true,
    ignored: /(^|[/\\])\../
  });
  watcher.on("add", (file2) => handleFileChange(file2, "add")).on("change", (file2) => handleFileChange(file2, "change")).on("unlink", (file2) => handleFileChange(file2, "unlink"));
  const relativePaths = Array.from(watchDirs).map((dir) => {
    return path4.relative(process.cwd(), dir).replace(/\\/g, "/");
  });
  watchDirs.clear();
  relativePaths.length ? logger.info(`
[hmr] ${logger.magenta("\u6B63\u5728\u76D1\u542C\u6587\u4EF6\u5939")}:
  ${relativePaths.join("\n  ")}`) : logger.info("[hmr] \u5F53\u524D\u76D1\u542C\u7684\u63D2\u4EF6\u5217\u8868\u4E3A\u7A7A");
};
var handleFileChange = async (file2, action) => {
  const ext = path4.extname(file2);
  const exts = getModuleType();
  if (!exts.includes(ext)) return;
  const absPath2 = formatPath(file2);
  const pkg2 = findPkgByFile(absPath2);
  if (!pkg2) return;
  const relativePath = path4.relative(process.cwd(), file2).replace(/\\/g, "/");
  logger.debug(`[hmr][${pkg2.name}] \u6587\u4EF6${action}: ${relativePath}`);
  if (action === "unlink") {
    pkgRemoveModule(absPath2);
    logger.info(`[hmr][${pkg2.name}] \u5DF2\u5378\u8F7D: ${path4.basename(file2)}`);
    return;
  }
  if (action === "change") {
    pkgRemoveModule(absPath2);
  }
  try {
    const result = await pkgLoadModule(pkg2.name, absPath2, true);
    pkgCache(result, pkg2, absPath2);
    pkgSort();
    const actionText = action === "add" ? "\u65B0\u589E\u63D2\u4EF6" : "\u91CD\u8F7D\u5B8C\u6210";
    logger.info(`[hmr][${pkg2.name}] ${actionText}: ${path4.basename(file2)}`);
  } catch (error) {
    logger.error(`[hmr][${pkg2.name}] \u52A0\u8F7D\u5931\u8D25:`);
    logger.error(error);
  }
};

// src/plugin/admin/init.ts
init_load();
init_internal();
var initPlugins = async () => {
  logger.info(logger.green("-----------"));
  logger.info("\u52A0\u8F7D\u63D2\u4EF6\u4E2D...");
  const allPromises = [];
  const list2 = await getPlugins("all", true, false, true);
  await Promise.all(list2.map(async (pkg2) => pkgLoads(pkg2, allPromises)));
  await Promise.allSettled(allPromises);
  allPromises.length = 0;
  pkgSort();
  errorHandler.printMissing();
  logger.info("\u63D2\u4EF6\u52A0\u8F7D\u5B8C\u6210");
  logger.info(`${logger.chalk.magentaBright("plugin")}: ${Object.keys(cache3.index).length}`);
  Object.keys(cache3.count).forEach((v) => {
    if (v === "handler") {
      const { key, fnc: fnc2 } = cache3.count.handler;
      logger.info(`${logger.chalk.magentaBright(v + ".key")} ${key}`);
      logger.info(`${logger.chalk.magentaBright(v + ".fnc")} ${fnc2}`);
      return;
    }
    logger.info(`${logger.chalk.magentaBright(v)}: ${cache3.count[v]}`);
  });
  logger.info(logger.green("-----------"));
  setTimeout(() => {
    initPluginHmr();
  }, 3 * 1e3);
};

// src/service/start.ts
var printStartLog = (version2) => {
  logger.mark("Karin \u542F\u52A8\u4E2D...");
  logger.mark(`\u5F53\u524D\u7248\u672C: ${version2}`);
  logger.mark("https://github.com/KarinJS/Karin");
};

// src/index.ts
init_db();
init_render2();

// src/adapter/onebot/core/index.ts
init_cache2();
init_core();
init_convert();

// src/adapter/onebot/create/init.ts
init_internal();
init_key2();
init_adapter();

// src/adapter/onebot/create/router.ts
init_app();
var oneBotEventDispatchRouter = async (req, res) => {
  res.status(204).json({});
  const chunks = [];
  req.on("data", (chunk) => {
    chunks.push(chunk);
  });
  req.on("end", () => {
    const rawBody = Buffer.concat(chunks).toString("utf8");
    const data = req.body;
    const selfId = req.headers["x-self-id"];
    if (!selfId || typeof selfId !== "string") {
      logger.warn(`[OneBot] \u672A\u77E5\u8BF7\u6C42: ${JSON.stringify(data)}`);
      return;
    }
    const adapter3 = cacheMap.http.get(selfId);
    if (!adapter3) {
      logger.warn(`[OneBot] \u672A\u77E5\u8BF7\u6C42: ${JSON.stringify(data)}`);
      return;
    }
    adapter3._onebot.handleEvent(rawBody, req.headers);
  });
};
var createOneBotEventDispatchRouter = () => {
  const router2 = Router();
  router2.post("/", oneBotEventDispatchRouter);
  app4.use("/onebot", router2);
};

// src/adapter/onebot/create/init.ts
var initOneBotAdapter = async () => {
  listeners.on(WS_CONNECTION_ONEBOT, (socket, request3, call2) => {
    call2();
    createOneBotWsServer(socket, request3);
  });
  const cfg = adapter();
  if (cfg.onebot.ws_client && Array.isArray(cfg.onebot.ws_client)) {
    for (const item of cfg.onebot.ws_client) {
      if (!item?.enable || !item?.url) continue;
      createOneBotClient(item.url, item.token);
    }
  }
  if (cfg.onebot.http_server && Array.isArray(cfg.onebot.http_server)) {
    for (const item of cfg.onebot.http_server) {
      if (!item?.enable || !item?.url || !item?.self_id) continue;
      createOneBotHttp(item);
    }
  }
  createOneBotEventDispatchRouter();
};

// src/adapter/onebot/create/index.ts
init_create2();
init_message5();
init_notice3();
init_request3();

// src/index.ts
init_task();
init_listeners();
init_root();
init_service();

// src/core/karin/export.ts
var export_exports = {};
__export(export_exports, {
  accept: () => accept,
  button: () => button2,
  command: () => command,
  ctx: () => ctx2,
  getAllBot: () => getAllBot,
  getAllBotID: () => getAllBotID,
  getAllBotList: () => getAllBotList,
  getBot: () => getBot,
  getBotCount: () => getBotCount,
  handler: () => handler2,
  registerBot: () => registerBot,
  render: () => render3,
  sendAdmin: () => sendAdmin,
  sendMaster: () => sendMaster,
  sendMsg: () => sendMsg2,
  task: () => task,
  unregisterBot: () => unregisterBot
});

// src/core/karin/task.ts
init_tools2();
var task = (name, cron2, fnc2, options = {}) => {
  if (!name) throw new Error("[task]: \u7F3A\u5C11\u53C2\u6570[name]");
  if (!cron2) throw new Error("[task]: \u7F3A\u5C11\u53C2\u6570[cron]");
  if (!fnc2 || typeof fnc2 !== "function") throw new Error("[task]: \u7F3A\u5C11\u53C2\u6570\u6216\u7C7B\u578B\u9519\u8BEF[fnc]");
  return {
    name,
    cron: cron2,
    fnc: fnc2,
    log: createLogger2(options.log, false),
    schedule: void 0,
    file: createFile("task", options.name || "task"),
    pkg: createPkg2()
  };
};

// src/core/karin/accept.ts
init_tools2();
var accept = (event, fnc2, options = {}) => {
  const dsbAdapter = options.dsbAdapter || options.notAdapter || [];
  const rank = Number(options.rank ?? options.priority);
  return {
    event,
    fnc: fnc2,
    log: createLogger2(options.log, true),
    adapter: Array.isArray(options.adapter) ? options.adapter : [],
    dsbAdapter: Array.isArray(dsbAdapter) ? dsbAdapter : [],
    file: createFile("accept", options.name || "accept"),
    pkg: createPkg2(),
    priority: rank ?? 1e4
  };
};

// src/core/karin/button.ts
init_tools2();
var button2 = (reg, fnc2, options = {}) => {
  const rank = Number(options.rank ?? options.priority);
  return {
    fnc: fnc2,
    reg: reg instanceof RegExp ? reg : new RegExp(reg),
    rank: isNaN(rank) ? 1e4 : rank,
    file: createFile("button", options.name || "button"),
    pkg: createPkg2(),
    priority: rank ?? 1e4
  };
};

// src/core/karin/render.ts
init_cache4();
var render3 = (options, multiPageOrId, id) => {
  if (options === "opt") {
    return callRender(multiPageOrId, id);
  }
  if (typeof options === "string") {
    if (!multiPageOrId) {
      return renderHtml(options);
    }
    return renderMultiHtml(options, multiPageOrId);
  }
  return callRender(options, multiPageOrId);
};

// src/core/karin/command.ts
init_tools2();
var command = (reg, second, options = {}) => {
  reg = typeof reg === "string" ? new RegExp(reg) : reg;
  const fnc2 = typeof second === "function" ? second : async (e) => {
    const element = typeof second === "number" ? String(second) : second;
    await e.reply(element, {
      at: "at" in options && options.at || false,
      reply: "reply" in options && options.reply || false,
      recallMsg: "recallMsg" in options && Number(options.recallMsg) || 0
    });
    return !("stop" in options && !options.stop);
  };
  const dsbAdapter = options.dsbAdapter || options.notAdapter || [];
  const rank = Number(options.rank ?? options.priority);
  return {
    type: "fnc",
    event: options.event || "message",
    fnc: fnc2,
    log: createLogger2(options.log, true),
    permission: options.perm || options.permission || "all",
    priority: isNaN(rank) ? 1e4 : rank,
    reg,
    adapter: Array.isArray(options.adapter) ? options.adapter : [],
    dsbAdapter: Array.isArray(dsbAdapter) ? dsbAdapter : [],
    authFailMsg: options.authFailMsg || true,
    file: createFile("command", options.name || "command"),
    pkg: createPkg2()
  };
};

// src/core/karin/context.ts
init_internal();
init_context();
var ctx2 = async (e, options) => {
  const time2 = options?.time || 120;
  const userId = options?.userId || e.userId || e.user_id;
  const key = e.contact.subPeer ? `${e.contact.peer}:${e.contact.subPeer}:${userId}` : `${e.contact.peer}:${userId}`;
  ctx.set(key, e);
  return new Promise((resolve, reject) => {
    const timeout2 = setTimeout(() => {
      const data = ctx.get(key);
      if (data?.eventId === e.eventId) {
        ctx.delete(key);
        if (options?.reply) e.reply(options.replyMsg || "\u64CD\u4F5C\u8D85\u65F6\u5DF2\u53D6\u6D88");
        listeners.removeAllListeners(`ctx:${key}`);
        reject(new Error(`\u63A5\u6536\u4E0B\u6587\u4E8B\u4EF6\u8D85\u65F6\uFF0C\u5DF2\u53D6\u6D88\u4E0B\u6587\u76D1\u542C: ${key}`));
        return true;
      }
    }, time2 * 1e3);
    listeners.once(`ctx:${key}`, (e2) => {
      clearTimeout(timeout2);
      resolve(e2);
    });
  });
};

// src/core/karin/handler.ts
init_tools2();
var handler2 = (key, fnc2, options = {}) => {
  if (!key) throw new Error("[handler]: \u7F3A\u5C11\u53C2\u6570[key]");
  if (!fnc2) throw new Error("[handler]: \u7F3A\u5C11\u53C2\u6570[fnc]");
  return {
    key,
    fnc: fnc2,
    priority: Number(options.rank ?? options.priority) || 1e4,
    file: createFile("handler", options.name || "handler"),
    pkg: createPkg2()
  };
};

// src/core/karin/sendMsg.ts
init_bot();
init_config();
var sendMaster = async (selfId, targetId, elements, options = { recallMsg: 0, retryCount: 1, mustMaster: false }) => {
  const mustMaster = options?.mustMaster ?? false;
  const lsit = master();
  if (mustMaster) {
    if (!lsit.includes(`${selfId}@${targetId}`)) {
      throw new Error("\u53D1\u9001\u6D88\u606F\u5931\u8D25: \u76EE\u6807\u4E0D\u662FBot\u7684\u4E13\u5C5E\u4E3B\u4EBA");
    }
  } else {
    if (!lsit.includes(targetId)) {
      throw new Error("\u53D1\u9001\u6D88\u606F\u5931\u8D25: \u76EE\u6807\u4E0D\u662F\u4E3B\u4EBA");
    }
  }
  const contact3 = { peer: targetId, scene: "friend" };
  return sendMsg2(selfId, contact3, elements, options);
};
var sendAdmin = async (selfId, targetId, elements, options = { recallMsg: 0, retryCount: 1, mustAdmin: false }) => {
  const mustAdmin = options?.mustAdmin ?? false;
  const lsit = admin();
  if (mustAdmin) {
    if (!lsit.includes(`${selfId}@${targetId}`)) {
      throw new Error("\u53D1\u9001\u6D88\u606F\u5931\u8D25: \u76EE\u6807\u4E0D\u662FBot\u7684\u4E13\u5C5E\u7BA1\u7406\u5458");
    }
  } else {
    if (!lsit.includes(targetId)) {
      throw new Error("\u53D1\u9001\u6D88\u606F\u5931\u8D25: \u76EE\u6807\u4E0D\u662F\u7BA1\u7406\u5458");
    }
  }
  const contact3 = { peer: targetId, scene: "friend" };
  return sendMsg2(selfId, contact3, elements, options);
};

// src/core/karin/export.ts
init_bot();

// src/core/karin/other.ts
init_internal();
init_key2();
init_bot();
var Other = class extends EventEmitter {
  /** 框架名称 */
  name = "karin";
  /**
   * 构建contact
   * @param scene 场景
   * @param peer 群号或者用户id
   * @param subPeer 子id
   */
  contact(scene, peer, subPeer, name) {
    if (scene === "guild" || scene === "direct" || scene === "groupTemp") {
      return { scene, peer, subPeer, name };
    } else {
      return { scene, peer, subPeer: void 0, name };
    }
  }
  /**
   * 构建群contact
   * @param peer - 群号
   * @param name - 群名
   */
  contactGroup(peer, name) {
    return { scene: "group", peer, subPeer: void 0, name: name || "" };
  }
  /**
   * 构建好友contact
   * @param peer - 用户id
   * @param name - 昵称
   */
  contactFriend(peer, name) {
    return { scene: "friend", peer, subPeer: void 0, name: name || "" };
  }
  /**
   * 构建频道contact
   * @param peer - 频道id
   * @param subPeer - 子频道id
   * @param name - 频道名称
   * @param subName - 子频道名称
   * @returns 频道contact
   */
  contactGuild(peer, subPeer, name, subName) {
    return { scene: "guild", peer, subPeer, name: name || "", subName: subName || "" };
  }
  /**
   * 构建临时群会话contact
   * @param peer - 群号
   * @param subPeer - 子id
   * @param name - 群名
   */
  contactGroupTemp(peer, subPeer, name) {
    return { scene: "groupTemp", peer, subPeer, name: name || "" };
  }
  /**
   * 构建消息事件私聊发送者信息
   * @param userId 发送者ID
   * @param nick 昵称
   * @param sex 性别
   * @param age 年龄
   * @param uid 隐藏字段 uid
   * @param uin 隐藏字段 uin
   */
  friendSender(userId, nick, sex = "unknown", age, uid, uin) {
    return { userId: String(userId), nick, sex, age, uid, uin, name: nick };
  }
  /**
   * 构建消息事件群聊发送者信息
   * @param userId 发送者ID
   * @param nick 昵称
   * @param role 角色
   * @param sex 性别
   * @param age 年龄
   * @param card 群名片/备注
   * @param area 地区
   * @param level 成员等级
   * @param title 专属头衔
   * @param uid 隐藏字段 uid
   * @param uin 隐藏字段 uin
   */
  groupSender(userId, role, nick, sex, age, card, area, level, title, uid, uin) {
    return {
      userId: String(userId),
      role: role || "unknown",
      nick: nick || "",
      sex,
      age,
      card,
      area,
      level,
      title,
      uid,
      uin,
      name: nick || ""
    };
  }
  /**
   * 根据索引获取Bot
   * @param index - Bot的索引id
   */
  getBotByIndex(index6) {
    return getBot(index6);
  }
  /**
   * 获取注册的Bot数量
   * @returns Bot数量
   */
  getBotCount() {
    return getBotCount();
  }
  /**
   * 获取所有Bot列表
   * @param isIndex - 是否返回包含的索引列表 默认`false` 返回Bot列表
   */
  getBotAll(isIndex) {
    if (isIndex) return getAllBotList();
    return getAllBot().map((item) => item);
  }
};
var events = () => {
  listeners.on(WS_CONNECTION, (socket, request3, call2) => {
    other.emit(WS_CONNECTION, socket, request3, call2);
    const url = new URL$1(request3.url || "", "ws://localhost");
    other.emit(`${WS_CONNECTION}:${url.pathname}`, socket, request3, call2);
  });
  listeners.on("file:change", (type, old, data) => {
    other.emit("file:change", type, old, data);
  });
};
var other = new Other();
events();

// src/core/karin/index.ts
debug("debug: init karin");
var karin = Object.assign(other, export_exports);
var Bot = karin;

// src/index.ts
init_utils();

// src/server/index.ts
init_router3();
init_router();
init_response();
init_getMimeType();
init_middleware();
init_app();

// src/index.ts
init_event2();
init_cache4();

// src/components/defineConfig.ts
var defineConfig = (config3) => {
  return config3;
};

// src/components/accordion.ts
var createAccordion = (key, config3 = {}) => ({
  key,
  ...config3,
  componentType: "accordion"
});
var createAccordionPro = (key, config3 = {}) => ({
  ...config3,
  key,
  componentType: "accordion-pro",
  data: config3.data || [],
  children: config3.children
});
var createAccordionItem = (key, config3 = {}) => ({
  key,
  ...config3,
  componentType: "accordion-item",
  children: config3.children || []
});
var accordion = {
  /**
   * 创建基础手风琴组件
   * @param key 唯一标识符
   * @param options 手风琴配置
   */
  create: (key, options) => createAccordion(key, options),
  /**
   * 创建默认配置的手风琴组件
   * @param key 唯一标识符
   */
  default: (key) => createAccordion(key, {
    title: "\u6298\u53E0\u9762\u677F",
    variant: "bordered",
    selectionMode: "single",
    selectionBehavior: "toggle",
    showDivider: true,
    fullWidth: true
  }),
  /**
   * 创建手风琴子项
   * @param key 唯一标识符
   * @param options 手风琴子项配置
   */
  createItem: (key, options) => createAccordionItem(key, options)
};
var accordionPro = {
  /**
   * 创建基础手风琴Pro组件
   * @param key 唯一标识符
   * @param data 渲染数据
   * @param options 手风琴Pro配置
   */
  create: (key, data, options) => createAccordionPro(key, {
    ...options,
    data
  })
};
var accordionItem = {
  /**
   * 创建手风琴子项
   * @param key 唯一标识符
   * @param options 手风琴子项配置
   */
  create: (key, options) => createAccordionItem(key, options),
  /**
   * 创建默认配置的手风琴子项
   * @param key 唯一标识符
   * @param title 标题
   * @param children 子组件
   */
  default: (key, title, children) => createAccordionItem(key, {
    title,
    children,
    isCompact: false,
    hideIndicator: false,
    disableAnimation: false,
    disableIndicatorAnimation: false
  })
};

// src/components/input.ts
var createInput = (key, config3 = {}) => {
  const data = {
    ...config3,
    key,
    componentType: "input"
  };
  if (config3.rules) {
    data.rules = config3.rules.map((rule) => {
      return {
        ...rule,
        regex: rule.regex instanceof RegExp ? rule.regex.source : rule.regex
      };
    });
  }
  return data;
};
var createInputGroup = (key, options) => {
  return {
    ...options,
    key,
    componentType: "input-group",
    template: createInput("input-group-template", options.template),
    data: Array.isArray(options?.data) ? options.data : [],
    itemsPerRow: options.itemsPerRow ?? 3,
    maxRows: options.maxRows ?? 3,
    maxInputs: options.maxInputs ?? 100
  };
};
var input = {
  /**
   * 创建基础输入框
   * @param key 唯一标识符
   * @param options 输入框配置
   */
  create: (key, options) => createInput(key, options),
  /**
   * 创建输入框组
   * @param key 唯一标识符
   * @param options 输入框组配置
   */
  group: (key, options) => createInputGroup(key, options),
  /**
   * 字符串输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  string: (key, config3 = {}) => createInput(key, {
    type: "text",
    label: "\u5B57\u7B26\u4E32",
    placeholder: "\u8BF7\u8F93\u5165\u5B57\u7B26\u4E32",
    isRequired: true,
    isClearable: true,
    color: "primary",
    ...config3
  }),
  /**
   * 数字输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  number: (key, config3 = {}) => createInput(key, {
    type: "number",
    label: "\u6570\u5B57",
    placeholder: "\u8BF7\u8F93\u5165\u6570\u5B57",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        min: 0,
        max: 100,
        error: "\u6570\u5B57\u5E94\u57280-100\u4E4B\u95F4"
      }
    ],
    ...config3
  }),
  /**
   * 布尔值输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  boolean: (key, config3 = {}) => createInput(key, {
    type: "text",
    label: "\u5E03\u5C14\u503C",
    placeholder: "\u8BF7\u8F93\u5165\u5E03\u5C14\u503C",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^(true|false)$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u5E03\u5C14\u503C"
      }
    ],
    ...config3
  }),
  /**
   * 日期输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  date: (key, config3 = {}) => createInput(key, {
    type: "text",
    label: "\u65E5\u671F",
    placeholder: "\u8BF7\u8F93\u5165\u65E5\u671F",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^\d{4}-\d{2}-\d{2}$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u65E5\u671F\u683C\u5F0F"
      }
    ],
    ...config3
  }),
  /**
   * 时间输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  time: (key, config3 = {}) => createInput(key, {
    type: "text",
    label: "\u65F6\u95F4",
    placeholder: "\u8BF7\u8F93\u5165\u65F6\u95F4",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^\d{2}:\d{2}:\d{2}$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u65F6\u95F4\u683C\u5F0F"
      }
    ],
    ...config3
  }),
  /**
   * 日期时间输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  datetime: (key, config3 = {}) => createInput(key, {
    type: "text",
    label: "\u65E5\u671F\u65F6\u95F4",
    placeholder: "\u8BF7\u8F93\u5165\u65E5\u671F\u65F6\u95F4",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u65E5\u671F\u65F6\u95F4\u683C\u5F0F"
      }
    ],
    ...config3
  }),
  /**
   * 邮箱输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  email: (key, config3 = {}) => createInput(key, {
    type: "email",
    label: "\u90AE\u7BB1",
    placeholder: "\u8BF7\u8F93\u5165\u90AE\u7BB1",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$",
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u90AE\u7BB1\u5730\u5740"
      },
      {
        minLength: 5,
        maxLength: 50,
        error: "\u90AE\u7BB1\u957F\u5EA6\u5E94\u57285-50\u4E2A\u5B57\u7B26\u4E4B\u95F4"
      }
    ],
    ...config3
  }),
  /**
   * URL输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  url: (key, config3 = {}) => createInput(key, {
    type: "url",
    label: "URL",
    placeholder: "\u8BF7\u8F93\u5165URL",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([/\w .-]*)*\/?$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684URL\u5730\u5740"
      }
    ],
    ...config3
  }),
  /**
   * 电话输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  tel: (key, config3 = {}) => createInput(key, {
    type: "tel",
    label: "\u7535\u8BDD",
    placeholder: "\u8BF7\u8F93\u5165\u7535\u8BDD",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^1[3-9]\d{9}$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u624B\u673A\u53F7\u7801"
      }
    ],
    ...config3
  }),
  /**
   * 密码输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  password: (key, config3 = {}) => createInput(key, {
    type: "password",
    label: "\u5BC6\u7801",
    placeholder: "\u8BF7\u8F93\u5165\u5BC6\u7801",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        minLength: 1,
        error: "\u5BC6\u7801\u957F\u5EA6\u4E0D\u80FD\u5C0F\u4E8E1\u4F4D"
      }
    ],
    ...config3
  }),
  /**
   * 颜色输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  color: (key, config3 = {}) => createInput(key, {
    type: "text",
    label: "\u989C\u8272",
    placeholder: "\u8BF7\u8F93\u5165\u989C\u8272",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u989C\u8272\u683C\u5F0F"
      }
    ],
    ...config3
  }),
  /**
   * JSON输入框
   * @param key 唯一标识符
   * @param config 输入框配置
   */
  json: (key, config3 = {}) => createInput(key, {
    type: "text",
    label: "JSON",
    placeholder: "\u8BF7\u8F93\u5165JSON",
    isRequired: true,
    isClearable: true,
    color: "primary",
    rules: [
      {
        regex: /^[^{}]*$/,
        error: "\u8BF7\u8F93\u5165\u6709\u6548\u7684JSON\u683C\u5F0F"
      }
    ],
    ...config3
  })
};

// src/components/switch.ts
var createSwitch = (key, config3 = {}) => ({
  ...config3,
  key,
  componentType: "switch"
});
var switchComponent = {
  /**
   * 创建基础开关
   * @param key 唯一标识符
   * @param options 开关配置
   */
  create: (key, options = {}) => createSwitch(key, options),
  /**
   * 自定义开关
   * @param key 唯一标识符
   * @param config 开关配置
   */
  options: (key, config3 = {}) => createSwitch(key, {
    startText: "\u5F00\u542F",
    endText: "\u5173\u95ED",
    size: "md",
    color: "primary",
    isSelected: false,
    defaultSelected: false,
    isReadOnly: false,
    isDisabled: false,
    disableAnimation: false,
    ...config3
  })
};

// src/components/divider.ts
var createDivider = (key, config3 = {}) => ({
  componentType: "divider",
  transparent: false,
  orientation: "horizontal",
  ...config3,
  key
});
var divider = {
  /**
   * 创建基础分隔线
   * @param key 唯一标识符
   * @param options 分隔线配置
   */
  create: (key, options = {}) => createDivider(key, options),
  /**
   * 创建水平分隔线
   * @param key 唯一标识符
   * @param config 分隔线配置
   */
  horizontal: (key, config3 = {}) => createDivider(key, {
    orientation: "horizontal",
    ...config3
  }),
  /**
   * 创建垂直分隔线
   * @param key 唯一标识符
   * @param config 分隔线配置
   */
  vertical: (key, config3 = {}) => createDivider(key, {
    orientation: "vertical",
    ...config3
  })
};

// src/components/cron.ts
var createCron = (key, config3 = {}) => ({
  componentType: "cron",
  ...config3,
  key
});
var cron = {
  /**
   * 创建基础分隔线
   * @param key 唯一标识符
   * @param options 分隔线配置
   */
  create: (key, options = {}) => createCron(key, options)
};

// src/components/radioGroup.ts
var createRadio = (key, config3 = {}) => ({
  ...config3,
  key,
  value: config3.value || "",
  componentType: "radio"
});
var createRadioGroup = (key, config3 = {}) => ({
  ...config3,
  key,
  componentType: "radio-group",
  radio: config3.radio || []
});
var radio = {
  /**
   * 创建基础单选框
   * @param key 唯一标识符
   * @param options 单选框配置
   */
  create: (key, options) => createRadio(key, options),
  /**
   * 创建单选框组
   * @param key 唯一标识符
   * @param options 单选框组配置
   */
  group: (key, options) => createRadioGroup(key, options),
  /**
   * 默认单选框组
   * @param key 唯一标识符
   * @param config 单选框组配置
   */
  defaultGroup: (key, config3) => {
    if (!Array.isArray(config3?.radio)) {
      throw new Error("radio \u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u7EC4");
    }
    return createRadioGroup(key, { radio: config3.radio });
  },
  /**
   * 默认单选框
   * @param key 唯一标识符
   * @param config 单选框配置
   */
  default: (key, config3 = {}) => createRadio(key, {
    ...config3
  }),
  /**
   * 必选单选框
   * @param key 唯一标识符
   * @param config 单选框配置
   */
  required: (key, config3 = {}) => createRadio(key, {
    ...config3,
    isRequired: true
  }),
  /**
   * 禁用单选框
   * @param key 唯一标识符
   * @param config 单选框配置
   */
  disabled: (key, config3 = {}) => createRadio(key, {
    ...config3,
    isDisabled: true
  }),
  /**
   * 只读单选框
   * @param key 唯一标识符
   * @param config 单选框配置
   */
  readonly: (key, config3 = {}) => createRadio(key, {
    ...config3,
    isReadOnly: true
  }),
  /**
   * 错误状态单选框
   * @param key 唯一标识符
   * @param config 单选框配置
   */
  invalid: (key, config3 = {}) => createRadio(key, {
    isInvalid: true,
    ...config3
  })
};

// src/components/checkbox.ts
var createCheckbox = (key, config3 = {}) => ({
  ...config3,
  key,
  componentType: "checkbox"
});
var createCheckboxGroup = (key, config3 = {}) => ({
  ...config3,
  key,
  componentType: "checkbox-group",
  checkbox: config3.checkbox || []
});
var checkbox = {
  /**
   * 创建基础复选框
   * @param key 唯一标识符
   * @param options 复选框配置
   */
  create: (key, options) => createCheckbox(key, options),
  /**
   * 创建复选框组
   * @param key 唯一标识符
   * @param options 复选框组配置
   */
  group: (key, options) => createCheckboxGroup(key, options),
  /**
   * 默认复选框组
   * @param key 唯一标识符
   * @param config 复选框组配置
   */
  defaultGroup: (key, config3) => {
    if (!Array.isArray(config3?.checkbox)) {
      throw new Error("checkbox \u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u7EC4");
    }
    return createCheckboxGroup(key, { checkbox: config3.checkbox });
  },
  /**
   * 默认复选框
   * @param key 唯一标识符
   * @param config 复选框配置
   */
  default: (key, config3 = {}) => createCheckbox(key, {
    ...config3
  }),
  /**
   * 必选复选框
   * @param key 唯一标识符
   * @param config 复选框配置
   */
  required: (key, config3 = {}) => createCheckbox(key, {
    ...config3,
    isRequired: true
  }),
  /**
   * 禁用复选框
   * @param key 唯一标识符
   * @param config 复选框配置
   */
  disabled: (key, config3 = {}) => createCheckbox(key, {
    ...config3,
    isDisabled: true
  }),
  /**
   * 只读复选框
   * @param key 唯一标识符
   * @param config 复选框配置
   */
  readonly: (key, config3 = {}) => createCheckbox(key, {
    ...config3,
    isReadOnly: true
  }),
  /**
   * 不确定状态复选框
   * @param key 唯一标识符
   * @param config 复选框配置
   */
  indeterminate: (key, config3 = {}) => createCheckbox(key, {
    isIndeterminate: true,
    ...config3
  }),
  /**
   * 错误状态复选框
   * @param key 唯一标识符
   * @param config 复选框配置
   */
  invalid: (key, config3 = {}) => createCheckbox(key, {
    isInvalid: true,
    ...config3
  })
};

// src/components/all.ts
var components = {
  /** 分隔线 */
  divider,
  /** 输入框 */
  input,
  /** 开关 */
  switch: switchComponent,
  /** 手风琴 */
  accordion,
  /** 手风琴Pro */
  accordionPro,
  /** 手风琴项 */
  accordionItem,
  /** 单选框 */
  radio,
  /** 多选框 */
  checkbox,
  /** cron */
  cron
};

// src/hooks/index.ts
init_empty();
init_messaeg();
init_sendMsg();
init_eventCall();
var hooks = {
  message,
  sendMsg,
  empty,
  eventCall
};

// src/index.ts
init_template();
init_base();
init_list();

// src/plugin/class.ts
var Plugin = class {
  /** 插件名称 */
  name;
  /** 指令规则集 */
  rule;
  /** 插件描述 */
  desc;
  /** 插件事件 */
  event;
  /** 优先级 */
  priority;
  /** 消息事件对象 */
  e;
  /** 调用后将继续匹配下一个插件 */
  next;
  /** 快速回复 */
  reply;
  constructor(options) {
    const { name, rule } = options;
    this.name = name;
    this.rule = rule;
    this.desc = options.desc || "\u65E0\u63CF\u8FF0";
    this.event = options.event || "message";
    this.priority = options.priority || 1e4;
  }
  /**
   * 快速回复合并转发
   * @param element 合并转发消息元素节点
   */
  async replyForward(element) {
    const result = await this.e.bot.sendForwardMsg(this.e.contact, element);
    return {
      ...result,
      /** @deprecated 已废弃 请请使用 messageId */
      message_id: result.messageId
    };
  }
};

// src/index.ts
init_kv();
init_redis3();

// src/utils/logger/index.ts
init_logger2();

// src/index.ts
var isStart = false;
if (!process.env.EBV_FILE) process.env.EBV_FILE = ".env";
var start2 = async () => {
  if (isStart) {
    console.error("karin \u5DF2\u7ECF\u542F\u52A8\uFF0C\u8BF7\u52FF\u91CD\u590D\u542F\u52A8");
    return;
  }
  isStart = true;
  dotenv_default.config({ path: `${path4.resolve(process.cwd(), process.env.EBV_FILE)}` });
  await initConfig2(root_default);
  printStartLog(process.env.KARIN_VERSION);
  await initProcess(+process.env.HTTP_PORT);
  const { initExpress: initExpress2 } = await Promise.resolve().then(() => (init_app(), app_exports));
  const { initialize: initialize2 } = await Promise.resolve().then(() => (init_terminalManager(), terminalManager_exports));
  await initExpress2(root_default, +process.env.HTTP_PORT, process.env.HTTP_HOST);
  await initTaskSystem(root_default.karinPathTaskDb);
  await createRedis();
  await createDB();
  await initialize2();
  await initPlugins();
  await Promise.resolve().then(() => (init_adapter2(), adapter_exports));
  await initOneBotAdapter();
  await initRender2();
  const { startCleanExpiredFiles: startCleanExpiredFiles2 } = await Promise.resolve().then(() => (init_template(), template_exports));
  startCleanExpiredFiles2();
  const {
    initWebSocketPuppeteerServer: initWebSocketPuppeteerServer2,
    initSnapkaClient: initSnapkaClient2,
    initSnapkaHttp: initSnapkaHttp2
  } = await Promise.resolve().then(() => (init_snapka(), snapka_exports));
  initWebSocketPuppeteerServer2();
  initSnapkaClient2();
  initSnapkaHttp2();
  listeners.emit(ONLINE, {});
  logger.mark(`karin \u542F\u52A8\u5B8C\u6210: \u8017\u65F6 ${logger.green(process.uptime().toFixed(2))} \u79D2...`);
};
/*! Bundled license information:

@karinjs/jsonwebtoken/dist/jsonwebtoken.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/

export { AdapterBase, AdapterConvertKarin, AdapterOneBot, BASE_ROUTER, BATCH_UPDATE_PLUGINS_ROUTER, BaseEvent, Bot, CHECK_PLUGIN_ROUTER, CLOSE_TERMINAL_ROUTER, CONSOLE_ROUTER, CREATE_TERMINAL_ROUTER, DirectMessage, EVENT_COUNT, EXIT_ROUTER, FILE_CHANGE, FriendDecreaseNotice, FriendIncreaseNotice, FriendMessage, GET_BOTS_ROUTER, GET_CONFIG_ROUTER, GET_DEPENDENCIES_LIST_ROUTER, GET_LOADED_COMMAND_PLUGIN_CACHE_LIST_ROUTER, GET_LOCAL_PLUGIN_FRONTEND_LIST_ROUTER, GET_LOCAL_PLUGIN_LIST_ROUTER, GET_LOG_FILE_LIST_ROUTER, GET_LOG_FILE_ROUTER, GET_LOG_ROUTER, GET_NETWORK_STATUS_ROUTER, GET_NPMRC_LIST_ROUTER, GET_NPM_BASE_CONFIG_ROUTER, GET_NPM_CONFIG_ROUTER, GET_ONLINE_PLUGIN_LIST_ROUTER, GET_PLUGIN_APPS_ROUTER, GET_PLUGIN_CONFIG_ROUTER, GET_PLUGIN_FILE_ROUTER, GET_PLUGIN_LIST_PLUGIN_ADMIN_ROUTER, GET_PLUGIN_LIST_ROUTER, GET_PLUGIN_MARKET_LIST_ROUTER, GET_TASK_LIST_ROUTER, GET_TASK_STATUS_ROUTER, GET_TERMINAL_LIST_ROUTER, GET_UPDATABLE_PLUGINS_ROUTER, GET_WEBUI_PLUGIN_LIST_ROUTER, GET_WEBUI_PLUGIN_VERSIONS_ROUTER, GroupAdminChangedNotice, GroupApplyRequest, GroupCardChangedNotice, GroupFileUploadedNotice, GroupHlightsChangedNotice, GroupHonorChangedNotice, GroupInviteRequest, GroupLuckKingNotice, GroupMemberBanNotice, GroupMemberDecreaseNotice, GroupMemberIncreaseNotice, GroupMemberTitleUpdatedNotice, GroupMessage, GroupMessageReactionNotice, GroupNotice, GroupPokeNotice, GroupRecallNotice, GroupSignInNotice, GroupTempMessage, GroupWholeBanNotice, GuildMessage, HTTPStatusCode, INSTALL_PLUGIN_ROUTER, INSTALL_WEBUI_PLUGIN_ROUTER, IS_PLUGIN_CONFIG_EXIST_ROUTER, KarinConvertAdapter, LOGIN_ROUTER, MANAGE_DEPENDENCIES_ROUTER, MessageBase, NoticeBase, createMessage as OneBotCreateMessage, createNotice as OneBotCreateNotice, createRequest as OneBotCreateRequest, PING_ROUTER, PLUGIN_ADMIN_ROUTER, Plugin, PrivateApplyRequest, PrivateFileUploadedNotice, PrivatePokeNotice, PrivateRecallNotice, RECV_MSG, REFRESH_ROUTER, RESTART_ROUTER, ReceiveLikeNotice, Renderer, RequestBase, SAVE_CONFIG_ROUTER, SAVE_NPMRC_ROUTER, SAVE_PLUGIN_CONFIG_ROUTER, SEND_MSG, SET_LOG_LEVEL_ROUTER, SYSTEM_INFO_ROUTER, SYSTEM_STATUS_KARIN_ROUTER, SYSTEM_STATUS_ROUTER, SYSTEM_STATUS_WS_ROUTER, TASK_DELETE_ROUTER, TASK_LIST_ROUTER, TASK_LOGS_ROUTER, TASK_RUN_ROUTER, UNINSTALL_PLUGIN_ROUTER, UNINSTALL_WEBUI_PLUGIN_ROUTER, UPDATE_CORE_ROUTER, UPDATE_PLUGIN_ROUTER, UPDATE_TASK_STATUS_ROUTER, UPDATE_WEBUI_PLUGIN_VERSION_ROUTER, WS_CLOSE, WS_CLOSE_ONEBOT, WS_CLOSE_PUPPETEER, WS_CLOSE_SANDBOX, WS_CONNECTION, WS_CONNECTION_ONEBOT, WS_CONNECTION_PUPPETEER, WS_CONNECTION_SANDBOX, WS_CONNECTION_TERMINAL, WS_SNAPKA, Watch, Watcher, YamlEditor, absPath, accordion, accordionItem, accordionPro, app4 as app, applyComments, authMiddleware, base64, basePath, buffer, buildError, buildGithub, buttonHandle, cacheMap, callRender, changelog_exports as changelog, checkGitPluginUpdate, checkPkgUpdate, checkPort, clearRequire, clearRequireFile, comment, commentPath, common_exports as common, components, config_exports as config, configPath, consolePath, contact2 as contact, contactDirect, contactFriend, contactGroup, contactGroupTemp, contactGuild, convertOneBotMessageToKarin, copyConfig, copyConfigSync, copyFiles, copyFilesSync, createAccessTokenExpiredResponse, createBadRequestResponse, createDirectMessage, createForbiddenResponse, createFriendDecreaseNotice, createFriendIncreaseNotice, createFriendMessage, createGroupAdminChangedNotice, createGroupApplyRequest, createGroupCardChangedNotice, createGroupFileUploadedNotice, createGroupHlightsChangedNotice, createGroupHonorChangedNotice, createGroupInviteRequest, createGroupLuckKingNotice, createGroupMemberAddNotice, createGroupMemberBanNotice, createGroupMemberDelNotice, createGroupMemberTitleUpdatedNotice, createGroupMessage, createGroupMessageReactionNotice, createGroupPokeNotice, createGroupRecallNotice, createGroupSignInNotice, createGroupTempMessage, createGroupWholeBanNotice, createGuildMessage, createINIParser, createMethodNotAllowedResponse, createNotFoundResponse, createOneBotClient, createOneBotHttp, createOneBotWsServer, createPayloadTooLargeResponse, createPluginDir, createPrivateApplyRequest, createPrivateFileUploadedNotice, createPrivatePokeNotice, createPrivateRecallNotice, createRawMessage, createReceiveLikeNotice, createRefreshTokenExpiredResponse, createResponse, createServerErrorResponse, createSuccessResponse, createTaskDatabase, createUnauthorizedResponse, cron, dataPath, db, dbPath, debug2 as debug, karin as default, defaultConfigPath, defaultViewPath, defineConfig, disconnectAllOneBotServer, divider, downFile, downloadFile, errorToString, exec, executeTask, existToMkdir, existToMkdirSync, exists, existsSync, ffmpeg, ffplay, ffprobe, fs_exports as file, fileToBase64, fileToUrl, fileToUrlHandlerKey, filesByExt, formatLogString, formatPath, formatTime, fs_exports2 as fs, getAllBot, getAllBotID, getAllBotList, getAllFiles, getAllFilesSync, getBot, getBotCount, getCommit, getDefaultBranch, getFastGithub, getFastRegistry, getFileMessage, getFiles, getHash, getLocalBranches, getLocalCommitHash, getMimeType, getPackageJson, getPid, getPkgVersion, getPluginInfo, getPlugins, getRelPath, getRemoteBranches, getRemoteCommitHash, getRemotePkgVersion, getRender, getRenderCount, getRenderList, getRequestIp, getTaskCallback, getTaskDatabase, getTime, gitPull, handler, hooks, htmlPath, importModule, imports, ini, initOneBotAdapter, initTaskSystem, input, isClass, isDir, isDirSync, isDocker, isFile, isFileSync, isIPv4Loop, isIPv6Loop, isLinux, isLocalRequest, isLoopback, isMac, isPackaged, isPathEqual, isPkg, isPlugin, isPublic, isRoot, isSubPath, isWin2 as isWin, json, karin, karinDir, karinMain, karinPathBase, karinPathComment, karinPathConfig, karinPathConsole, karinPathData, karinPathDb, karinPathDefaultConfig, karinPathDefaultView, karinPathHtml, karinPathKv, karinPathLogs, karinPathMain, karinPathPlugins, karinPathPm2Config, karinPathRedisSqlite3, karinPathResource, karinPathRoot, karinPathSandboxData, karinPathSandboxTemp, karinPathTaskDb, karinPathTemp, karinToQQBot, key_exports as key, killApp, kvPath, lock, lockMethod, lockProp, log, logger2 as logger, logs, logsPath, makeForward, makeMessage, mkdir, mkdirSync, parseChangelog, parseGithubUrl, pingRequest, pkgRoot, pluginDir, pm2Path, qqbotToKarin, raceRequest, randomStr, range, read, readFile, readJson, readJsonSync, redis2 as redis, redisSqlite3Path, registerBot, registerRender, removeTaskCallback, render, renderHtml, renderMultiHtml, renderTpl, requireFile, requireFileSync, resourcePath, restart, restartDirect, rmSync, router, sandboxDataPath, sandboxTempPath, satisfies, save, segment_exports as segment, sendMsg2 as sendMsg, sender, senderDirect, senderFriend, senderGroup, senderGroupTemp, senderGuild, sep, server, setTaskCallback, setTaskDatabase, splitPath, start2 as start, stream, stringifyError, switchComponent, system_exports as system, taskAdd, taskExists, taskGet, taskList, taskSystem, taskUpdateLogs, taskUpdateStatus, tempPath, unregisterBot, unregisterRender, updateAllGitPlugin, updateAllPkg, updateGitPlugin, updatePkg, updateTaskLogs, updateTaskStatus, uptime, urlToPath, waitPort, watch, watchAndMerge, write, writeJson, writeJsonSync, yaml3 as yaml };

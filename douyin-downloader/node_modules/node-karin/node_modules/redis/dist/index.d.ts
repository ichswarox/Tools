/// <reference types="node" />
import * as net from 'net';
import * as tls from 'tls';
import { EventEmitter } from 'events';

declare const FIRST_KEY_INDEX$4z = 1;
declare const IS_READ_ONLY$2x = true;
interface ReserveOptions$2 {
    width: number;
    depth: number;
    decay: number;
}
declare function transformArguments$7x(key: string, topK: number, options?: ReserveOptions$2): Array<string>;
declare function transformReply$6c(): 'OK';

declare namespace _redis_bloom_dist_commands_top_k_RESERVE {
  export { FIRST_KEY_INDEX$4z as FIRST_KEY_INDEX, IS_READ_ONLY$2x as IS_READ_ONLY, transformArguments$7x as transformArguments, transformReply$6c as transformReply };
}

declare const symbol: unique symbol;
type CommandOptions<T> = T & {
    readonly [symbol]: true;
};

interface RedisScriptConfig extends RedisCommand$1 {
    SCRIPT: string;
    NUMBER_OF_KEYS?: number;
}
interface SHA1 {
    SHA1: string;
}
declare function defineScript$1<S extends RedisScriptConfig>(script: S): S & SHA1;

type RedisCommandRawReply = string | number | Buffer | null | undefined | Array<RedisCommandRawReply>;
type RedisCommandArgument$5 = string | Buffer;
type RedisCommandArguments$5 = Array<RedisCommandArgument$5> & {
    preserve?: unknown;
};
interface RedisCommand$1 {
    FIRST_KEY_INDEX?: number | ((...args: Array<any>) => RedisCommandArgument$5 | undefined);
    IS_READ_ONLY?: boolean;
    TRANSFORM_LEGACY_REPLY?: boolean;
    transformArguments(this: void, ...args: Array<any>): RedisCommandArguments$5;
    transformReply?(this: void, reply: any, preserved?: any): any;
}
type RedisCommandReply<C extends RedisCommand$1> = C['transformReply'] extends (...args: any) => infer T ? T : RedisCommandRawReply;
type ConvertArgumentType<Type, ToType> = Type extends RedisCommandArgument$5 ? (Type extends (string & ToType) ? Type : ToType) : (Type extends Set<infer Member> ? Set<ConvertArgumentType<Member, ToType>> : (Type extends Map<infer Key, infer Value> ? Map<Key, ConvertArgumentType<Value, ToType>> : (Type extends Array<infer Member> ? Array<ConvertArgumentType<Member, ToType>> : (Type extends Date ? Type : (Type extends Record<PropertyKey, any> ? {
    [Property in keyof Type]: ConvertArgumentType<Type[Property], ToType>;
} : Type)))));
type RedisCommandSignature<Command extends RedisCommand$1, Params extends Array<unknown> = Parameters<Command['transformArguments']>> = <Options extends CommandOptions<ClientCommandOptions$1>>(...args: Params | [options: Options, ...rest: Params]) => Promise<ConvertArgumentType<RedisCommandReply<Command>, Options['returnBuffers'] extends true ? Buffer : string>>;
interface RedisModule {
    [command: string]: RedisCommand$1;
}
interface RedisModules {
    [module: string]: RedisModule;
}
interface RedisFunction$1 extends RedisCommand$1 {
    NUMBER_OF_KEYS?: number;
}
interface RedisFunctionLibrary$1 {
    [fn: string]: RedisFunction$1;
}
interface RedisFunctions$1 {
    [library: string]: RedisFunctionLibrary$1;
}
type RedisScript$1 = RedisScriptConfig & SHA1;
interface RedisScripts$1 {
    [script: string]: RedisScript$1;
}
interface RedisExtensions<M extends RedisModules = RedisModules, F extends RedisFunctions$1 = RedisFunctions$1, S extends RedisScripts$1 = RedisScripts$1> {
    modules?: M;
    functions?: F;
    scripts?: S;
}
type ExcludeMappedString<S> = string extends S ? never : S;

declare const FIRST_KEY_INDEX$4y = 1;
interface ZUnionOptions$1 {
    WEIGHTS?: Array<number>;
    AGGREGATE?: 'SUM' | 'MIN' | 'MAX';
}
declare function transformArguments$7w(destination: RedisCommandArgument$5, keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5, options?: ZUnionOptions$1): RedisCommandArguments$5;
declare function transformReply$6b(): number;

declare namespace ZUNIONSTORE {
  export { FIRST_KEY_INDEX$4y as FIRST_KEY_INDEX, transformArguments$7w as transformArguments, transformReply$6b as transformReply };
}

declare const FIRST_KEY_INDEX$4x = 2;
declare const IS_READ_ONLY$2w = true;
interface ZUnionOptions {
    WEIGHTS?: Array<number>;
    AGGREGATE?: 'SUM' | 'MIN' | 'MAX';
}
declare function transformArguments$7v(keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5, options?: ZUnionOptions): RedisCommandArguments$5;
declare function transformReply$6a(): Array<RedisCommandArgument$5>;

declare namespace ZUNION {
  export { FIRST_KEY_INDEX$4x as FIRST_KEY_INDEX, IS_READ_ONLY$2w as IS_READ_ONLY, transformArguments$7v as transformArguments, transformReply$6a as transformReply };
}

declare function transformBooleanReply$2(reply: number): boolean;
declare function transformBooleanArrayReply$1(reply: Array<number>): Array<boolean>;
type BitValue = 0 | 1;
interface ScanOptions {
    MATCH?: string;
    COUNT?: number;
}
declare function transformNumberInfinityReply(reply: RedisCommandArgument$5): number;
declare function transformNumberInfinityNullReply(reply: RedisCommandArgument$5 | null): number | null;
declare function transformNumberInfinityNullArrayReply(reply: Array<RedisCommandArgument$5 | null>): Array<number | null>;
declare function transformTuplesReply(reply: Array<RedisCommandArgument$5>): Record<string, RedisCommandArgument$5>;
interface StreamMessageReply {
    id: RedisCommandArgument$5;
    message: Record<string, RedisCommandArgument$5>;
}
type StreamMessagesReply = Array<StreamMessageReply>;
declare function transformStreamMessagesReply(reply: Array<any>): StreamMessagesReply;
type StreamMessagesNullReply = Array<StreamMessageReply | null>;
declare function transformStreamMessagesNullReply(reply: Array<any>): StreamMessagesNullReply;
type StreamsMessagesReply = Array<{
    name: RedisCommandArgument$5;
    messages: StreamMessagesReply;
}> | null;
declare function transformStreamsMessagesReply(reply: Array<any> | null): StreamsMessagesReply | null;
interface ZMember {
    score: number;
    value: RedisCommandArgument$5;
}
declare function transformSortedSetMemberNullReply(reply: [RedisCommandArgument$5, RedisCommandArgument$5] | []): ZMember | null;
declare function transformSortedSetWithScoresReply(reply: Array<RedisCommandArgument$5>): Array<ZMember>;
type SortedSetSide = 'MIN' | 'MAX';
interface ZMPopOptions {
    COUNT?: number;
}
type ListSide = 'LEFT' | 'RIGHT';
interface LMPopOptions {
    COUNT?: number;
}
type GeoCountArgument = number | {
    value: number;
    ANY?: true;
};
type GeoUnits = 'm' | 'km' | 'mi' | 'ft';
interface GeoCoordinates$1 {
    longitude: string | number;
    latitude: string | number;
}
type GeoSearchFromMember = string;
type GeoSearchFrom = GeoSearchFromMember | GeoCoordinates$1;
interface GeoSearchByRadius {
    radius: number;
    unit: GeoUnits;
}
interface GeoSearchByBox {
    width: number;
    height: number;
    unit: GeoUnits;
}
type GeoSearchBy = GeoSearchByRadius | GeoSearchByBox;
interface GeoSearchOptions {
    SORT?: 'ASC' | 'DESC';
    COUNT?: GeoCountArgument;
}
interface GeoRadiusStoreOptions extends GeoSearchOptions {
    STOREDIST?: boolean;
}
declare enum GeoReplyWith$1 {
    DISTANCE = "WITHDIST",
    HASH = "WITHHASH",
    COORDINATES = "WITHCOORD"
}
interface GeoReplyWithMember {
    member: string;
    distance?: number;
    hash?: string;
    coordinates?: {
        longitude: string;
        latitude: string;
    };
}
declare function transformGeoMembersWithReply(reply: Array<Array<any>>, replyWith: Array<GeoReplyWith$1>): Array<GeoReplyWithMember>;
interface EvalOptions {
    keys?: Array<string>;
    arguments?: Array<string>;
}
declare function evalFirstKeyIndex(options?: EvalOptions): string | undefined;
declare enum CommandFlags {
    WRITE = "write",
    READONLY = "readonly",
    DENYOOM = "denyoom",
    ADMIN = "admin",
    PUBSUB = "pubsub",
    NOSCRIPT = "noscript",
    RANDOM = "random",
    SORT_FOR_SCRIPT = "sort_for_script",
    LOADING = "loading",
    STALE = "stale",
    SKIP_MONITOR = "skip_monitor",
    ASKING = "asking",
    FAST = "fast",
    MOVABLEKEYS = "movablekeys"
}
declare enum CommandCategories {
    KEYSPACE = "@keyspace",
    READ = "@read",
    WRITE = "@write",
    SET = "@set",
    SORTEDSET = "@sortedset",
    LIST = "@list",
    HASH = "@hash",
    STRING = "@string",
    BITMAP = "@bitmap",
    HYPERLOGLOG = "@hyperloglog",
    GEO = "@geo",
    STREAM = "@stream",
    PUBSUB = "@pubsub",
    ADMIN = "@admin",
    FAST = "@fast",
    SLOW = "@slow",
    BLOCKING = "@blocking",
    DANGEROUS = "@dangerous",
    CONNECTION = "@connection",
    TRANSACTION = "@transaction",
    SCRIPTING = "@scripting"
}
type CommandRawReply = [
    name: string,
    arity: number,
    flags: Array<CommandFlags>,
    firstKeyIndex: number,
    lastKeyIndex: number,
    step: number,
    categories: Array<CommandCategories>
];
type CommandReply = {
    name: string;
    arity: number;
    flags: Set<CommandFlags>;
    firstKeyIndex: number;
    lastKeyIndex: number;
    step: number;
    categories: Set<CommandCategories>;
};
declare enum RedisFunctionFlags {
    NO_WRITES = "no-writes",
    ALLOW_OOM = "allow-oom",
    ALLOW_STALE = "allow-stale",
    NO_CLUSTER = "no-cluster"
}
type FunctionListRawItemReply = [
    'library_name',
    string,
    'engine',
    string,
    'functions',
    Array<[
        'name',
        string,
        'description',
        string | null,
        'flags',
        Array<RedisFunctionFlags>
    ]>
];
interface FunctionListItemReply {
    libraryName: string;
    engine: string;
    functions: Array<{
        name: string;
        description: string | null;
        flags: Array<RedisFunctionFlags>;
    }>;
}
interface SortOptions {
    BY?: string;
    LIMIT?: {
        offset: number;
        count: number;
    };
    GET?: string | Array<string>;
    DIRECTION?: 'ASC' | 'DESC';
    ALPHA?: true;
}
interface SlotRange {
    start: number;
    end: number;
}
type RawRangeReply = [
    start: number,
    end: number
];
interface RangeReply {
    start: number;
    end: number;
}

declare function transformArguments$7u(...args: Parameters<typeof transformArguments$7v>): RedisCommandArguments$5;

declare namespace ZUNION_WITHSCORES {
  export { FIRST_KEY_INDEX$4x as FIRST_KEY_INDEX, IS_READ_ONLY$2w as IS_READ_ONLY, transformArguments$7u as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$4w = 1;
declare const IS_READ_ONLY$2v = true;
declare function transformArguments$7t(key: RedisCommandArgument$5, member: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace ZSCORE {
  export { FIRST_KEY_INDEX$4w as FIRST_KEY_INDEX, IS_READ_ONLY$2v as IS_READ_ONLY, transformArguments$7t as transformArguments, transformNumberInfinityNullReply as transformReply };
}

declare const FIRST_KEY_INDEX$4v = 1;
declare const IS_READ_ONLY$2u = true;
declare function transformArguments$7s(key: RedisCommandArgument$5, cursor: number, options?: ScanOptions): RedisCommandArguments$5;
type ZScanRawReply = [RedisCommandArgument$5, Array<RedisCommandArgument$5>];
interface ZScanReply {
    cursor: number;
    members: Array<ZMember>;
}
declare function transformReply$69([cursor, rawMembers]: ZScanRawReply): ZScanReply;

declare namespace ZSCAN {
  export { FIRST_KEY_INDEX$4v as FIRST_KEY_INDEX, IS_READ_ONLY$2u as IS_READ_ONLY, transformArguments$7s as transformArguments, transformReply$69 as transformReply };
}

declare const FIRST_KEY_INDEX$4u = 1;
declare const IS_READ_ONLY$2t = true;
declare function transformArguments$7r(key: RedisCommandArgument$5, member: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$68(): number | null;

declare namespace ZREVRANK {
  export { FIRST_KEY_INDEX$4u as FIRST_KEY_INDEX, IS_READ_ONLY$2t as IS_READ_ONLY, transformArguments$7r as transformArguments, transformReply$68 as transformReply };
}

declare const FIRST_KEY_INDEX$4t = 1;
declare function transformArguments$7q(key: RedisCommandArgument$5, min: RedisCommandArgument$5 | number, max: RedisCommandArgument$5 | number): RedisCommandArguments$5;
declare function transformReply$67(): number;

declare namespace ZREMRANGEBYSCORE {
  export { FIRST_KEY_INDEX$4t as FIRST_KEY_INDEX, transformArguments$7q as transformArguments, transformReply$67 as transformReply };
}

declare const FIRST_KEY_INDEX$4s = 1;
declare function transformArguments$7p(key: RedisCommandArgument$5, start: number, stop: number): RedisCommandArguments$5;
declare function transformReply$66(): number;

declare namespace ZREMRANGEBYRANK {
  export { FIRST_KEY_INDEX$4s as FIRST_KEY_INDEX, transformArguments$7p as transformArguments, transformReply$66 as transformReply };
}

declare const FIRST_KEY_INDEX$4r = 1;
declare function transformArguments$7o(key: RedisCommandArgument$5, min: RedisCommandArgument$5 | number, max: RedisCommandArgument$5 | number): RedisCommandArguments$5;
declare function transformReply$65(): number;

declare namespace ZREMRANGEBYLEX {
  export { FIRST_KEY_INDEX$4r as FIRST_KEY_INDEX, transformArguments$7o as transformArguments, transformReply$65 as transformReply };
}

declare const FIRST_KEY_INDEX$4q = 1;
declare function transformArguments$7n(key: RedisCommandArgument$5, member: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$64(): number;

declare namespace ZREM {
  export { FIRST_KEY_INDEX$4q as FIRST_KEY_INDEX, transformArguments$7n as transformArguments, transformReply$64 as transformReply };
}

declare const FIRST_KEY_INDEX$4p = 1;
declare const IS_READ_ONLY$2s = true;
declare function transformArguments$7m(key: RedisCommandArgument$5, member: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$63(): number | null;

declare namespace ZRANK {
  export { FIRST_KEY_INDEX$4p as FIRST_KEY_INDEX, IS_READ_ONLY$2s as IS_READ_ONLY, transformArguments$7m as transformArguments, transformReply$63 as transformReply };
}

declare const FIRST_KEY_INDEX$4o = 1;
interface ZRangeStoreOptions {
    BY?: 'SCORE' | 'LEX';
    REV?: true;
    LIMIT?: {
        offset: number;
        count: number;
    };
    WITHSCORES?: true;
}
declare function transformArguments$7l(dst: RedisCommandArgument$5, src: RedisCommandArgument$5, min: RedisCommandArgument$5 | number, max: RedisCommandArgument$5 | number, options?: ZRangeStoreOptions): RedisCommandArguments$5;
declare function transformReply$62(reply: number): number;

declare namespace ZRANGESTORE {
  export { FIRST_KEY_INDEX$4o as FIRST_KEY_INDEX, transformArguments$7l as transformArguments, transformReply$62 as transformReply };
}

declare const FIRST_KEY_INDEX$4n = 1;
declare const IS_READ_ONLY$2r = true;
interface ZRangeByScoreOptions {
    LIMIT?: {
        offset: number;
        count: number;
    };
}
declare function transformArguments$7k(key: RedisCommandArgument$5, min: string | number, max: string | number, options?: ZRangeByScoreOptions): RedisCommandArguments$5;
declare function transformReply$61(): Array<RedisCommandArgument$5>;

type ZRANGEBYSCORE_ZRangeByScoreOptions = ZRangeByScoreOptions;
declare namespace ZRANGEBYSCORE {
  export { FIRST_KEY_INDEX$4n as FIRST_KEY_INDEX, IS_READ_ONLY$2r as IS_READ_ONLY, type ZRANGEBYSCORE_ZRangeByScoreOptions as ZRangeByScoreOptions, transformArguments$7k as transformArguments, transformReply$61 as transformReply };
}

declare function transformArguments$7j(key: RedisCommandArgument$5, min: string | number, max: string | number, options?: ZRangeByScoreOptions): RedisCommandArguments$5;

declare namespace ZRANGEBYSCORE_WITHSCORES {
  export { FIRST_KEY_INDEX$4n as FIRST_KEY_INDEX, IS_READ_ONLY$2r as IS_READ_ONLY, transformArguments$7j as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$4m = 1;
declare const IS_READ_ONLY$2q = true;
interface ZRangeByLexOptions {
    LIMIT?: {
        offset: number;
        count: number;
    };
}
declare function transformArguments$7i(key: RedisCommandArgument$5, min: RedisCommandArgument$5, max: RedisCommandArgument$5, options?: ZRangeByLexOptions): RedisCommandArguments$5;
declare function transformReply$60(): Array<RedisCommandArgument$5>;

type ZRANGEBYLEX_ZRangeByLexOptions = ZRangeByLexOptions;
declare namespace ZRANGEBYLEX {
  export { FIRST_KEY_INDEX$4m as FIRST_KEY_INDEX, IS_READ_ONLY$2q as IS_READ_ONLY, type ZRANGEBYLEX_ZRangeByLexOptions as ZRangeByLexOptions, transformArguments$7i as transformArguments, transformReply$60 as transformReply };
}

declare const FIRST_KEY_INDEX$4l = 1;
declare const IS_READ_ONLY$2p = true;
interface ZRangeOptions {
    BY?: 'SCORE' | 'LEX';
    REV?: true;
    LIMIT?: {
        offset: number;
        count: number;
    };
}
declare function transformArguments$7h(key: RedisCommandArgument$5, min: RedisCommandArgument$5 | number, max: RedisCommandArgument$5 | number, options?: ZRangeOptions): RedisCommandArguments$5;
declare function transformReply$5$(): Array<RedisCommandArgument$5>;

declare namespace ZRANGE {
  export { FIRST_KEY_INDEX$4l as FIRST_KEY_INDEX, IS_READ_ONLY$2p as IS_READ_ONLY, transformArguments$7h as transformArguments, transformReply$5$ as transformReply };
}

declare function transformArguments$7g(...args: Parameters<typeof transformArguments$7h>): RedisCommandArguments$5;

declare namespace ZRANGE_WITHSCORES {
  export { FIRST_KEY_INDEX$4l as FIRST_KEY_INDEX, IS_READ_ONLY$2p as IS_READ_ONLY, transformArguments$7g as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$4k = 1;
declare const IS_READ_ONLY$2o = true;
declare function transformArguments$7f(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5_(): RedisCommandArgument$5 | null;

declare namespace ZRANDMEMBER {
  export { FIRST_KEY_INDEX$4k as FIRST_KEY_INDEX, IS_READ_ONLY$2o as IS_READ_ONLY, transformArguments$7f as transformArguments, transformReply$5_ as transformReply };
}

declare function transformArguments$7e(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;
declare function transformReply$5Z(): Array<RedisCommandArgument$5>;

declare namespace ZRANDMEMBER_COUNT {
  export { FIRST_KEY_INDEX$4k as FIRST_KEY_INDEX, IS_READ_ONLY$2o as IS_READ_ONLY, transformArguments$7e as transformArguments, transformReply$5Z as transformReply };
}

declare function transformArguments$7d(...args: Parameters<typeof transformArguments$7e>): RedisCommandArguments$5;

declare namespace ZRANDMEMBER_COUNT_WITHSCORES {
  export { FIRST_KEY_INDEX$4k as FIRST_KEY_INDEX, IS_READ_ONLY$2o as IS_READ_ONLY, transformArguments$7d as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$4j = 1;
declare function transformArguments$7c(key: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace ZPOPMIN {
  export { FIRST_KEY_INDEX$4j as FIRST_KEY_INDEX, transformArguments$7c as transformArguments, transformSortedSetMemberNullReply as transformReply };
}

declare function transformArguments$7b(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;

declare namespace ZPOPMIN_COUNT {
  export { FIRST_KEY_INDEX$4j as FIRST_KEY_INDEX, transformArguments$7b as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$4i = 1;
declare function transformArguments$7a(key: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace ZPOPMAX {
  export { FIRST_KEY_INDEX$4i as FIRST_KEY_INDEX, transformArguments$7a as transformArguments, transformSortedSetMemberNullReply as transformReply };
}

declare function transformArguments$79(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;

declare namespace ZPOPMAX_COUNT {
  export { FIRST_KEY_INDEX$4i as FIRST_KEY_INDEX, transformArguments$79 as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$4h = 1;
declare const IS_READ_ONLY$2n = true;
declare function transformArguments$78(key: RedisCommandArgument$5, member: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;

declare namespace ZMSCORE {
  export { FIRST_KEY_INDEX$4h as FIRST_KEY_INDEX, IS_READ_ONLY$2n as IS_READ_ONLY, transformArguments$78 as transformArguments, transformNumberInfinityNullArrayReply as transformReply };
}

declare const FIRST_KEY_INDEX$4g = 2;
declare function transformArguments$77(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, side: SortedSetSide, options?: ZMPopOptions): RedisCommandArguments$5;
type ZMPopRawReply = null | [
    key: string,
    elements: Array<[RedisCommandArgument$5, RedisCommandArgument$5]>
];
type ZMPopReply = null | {
    key: string;
    elements: Array<ZMember>;
};
declare function transformReply$5Y(reply: ZMPopRawReply): ZMPopReply;

declare namespace ZMPOP {
  export { FIRST_KEY_INDEX$4g as FIRST_KEY_INDEX, transformArguments$77 as transformArguments, transformReply$5Y as transformReply };
}

declare const FIRST_KEY_INDEX$4f = 1;
declare const IS_READ_ONLY$2m = true;
declare function transformArguments$76(key: RedisCommandArgument$5, min: RedisCommandArgument$5, max: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5X(): number;

declare namespace ZLEXCOUNT {
  export { FIRST_KEY_INDEX$4f as FIRST_KEY_INDEX, IS_READ_ONLY$2m as IS_READ_ONLY, transformArguments$76 as transformArguments, transformReply$5X as transformReply };
}

declare const FIRST_KEY_INDEX$4e = 1;
interface ZInterStoreOptions {
    WEIGHTS?: Array<number>;
    AGGREGATE?: 'SUM' | 'MIN' | 'MAX';
}
declare function transformArguments$75(destination: RedisCommandArgument$5, keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5, options?: ZInterStoreOptions): RedisCommandArguments$5;
declare function transformReply$5W(): number;

declare namespace ZINTERSTORE {
  export { FIRST_KEY_INDEX$4e as FIRST_KEY_INDEX, transformArguments$75 as transformArguments, transformReply$5W as transformReply };
}

declare const FIRST_KEY_INDEX$4d = 2;
declare const IS_READ_ONLY$2l = true;
declare function transformArguments$74(keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5, limit?: number): RedisCommandArguments$5;
declare function transformReply$5V(): number;

declare namespace ZINTERCARD {
  export { FIRST_KEY_INDEX$4d as FIRST_KEY_INDEX, IS_READ_ONLY$2l as IS_READ_ONLY, transformArguments$74 as transformArguments, transformReply$5V as transformReply };
}

declare const FIRST_KEY_INDEX$4c = 2;
declare const IS_READ_ONLY$2k = true;
interface ZInterOptions {
    WEIGHTS?: Array<number>;
    AGGREGATE?: 'SUM' | 'MIN' | 'MAX';
}
declare function transformArguments$73(keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5, options?: ZInterOptions): RedisCommandArguments$5;
declare function transformReply$5U(): Array<RedisCommandArgument$5>;

declare namespace ZINTER {
  export { FIRST_KEY_INDEX$4c as FIRST_KEY_INDEX, IS_READ_ONLY$2k as IS_READ_ONLY, transformArguments$73 as transformArguments, transformReply$5U as transformReply };
}

declare function transformArguments$72(...args: Parameters<typeof transformArguments$73>): RedisCommandArguments$5;

declare namespace ZINTER_WITHSCORES {
  export { FIRST_KEY_INDEX$4c as FIRST_KEY_INDEX, IS_READ_ONLY$2k as IS_READ_ONLY, transformArguments$72 as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$4b = 1;
declare function transformArguments$71(key: RedisCommandArgument$5, increment: number, member: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace ZINCRBY {
  export { FIRST_KEY_INDEX$4b as FIRST_KEY_INDEX, transformArguments$71 as transformArguments, transformNumberInfinityReply as transformReply };
}

declare const FIRST_KEY_INDEX$4a = 1;
declare function transformArguments$70(destination: RedisCommandArgument$5, keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5T(): number;

declare namespace ZDIFFSTORE {
  export { FIRST_KEY_INDEX$4a as FIRST_KEY_INDEX, transformArguments$70 as transformArguments, transformReply$5T as transformReply };
}

declare const FIRST_KEY_INDEX$49 = 2;
declare const IS_READ_ONLY$2j = true;
declare function transformArguments$6$(keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5S(): Array<RedisCommandArgument$5>;

declare namespace ZDIFF {
  export { FIRST_KEY_INDEX$49 as FIRST_KEY_INDEX, IS_READ_ONLY$2j as IS_READ_ONLY, transformArguments$6$ as transformArguments, transformReply$5S as transformReply };
}

declare function transformArguments$6_(...args: Parameters<typeof transformArguments$6$>): RedisCommandArguments$5;

declare namespace ZDIFF_WITHSCORES {
  export { FIRST_KEY_INDEX$49 as FIRST_KEY_INDEX, IS_READ_ONLY$2j as IS_READ_ONLY, transformArguments$6_ as transformArguments, transformSortedSetWithScoresReply as transformReply };
}

declare const FIRST_KEY_INDEX$48 = 1;
declare const IS_READ_ONLY$2i = true;
declare function transformArguments$6Z(key: RedisCommandArgument$5, min: RedisCommandArgument$5 | number, max: RedisCommandArgument$5 | number): RedisCommandArguments$5;
declare function transformReply$5R(): number;

declare namespace ZCOUNT {
  export { FIRST_KEY_INDEX$48 as FIRST_KEY_INDEX, IS_READ_ONLY$2i as IS_READ_ONLY, transformArguments$6Z as transformArguments, transformReply$5R as transformReply };
}

declare const FIRST_KEY_INDEX$47 = 1;
declare const IS_READ_ONLY$2h = true;
declare function transformArguments$6Y(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5Q(): number;

declare namespace ZCARD {
  export { FIRST_KEY_INDEX$47 as FIRST_KEY_INDEX, IS_READ_ONLY$2h as IS_READ_ONLY, transformArguments$6Y as transformArguments, transformReply$5Q as transformReply };
}

declare const FIRST_KEY_INDEX$46 = 1;
interface NX$2 {
    NX?: true;
}
interface XX$2 {
    XX?: true;
}
interface LT {
    LT?: true;
}
interface GT {
    GT?: true;
}
interface CH {
    CH?: true;
}
interface INCR$1 {
    INCR?: true;
}
type ZAddOptions = (NX$2 | (XX$2 & LT & GT)) & CH & INCR$1;
declare function transformArguments$6X(key: RedisCommandArgument$5, members: ZMember | Array<ZMember>, options?: ZAddOptions): RedisCommandArguments$5;

declare namespace ZADD {
  export { FIRST_KEY_INDEX$46 as FIRST_KEY_INDEX, transformArguments$6X as transformArguments, transformNumberInfinityReply as transformReply };
}

declare const FIRST_KEY_INDEX$45 = 1;
interface XTrimOptions {
    strategyModifier?: '=' | '~';
    LIMIT?: number;
}
declare function transformArguments$6W(key: RedisCommandArgument$5, strategy: 'MAXLEN' | 'MINID', threshold: number, options?: XTrimOptions): RedisCommandArguments$5;
declare function transformReply$5P(): number;

declare namespace XTRIM {
  export { FIRST_KEY_INDEX$45 as FIRST_KEY_INDEX, transformArguments$6W as transformArguments, transformReply$5P as transformReply };
}

declare const FIRST_KEY_INDEX$44 = 1;
interface XSetIdOptions {
    ENTRIESADDED?: number;
    MAXDELETEDID?: RedisCommandArgument$5;
}
declare function transformArguments$6V(key: RedisCommandArgument$5, lastId: RedisCommandArgument$5, options?: XSetIdOptions): RedisCommandArguments$5;
declare function transformReply$5O(): 'OK';

declare namespace XSETID {
  export { FIRST_KEY_INDEX$44 as FIRST_KEY_INDEX, transformArguments$6V as transformArguments, transformReply$5O as transformReply };
}

declare const FIRST_KEY_INDEX$43 = 1;
declare const IS_READ_ONLY$2g = true;
interface XRangeRevOptions {
    COUNT?: number;
}
declare function transformArguments$6U(key: RedisCommandArgument$5, start: RedisCommandArgument$5, end: RedisCommandArgument$5, options?: XRangeRevOptions): RedisCommandArguments$5;

declare namespace XREVRANGE {
  export { FIRST_KEY_INDEX$43 as FIRST_KEY_INDEX, IS_READ_ONLY$2g as IS_READ_ONLY, transformArguments$6U as transformArguments, transformStreamMessagesReply as transformReply };
}

interface XReadGroupStream {
    key: RedisCommandArgument$5;
    id: RedisCommandArgument$5;
}
interface XReadGroupOptions {
    COUNT?: number;
    BLOCK?: number;
    NOACK?: true;
}
declare const FIRST_KEY_INDEX$42: (_group: RedisCommandArgument$5, _consumer: RedisCommandArgument$5, streams: Array<XReadGroupStream> | XReadGroupStream) => RedisCommandArgument$5;
declare const IS_READ_ONLY$2f = true;
declare function transformArguments$6T(group: RedisCommandArgument$5, consumer: RedisCommandArgument$5, streams: Array<XReadGroupStream> | XReadGroupStream, options?: XReadGroupOptions): RedisCommandArguments$5;

type XREADGROUP_XReadGroupOptions = XReadGroupOptions;
type XREADGROUP_XReadGroupStream = XReadGroupStream;
declare namespace XREADGROUP {
  export { FIRST_KEY_INDEX$42 as FIRST_KEY_INDEX, IS_READ_ONLY$2f as IS_READ_ONLY, type XREADGROUP_XReadGroupOptions as XReadGroupOptions, type XREADGROUP_XReadGroupStream as XReadGroupStream, transformArguments$6T as transformArguments, transformStreamsMessagesReply as transformReply };
}

declare const FIRST_KEY_INDEX$41: (streams: Array<XReadStream> | XReadStream) => RedisCommandArgument$5;
declare const IS_READ_ONLY$2e = true;
interface XReadStream {
    key: RedisCommandArgument$5;
    id: RedisCommandArgument$5;
}
interface XReadOptions {
    COUNT?: number;
    BLOCK?: number;
}
declare function transformArguments$6S(streams: Array<XReadStream> | XReadStream, options?: XReadOptions): RedisCommandArguments$5;

declare namespace XREAD {
  export { FIRST_KEY_INDEX$41 as FIRST_KEY_INDEX, IS_READ_ONLY$2e as IS_READ_ONLY, transformArguments$6S as transformArguments, transformStreamsMessagesReply as transformReply };
}

declare const FIRST_KEY_INDEX$40 = 1;
declare const IS_READ_ONLY$2d = true;
interface XRangeOptions {
    COUNT?: number;
}
declare function transformArguments$6R(key: RedisCommandArgument$5, start: RedisCommandArgument$5, end: RedisCommandArgument$5, options?: XRangeOptions): RedisCommandArguments$5;

declare namespace XRANGE {
  export { FIRST_KEY_INDEX$40 as FIRST_KEY_INDEX, IS_READ_ONLY$2d as IS_READ_ONLY, transformArguments$6R as transformArguments, transformStreamMessagesReply as transformReply };
}

declare const FIRST_KEY_INDEX$3$ = 1;
declare const IS_READ_ONLY$2c = true;
declare function transformArguments$6Q(key: RedisCommandArgument$5, group: RedisCommandArgument$5): RedisCommandArguments$5;
type XPendingRawReply = [
    pending: number,
    firstId: RedisCommandArgument$5 | null,
    lastId: RedisCommandArgument$5 | null,
    consumers: Array<[
        name: RedisCommandArgument$5,
        deliveriesCounter: RedisCommandArgument$5
    ]> | null
];
interface XPendingReply {
    pending: number;
    firstId: RedisCommandArgument$5 | null;
    lastId: RedisCommandArgument$5 | null;
    consumers: Array<{
        name: RedisCommandArgument$5;
        deliveriesCounter: number;
    }> | null;
}
declare function transformReply$5N(reply: XPendingRawReply): XPendingReply;

declare namespace XPENDING {
  export { FIRST_KEY_INDEX$3$ as FIRST_KEY_INDEX, IS_READ_ONLY$2c as IS_READ_ONLY, transformArguments$6Q as transformArguments, transformReply$5N as transformReply };
}

declare const FIRST_KEY_INDEX$3_ = 1;
declare const IS_READ_ONLY$2b = true;
interface XPendingRangeOptions {
    IDLE?: number;
    consumer?: RedisCommandArgument$5;
}
declare function transformArguments$6P(key: RedisCommandArgument$5, group: RedisCommandArgument$5, start: string, end: string, count: number, options?: XPendingRangeOptions): RedisCommandArguments$5;
type XPendingRangeRawReply = Array<[
    id: RedisCommandArgument$5,
    consumer: RedisCommandArgument$5,
    millisecondsSinceLastDelivery: number,
    deliveriesCounter: number
]>;
type XPendingRangeReply = Array<{
    id: RedisCommandArgument$5;
    owner: RedisCommandArgument$5;
    millisecondsSinceLastDelivery: number;
    deliveriesCounter: number;
}>;
declare function transformReply$5M(reply: XPendingRangeRawReply): XPendingRangeReply;

declare namespace XPENDING_RANGE {
  export { FIRST_KEY_INDEX$3_ as FIRST_KEY_INDEX, IS_READ_ONLY$2b as IS_READ_ONLY, transformArguments$6P as transformArguments, transformReply$5M as transformReply };
}

declare const FIRST_KEY_INDEX$3Z = 1;
declare const IS_READ_ONLY$2a = true;
declare function transformArguments$6O(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5L(): number;

declare namespace XLEN {
  export { FIRST_KEY_INDEX$3Z as FIRST_KEY_INDEX, IS_READ_ONLY$2a as IS_READ_ONLY, transformArguments$6O as transformArguments, transformReply$5L as transformReply };
}

declare const FIRST_KEY_INDEX$3Y = 2;
declare const IS_READ_ONLY$29 = true;
declare function transformArguments$6N(key: RedisCommandArgument$5): RedisCommandArguments$5;
interface XInfoStreamReply {
    length: number;
    radixTreeKeys: number;
    radixTreeNodes: number;
    groups: number;
    lastGeneratedId: RedisCommandArgument$5;
    firstEntry: StreamMessageReply | null;
    lastEntry: StreamMessageReply | null;
}
declare function transformReply$5K(rawReply: Array<any>): XInfoStreamReply;

declare namespace XINFO_STREAM {
  export { FIRST_KEY_INDEX$3Y as FIRST_KEY_INDEX, IS_READ_ONLY$29 as IS_READ_ONLY, transformArguments$6N as transformArguments, transformReply$5K as transformReply };
}

declare const FIRST_KEY_INDEX$3X = 2;
declare const IS_READ_ONLY$28 = true;
declare function transformArguments$6M(key: RedisCommandArgument$5): RedisCommandArguments$5;
type XInfoGroupsReply = Array<{
    name: RedisCommandArgument$5;
    consumers: number;
    pending: number;
    lastDeliveredId: RedisCommandArgument$5;
}>;
declare function transformReply$5J(rawReply: Array<any>): XInfoGroupsReply;

declare namespace XINFO_GROUPS {
  export { FIRST_KEY_INDEX$3X as FIRST_KEY_INDEX, IS_READ_ONLY$28 as IS_READ_ONLY, transformArguments$6M as transformArguments, transformReply$5J as transformReply };
}

declare const FIRST_KEY_INDEX$3W = 2;
declare const IS_READ_ONLY$27 = true;
declare function transformArguments$6L(key: RedisCommandArgument$5, group: RedisCommandArgument$5): RedisCommandArguments$5;
type XInfoConsumersReply = Array<{
    name: RedisCommandArgument$5;
    pending: number;
    idle: number;
    inactive: number;
}>;
declare function transformReply$5I(rawReply: Array<any>): XInfoConsumersReply;

declare namespace XINFO_CONSUMERS {
  export { FIRST_KEY_INDEX$3W as FIRST_KEY_INDEX, IS_READ_ONLY$27 as IS_READ_ONLY, transformArguments$6L as transformArguments, transformReply$5I as transformReply };
}

declare const FIRST_KEY_INDEX$3V = 2;
declare function transformArguments$6K(key: RedisCommandArgument$5, group: RedisCommandArgument$5, id: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5H(): RedisCommandArgument$5;

declare namespace XGROUP_SETID {
  export { FIRST_KEY_INDEX$3V as FIRST_KEY_INDEX, transformArguments$6K as transformArguments, transformReply$5H as transformReply };
}

declare const FIRST_KEY_INDEX$3U = 2;
declare function transformArguments$6J(key: RedisCommandArgument$5, group: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace XGROUP_DESTROY {
  export { FIRST_KEY_INDEX$3U as FIRST_KEY_INDEX, transformArguments$6J as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$3T = 2;
declare function transformArguments$6I(key: RedisCommandArgument$5, group: RedisCommandArgument$5, consumer: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5G(): number;

declare namespace XGROUP_DELCONSUMER {
  export { FIRST_KEY_INDEX$3T as FIRST_KEY_INDEX, transformArguments$6I as transformArguments, transformReply$5G as transformReply };
}

declare const FIRST_KEY_INDEX$3S = 2;
declare function transformArguments$6H(key: RedisCommandArgument$5, group: RedisCommandArgument$5, consumer: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace XGROUP_CREATECONSUMER {
  export { FIRST_KEY_INDEX$3S as FIRST_KEY_INDEX, transformArguments$6H as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$3R = 2;
interface XGroupCreateOptions {
    MKSTREAM?: true;
}
declare function transformArguments$6G(key: RedisCommandArgument$5, group: RedisCommandArgument$5, id: RedisCommandArgument$5, options?: XGroupCreateOptions): RedisCommandArguments$5;
declare function transformReply$5F(): RedisCommandArgument$5;

declare namespace XGROUP_CREATE {
  export { FIRST_KEY_INDEX$3R as FIRST_KEY_INDEX, transformArguments$6G as transformArguments, transformReply$5F as transformReply };
}

declare const FIRST_KEY_INDEX$3Q = 1;
declare function transformArguments$6F(key: RedisCommandArgument$5, id: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5E(): number;

declare namespace XDEL {
  export { FIRST_KEY_INDEX$3Q as FIRST_KEY_INDEX, transformArguments$6F as transformArguments, transformReply$5E as transformReply };
}

declare const FIRST_KEY_INDEX$3P = 1;
interface XClaimOptions {
    IDLE?: number;
    TIME?: number | Date;
    RETRYCOUNT?: number;
    FORCE?: true;
}
declare function transformArguments$6E(key: RedisCommandArgument$5, group: RedisCommandArgument$5, consumer: RedisCommandArgument$5, minIdleTime: number, id: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, options?: XClaimOptions): RedisCommandArguments$5;

type XCLAIM_XClaimOptions = XClaimOptions;
declare namespace XCLAIM {
  export { FIRST_KEY_INDEX$3P as FIRST_KEY_INDEX, type XCLAIM_XClaimOptions as XClaimOptions, transformArguments$6E as transformArguments, transformStreamMessagesNullReply as transformReply };
}

declare function transformArguments$6D(...args: Parameters<typeof transformArguments$6E>): RedisCommandArguments$5;
declare function transformReply$5D(): Array<RedisCommandArgument$5>;

declare namespace XCLAIM_JUSTID {
  export { FIRST_KEY_INDEX$3P as FIRST_KEY_INDEX, transformArguments$6D as transformArguments, transformReply$5D as transformReply };
}

declare const FIRST_KEY_INDEX$3O = 1;
interface XAutoClaimOptions {
    COUNT?: number;
}
declare function transformArguments$6C(key: RedisCommandArgument$5, group: RedisCommandArgument$5, consumer: RedisCommandArgument$5, minIdleTime: number, start: string, options?: XAutoClaimOptions): RedisCommandArguments$5;
type XAutoClaimRawReply = [RedisCommandArgument$5, Array<any>];
interface XAutoClaimReply {
    nextId: RedisCommandArgument$5;
    messages: StreamMessagesNullReply;
}
declare function transformReply$5C(reply: XAutoClaimRawReply): XAutoClaimReply;

type XAUTOCLAIM_XAutoClaimOptions = XAutoClaimOptions;
declare namespace XAUTOCLAIM {
  export { FIRST_KEY_INDEX$3O as FIRST_KEY_INDEX, type XAUTOCLAIM_XAutoClaimOptions as XAutoClaimOptions, transformArguments$6C as transformArguments, transformReply$5C as transformReply };
}

declare function transformArguments$6B(...args: Parameters<typeof transformArguments$6C>): RedisCommandArguments$5;
type XAutoClaimJustIdRawReply = [RedisCommandArgument$5, Array<RedisCommandArgument$5>];
interface XAutoClaimJustIdReply {
    nextId: RedisCommandArgument$5;
    messages: Array<RedisCommandArgument$5>;
}
declare function transformReply$5B(reply: XAutoClaimJustIdRawReply): XAutoClaimJustIdReply;

declare namespace XAUTOCLAIM_JUSTID {
  export { FIRST_KEY_INDEX$3O as FIRST_KEY_INDEX, transformArguments$6B as transformArguments, transformReply$5B as transformReply };
}

declare const FIRST_KEY_INDEX$3N = 1;
interface XAddOptions {
    NOMKSTREAM?: true;
    TRIM?: {
        strategy?: 'MAXLEN' | 'MINID';
        strategyModifier?: '=' | '~';
        threshold: number;
        limit?: number;
    };
}
declare function transformArguments$6A(key: RedisCommandArgument$5, id: RedisCommandArgument$5, message: Record<string, RedisCommandArgument$5>, options?: XAddOptions): RedisCommandArguments$5;
declare function transformReply$5A(): string;

declare namespace XADD {
  export { FIRST_KEY_INDEX$3N as FIRST_KEY_INDEX, transformArguments$6A as transformArguments, transformReply$5A as transformReply };
}

declare const FIRST_KEY_INDEX$3M = 1;
declare function transformArguments$6z(key: RedisCommandArgument$5, group: RedisCommandArgument$5, id: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5z(): number;

declare namespace XACK {
  export { FIRST_KEY_INDEX$3M as FIRST_KEY_INDEX, transformArguments$6z as transformArguments, transformReply$5z as transformReply };
}

declare const FIRST_KEY_INDEX$3L = 1;
declare function transformArguments$6y(key: string | Array<string>): RedisCommandArguments$5;
declare function transformReply$5y(): string;

declare namespace WATCH {
  export { FIRST_KEY_INDEX$3L as FIRST_KEY_INDEX, transformArguments$6y as transformArguments, transformReply$5y as transformReply };
}

declare const FIRST_KEY_INDEX$3K = 1;
declare function transformArguments$6x(key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5x(): number;

declare namespace UNLINK {
  export { FIRST_KEY_INDEX$3K as FIRST_KEY_INDEX, transformArguments$6x as transformArguments, transformReply$5x as transformReply };
}

declare const FIRST_KEY_INDEX$3J = 1;
declare const IS_READ_ONLY$26 = true;
declare function transformArguments$6w(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5w(): RedisCommandArgument$5;

declare namespace TYPE {
  export { FIRST_KEY_INDEX$3J as FIRST_KEY_INDEX, IS_READ_ONLY$26 as IS_READ_ONLY, transformArguments$6w as transformArguments, transformReply$5w as transformReply };
}

declare const FIRST_KEY_INDEX$3I = 1;
declare const IS_READ_ONLY$25 = true;
declare function transformArguments$6v(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5v(): number;

declare namespace TTL {
  export { FIRST_KEY_INDEX$3I as FIRST_KEY_INDEX, IS_READ_ONLY$25 as IS_READ_ONLY, transformArguments$6v as transformArguments, transformReply$5v as transformReply };
}

declare const FIRST_KEY_INDEX$3H = 1;
declare function transformArguments$6u(key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5u(): number;

declare namespace TOUCH {
  export { FIRST_KEY_INDEX$3H as FIRST_KEY_INDEX, transformArguments$6u as transformArguments, transformReply$5u as transformReply };
}

declare const FIRST_KEY_INDEX$3G = 1;
declare function transformArguments$6t(destination: RedisCommandArgument$5, keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5t(): number;

declare namespace SUNIONSTORE {
  export { FIRST_KEY_INDEX$3G as FIRST_KEY_INDEX, transformArguments$6t as transformArguments, transformReply$5t as transformReply };
}

declare const FIRST_KEY_INDEX$3F = 1;
declare const IS_READ_ONLY$24 = true;
declare function transformArguments$6s(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5s(): Array<RedisCommandArgument$5>;

declare namespace SUNION {
  export { FIRST_KEY_INDEX$3F as FIRST_KEY_INDEX, IS_READ_ONLY$24 as IS_READ_ONLY, transformArguments$6s as transformArguments, transformReply$5s as transformReply };
}

declare const FIRST_KEY_INDEX$3E = 1;
declare const IS_READ_ONLY$23 = true;
declare function transformArguments$6r(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5r(): number;

declare namespace STRLEN {
  export { FIRST_KEY_INDEX$3E as FIRST_KEY_INDEX, IS_READ_ONLY$23 as IS_READ_ONLY, transformArguments$6r as transformArguments, transformReply$5r as transformReply };
}

declare const FIRST_KEY_INDEX$3D = 1;
declare const IS_READ_ONLY$22 = true;
declare function transformArguments$6q(key: RedisCommandArgument$5, cursor: number, options?: ScanOptions): RedisCommandArguments$5;
type SScanRawReply = [string, Array<RedisCommandArgument$5>];
interface SScanReply {
    cursor: number;
    members: Array<RedisCommandArgument$5>;
}
declare function transformReply$5q([cursor, members]: SScanRawReply): SScanReply;

declare namespace SSCAN {
  export { FIRST_KEY_INDEX$3D as FIRST_KEY_INDEX, IS_READ_ONLY$22 as IS_READ_ONLY, transformArguments$6q as transformArguments, transformReply$5q as transformReply };
}

declare const FIRST_KEY_INDEX$3C = 1;
declare function transformArguments$6p(key: RedisCommandArgument$5, members: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5p(): number;

declare namespace SREM {
  export { FIRST_KEY_INDEX$3C as FIRST_KEY_INDEX, transformArguments$6p as transformArguments, transformReply$5p as transformReply };
}

declare const FIRST_KEY_INDEX$3B = 1;
declare function transformArguments$6o(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5o(): RedisCommandArgument$5 | null;

declare namespace SRANDMEMBER {
  export { FIRST_KEY_INDEX$3B as FIRST_KEY_INDEX, transformArguments$6o as transformArguments, transformReply$5o as transformReply };
}

declare function transformArguments$6n(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;
declare function transformReply$5n(): Array<RedisCommandArgument$5>;

declare namespace SRANDMEMBER_COUNT {
  export { FIRST_KEY_INDEX$3B as FIRST_KEY_INDEX, transformArguments$6n as transformArguments, transformReply$5n as transformReply };
}

declare const IS_READ_ONLY$21 = true;
declare const FIRST_KEY_INDEX$3A = 1;
declare function transformArguments$6m(channel: RedisCommandArgument$5, message: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5m(): number;

declare namespace SPUBLISH {
  export { FIRST_KEY_INDEX$3A as FIRST_KEY_INDEX, IS_READ_ONLY$21 as IS_READ_ONLY, transformArguments$6m as transformArguments, transformReply$5m as transformReply };
}

declare const FIRST_KEY_INDEX$3z = 1;
declare function transformArguments$6l(key: RedisCommandArgument$5, count?: number): RedisCommandArguments$5;
declare function transformReply$5l(): Array<RedisCommandArgument$5>;

declare namespace SPOP {
  export { FIRST_KEY_INDEX$3z as FIRST_KEY_INDEX, transformArguments$6l as transformArguments, transformReply$5l as transformReply };
}

declare const FIRST_KEY_INDEX$3y = 1;
declare function transformArguments$6k(key: string, options?: SortOptions): RedisCommandArguments$5;
declare function transformReply$5k(): Array<string>;

declare namespace SORT {
  export { FIRST_KEY_INDEX$3y as FIRST_KEY_INDEX, transformArguments$6k as transformArguments, transformReply$5k as transformReply };
}

declare const FIRST_KEY_INDEX$3x = 1;
declare function transformArguments$6j(source: string, destination: string, options?: SortOptions): RedisCommandArguments$5;
declare function transformReply$5j(): number;

declare namespace SORT_STORE {
  export { FIRST_KEY_INDEX$3x as FIRST_KEY_INDEX, transformArguments$6j as transformArguments, transformReply$5j as transformReply };
}

declare const FIRST_KEY_INDEX$3w = 1;
declare const IS_READ_ONLY$20 = true;
declare function transformArguments$6i(key: string, options?: SortOptions): RedisCommandArguments$5;
declare function transformReply$5i(): Array<string>;

declare namespace SORT_RO {
  export { FIRST_KEY_INDEX$3w as FIRST_KEY_INDEX, IS_READ_ONLY$20 as IS_READ_ONLY, transformArguments$6i as transformArguments, transformReply$5i as transformReply };
}

declare const FIRST_KEY_INDEX$3v = 1;
declare function transformArguments$6h(source: RedisCommandArgument$5, destination: RedisCommandArgument$5, member: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace SMOVE {
  export { FIRST_KEY_INDEX$3v as FIRST_KEY_INDEX, transformArguments$6h as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$3u = 1;
declare function transformArguments$6g(key: RedisCommandArgument$5, members: Array<RedisCommandArgument$5>): RedisCommandArguments$5;

declare namespace SMISMEMBER {
  export { FIRST_KEY_INDEX$3u as FIRST_KEY_INDEX, transformArguments$6g as transformArguments, transformBooleanArrayReply$1 as transformReply };
}

declare const FIRST_KEY_INDEX$3t = 1;
declare function transformArguments$6f(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5h(): Array<RedisCommandArgument$5>;

declare namespace SMEMBERS {
  export { FIRST_KEY_INDEX$3t as FIRST_KEY_INDEX, transformArguments$6f as transformArguments, transformReply$5h as transformReply };
}

declare const FIRST_KEY_INDEX$3s = 1;
declare function transformArguments$6e(key: RedisCommandArgument$5, member: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace SISMEMBER {
  export { FIRST_KEY_INDEX$3s as FIRST_KEY_INDEX, transformArguments$6e as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$3r = 1;
declare function transformArguments$6d(key: RedisCommandArgument$5, offset: number, value: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5g(): number;

declare namespace SETRANGE {
  export { FIRST_KEY_INDEX$3r as FIRST_KEY_INDEX, transformArguments$6d as transformArguments, transformReply$5g as transformReply };
}

declare const FIRST_KEY_INDEX$3q = 1;
declare function transformArguments$6c(key: RedisCommandArgument$5, value: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace SETNX {
  export { FIRST_KEY_INDEX$3q as FIRST_KEY_INDEX, transformArguments$6c as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$3p = 1;
declare function transformArguments$6b(key: RedisCommandArgument$5, seconds: number, value: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$5f(): RedisCommandArgument$5;

declare namespace SETEX {
  export { FIRST_KEY_INDEX$3p as FIRST_KEY_INDEX, transformArguments$6b as transformArguments, transformReply$5f as transformReply };
}

declare const FIRST_KEY_INDEX$3o = 1;
declare function transformArguments$6a(key: RedisCommandArgument$5, offset: number, value: BitValue): RedisCommandArguments$5;
declare function transformReply$5e(): BitValue;

declare namespace SETBIT {
  export { FIRST_KEY_INDEX$3o as FIRST_KEY_INDEX, transformArguments$6a as transformArguments, transformReply$5e as transformReply };
}

declare const FIRST_KEY_INDEX$3n = 1;
type MaximumOneOf<T, K extends keyof T = keyof T> = K extends keyof T ? {
    [P in K]?: T[K];
} & Partial<Record<Exclude<keyof T, K>, never>> : never;
type SetTTL = MaximumOneOf<{
    EX: number;
    PX: number;
    EXAT: number;
    PXAT: number;
    KEEPTTL: true;
}>;
type SetGuards$1 = MaximumOneOf<{
    NX: true;
    XX: true;
}>;
interface SetCommonOptions {
    GET?: true;
}
type SetOptions = SetTTL & SetGuards$1 & SetCommonOptions;
declare function transformArguments$69(key: RedisCommandArgument$5, value: RedisCommandArgument$5 | number, options?: SetOptions): RedisCommandArguments$5;
declare function transformReply$5d(): RedisCommandArgument$5 | null;

type SET_SetOptions = SetOptions;
declare namespace SET {
  export { FIRST_KEY_INDEX$3n as FIRST_KEY_INDEX, type SET_SetOptions as SetOptions, transformArguments$69 as transformArguments, transformReply$5d as transformReply };
}

declare const FIRST_KEY_INDEX$3m = 1;
declare function transformArguments$68(destination: RedisCommandArgument$5, keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5c(): Array<RedisCommandArgument$5>;

declare namespace SINTERSTORE {
  export { FIRST_KEY_INDEX$3m as FIRST_KEY_INDEX, transformArguments$68 as transformArguments, transformReply$5c as transformReply };
}

declare const FIRST_KEY_INDEX$3l = 2;
declare const IS_READ_ONLY$1$ = true;
declare function transformArguments$67(keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5, limit?: number): RedisCommandArguments$5;
declare function transformReply$5b(): number;

declare namespace SINTERCARD {
  export { FIRST_KEY_INDEX$3l as FIRST_KEY_INDEX, IS_READ_ONLY$1$ as IS_READ_ONLY, transformArguments$67 as transformArguments, transformReply$5b as transformReply };
}

declare const FIRST_KEY_INDEX$3k = 1;
declare const IS_READ_ONLY$1_ = true;
declare function transformArguments$66(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$5a(): Array<RedisCommandArgument$5>;

declare namespace SINTER {
  export { FIRST_KEY_INDEX$3k as FIRST_KEY_INDEX, IS_READ_ONLY$1_ as IS_READ_ONLY, transformArguments$66 as transformArguments, transformReply$5a as transformReply };
}

declare const FIRST_KEY_INDEX$3j = 1;
declare function transformArguments$65(destination: RedisCommandArgument$5, keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$59(): number;

declare namespace SDIFFSTORE {
  export { FIRST_KEY_INDEX$3j as FIRST_KEY_INDEX, transformArguments$65 as transformArguments, transformReply$59 as transformReply };
}

declare const FIRST_KEY_INDEX$3i = 1;
declare const IS_READ_ONLY$1Z = true;
declare function transformArguments$64(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$58(): Array<RedisCommandArgument$5>;

declare namespace SDIFF {
  export { FIRST_KEY_INDEX$3i as FIRST_KEY_INDEX, IS_READ_ONLY$1Z as IS_READ_ONLY, transformArguments$64 as transformArguments, transformReply$58 as transformReply };
}

declare const FIRST_KEY_INDEX$3h = 1;
declare function transformArguments$63(key: string): Array<string>;
declare function transformReply$57(): number;

declare namespace SCARD {
  export { FIRST_KEY_INDEX$3h as FIRST_KEY_INDEX, transformArguments$63 as transformArguments, transformReply$57 as transformReply };
}

declare const FIRST_KEY_INDEX$3g = 1;
declare function transformArguments$62(key: RedisCommandArgument$5, members: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$56(): number;

declare namespace SADD {
  export { FIRST_KEY_INDEX$3g as FIRST_KEY_INDEX, transformArguments$62 as transformArguments, transformReply$56 as transformReply };
}

declare const FIRST_KEY_INDEX$3f = 1;
declare function transformArguments$61(key: RedisCommandArgument$5, element: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$55(): number;

declare namespace RPUSHX {
  export { FIRST_KEY_INDEX$3f as FIRST_KEY_INDEX, transformArguments$61 as transformArguments, transformReply$55 as transformReply };
}

declare const FIRST_KEY_INDEX$3e = 1;
declare function transformArguments$60(key: RedisCommandArgument$5, element: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$54(): number;

declare namespace RPUSH {
  export { FIRST_KEY_INDEX$3e as FIRST_KEY_INDEX, transformArguments$60 as transformArguments, transformReply$54 as transformReply };
}

declare const FIRST_KEY_INDEX$3d = 1;
declare function transformArguments$5$(source: RedisCommandArgument$5, destination: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$53(): RedisCommandArgument$5 | null;

declare namespace RPOPLPUSH {
  export { FIRST_KEY_INDEX$3d as FIRST_KEY_INDEX, transformArguments$5$ as transformArguments, transformReply$53 as transformReply };
}

declare const FIRST_KEY_INDEX$3c = 1;
declare function transformArguments$5_(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$52(): RedisCommandArgument$5 | null;

declare namespace RPOP {
  export { FIRST_KEY_INDEX$3c as FIRST_KEY_INDEX, transformArguments$5_ as transformArguments, transformReply$52 as transformReply };
}

declare const FIRST_KEY_INDEX$3b = 1;
declare function transformArguments$5Z(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;
declare function transformReply$51(): Array<RedisCommandArgument$5> | null;

declare namespace RPOP_COUNT {
  export { FIRST_KEY_INDEX$3b as FIRST_KEY_INDEX, transformArguments$5Z as transformArguments, transformReply$51 as transformReply };
}

declare const FIRST_KEY_INDEX$3a = 1;
interface RestoreOptions {
    REPLACE?: true;
    ABSTTL?: true;
    IDLETIME?: number;
    FREQ?: number;
}
declare function transformArguments$5Y(key: RedisCommandArgument$5, ttl: number, serializedValue: RedisCommandArgument$5, options?: RestoreOptions): RedisCommandArguments$5;
declare function transformReply$50(): 'OK';

declare namespace RESTORE {
  export { FIRST_KEY_INDEX$3a as FIRST_KEY_INDEX, transformArguments$5Y as transformArguments, transformReply$50 as transformReply };
}

declare const FIRST_KEY_INDEX$39 = 1;
declare function transformArguments$5X(key: RedisCommandArgument$5, newKey: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace RENAMENX {
  export { FIRST_KEY_INDEX$39 as FIRST_KEY_INDEX, transformArguments$5X as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$38 = 1;
declare function transformArguments$5W(key: RedisCommandArgument$5, newKey: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4$(): RedisCommandArgument$5;

declare namespace RENAME {
  export { FIRST_KEY_INDEX$38 as FIRST_KEY_INDEX, transformArguments$5W as transformArguments, transformReply$4$ as transformReply };
}

declare const IS_READ_ONLY$1Y = true;
declare function transformArguments$5V(channel: RedisCommandArgument$5, message: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4_(): number;

declare namespace PUBLISH {
  export { IS_READ_ONLY$1Y as IS_READ_ONLY, transformArguments$5V as transformArguments, transformReply$4_ as transformReply };
}

declare const FIRST_KEY_INDEX$37 = 1;
declare const IS_READ_ONLY$1X = true;
declare function transformArguments$5U(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4Z(): number;

declare namespace PTTL {
  export { FIRST_KEY_INDEX$37 as FIRST_KEY_INDEX, IS_READ_ONLY$1X as IS_READ_ONLY, transformArguments$5U as transformArguments, transformReply$4Z as transformReply };
}

declare const FIRST_KEY_INDEX$36 = 1;
declare function transformArguments$5T(key: RedisCommandArgument$5, milliseconds: number, value: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4Y(): RedisCommandArgument$5;

declare namespace PSETEX {
  export { FIRST_KEY_INDEX$36 as FIRST_KEY_INDEX, transformArguments$5T as transformArguments, transformReply$4Y as transformReply };
}

declare const FIRST_KEY_INDEX$35 = 1;
declare function transformArguments$5S(destination: string, source: string | Array<string>): RedisCommandArguments$5;
declare function transformReply$4X(): string;

declare namespace PFMERGE {
  export { FIRST_KEY_INDEX$35 as FIRST_KEY_INDEX, transformArguments$5S as transformArguments, transformReply$4X as transformReply };
}

declare const FIRST_KEY_INDEX$34 = 1;
declare function transformArguments$5R(key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4W(): number;

declare namespace PFCOUNT {
  export { FIRST_KEY_INDEX$34 as FIRST_KEY_INDEX, transformArguments$5R as transformArguments, transformReply$4W as transformReply };
}

declare const FIRST_KEY_INDEX$33 = 1;
declare function transformArguments$5Q(key: RedisCommandArgument$5, element: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;

declare namespace PFADD {
  export { FIRST_KEY_INDEX$33 as FIRST_KEY_INDEX, transformArguments$5Q as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$32 = 1;
declare function transformArguments$5P(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4V(): number;

declare namespace PEXPIRETIME {
  export { FIRST_KEY_INDEX$32 as FIRST_KEY_INDEX, transformArguments$5P as transformArguments, transformReply$4V as transformReply };
}

declare const FIRST_KEY_INDEX$31 = 1;
declare function transformArguments$5O(key: RedisCommandArgument$5, millisecondsTimestamp: number | Date, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;

declare namespace PEXPIREAT {
  export { FIRST_KEY_INDEX$31 as FIRST_KEY_INDEX, transformArguments$5O as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$30 = 1;
declare function transformArguments$5N(key: RedisCommandArgument$5, milliseconds: number, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;

declare namespace PEXPIRE {
  export { FIRST_KEY_INDEX$30 as FIRST_KEY_INDEX, transformArguments$5N as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$2$ = 1;
declare function transformArguments$5M(key: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace PERSIST {
  export { FIRST_KEY_INDEX$2$ as FIRST_KEY_INDEX, transformArguments$5M as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$2_ = 2;
declare const IS_READ_ONLY$1W = true;
declare function transformArguments$5L(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4U(): number | null;

declare namespace OBJECT_REFCOUNT {
  export { FIRST_KEY_INDEX$2_ as FIRST_KEY_INDEX, IS_READ_ONLY$1W as IS_READ_ONLY, transformArguments$5L as transformArguments, transformReply$4U as transformReply };
}

declare const FIRST_KEY_INDEX$2Z = 2;
declare const IS_READ_ONLY$1V = true;
declare function transformArguments$5K(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4T(): number | null;

declare namespace OBJECT_IDLETIME {
  export { FIRST_KEY_INDEX$2Z as FIRST_KEY_INDEX, IS_READ_ONLY$1V as IS_READ_ONLY, transformArguments$5K as transformArguments, transformReply$4T as transformReply };
}

declare const FIRST_KEY_INDEX$2Y = 2;
declare const IS_READ_ONLY$1U = true;
declare function transformArguments$5J(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4S(): number | null;

declare namespace OBJECT_FREQ {
  export { FIRST_KEY_INDEX$2Y as FIRST_KEY_INDEX, IS_READ_ONLY$1U as IS_READ_ONLY, transformArguments$5J as transformArguments, transformReply$4S as transformReply };
}

declare const FIRST_KEY_INDEX$2X = 2;
declare const IS_READ_ONLY$1T = true;
declare function transformArguments$5I(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4R(): string | null;

declare namespace OBJECT_ENCODING {
  export { FIRST_KEY_INDEX$2X as FIRST_KEY_INDEX, IS_READ_ONLY$1T as IS_READ_ONLY, transformArguments$5I as transformArguments, transformReply$4R as transformReply };
}

declare const FIRST_KEY_INDEX$2W = 1;
type MSetArguments = Array<[RedisCommandArgument$5, RedisCommandArgument$5]> | Array<RedisCommandArgument$5> | Record<string, RedisCommandArgument$5>;
declare function transformArguments$5H(toSet: MSetArguments): RedisCommandArguments$5;
declare function transformReply$4Q(): RedisCommandArgument$5;

type MSET_MSetArguments = MSetArguments;
declare namespace MSET {
  export { FIRST_KEY_INDEX$2W as FIRST_KEY_INDEX, type MSET_MSetArguments as MSetArguments, transformArguments$5H as transformArguments, transformReply$4Q as transformReply };
}

declare const FIRST_KEY_INDEX$2V = 1;
declare function transformArguments$5G(toSet: MSetArguments): RedisCommandArguments$5;

declare namespace MSETNX {
  export { FIRST_KEY_INDEX$2V as FIRST_KEY_INDEX, transformArguments$5G as transformArguments, transformBooleanReply$2 as transformReply };
}

interface AuthOptions {
    username?: RedisCommandArgument$5;
    password: RedisCommandArgument$5;
}
declare function transformArguments$5F({ username, password }: AuthOptions): RedisCommandArguments$5;
declare function transformReply$4P(): RedisCommandArgument$5;

type AUTH_AuthOptions = AuthOptions;
declare namespace AUTH {
  export { type AUTH_AuthOptions as AuthOptions, transformArguments$5F as transformArguments, transformReply$4P as transformReply };
}

interface MigrateOptions {
    COPY?: true;
    REPLACE?: true;
    AUTH?: AuthOptions;
}
declare function transformArguments$5E(host: RedisCommandArgument$5, port: number, key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, destinationDb: number, timeout: number, options?: MigrateOptions): RedisCommandArguments$5;
declare function transformReply$4O(): string;

declare namespace MIGRATE {
  export { transformArguments$5E as transformArguments, transformReply$4O as transformReply };
}

declare const FIRST_KEY_INDEX$2U = 1;
declare const IS_READ_ONLY$1S = true;
declare function transformArguments$5D(keys: Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4N(): Array<RedisCommandArgument$5 | null>;

declare namespace MGET {
  export { FIRST_KEY_INDEX$2U as FIRST_KEY_INDEX, IS_READ_ONLY$1S as IS_READ_ONLY, transformArguments$5D as transformArguments, transformReply$4N as transformReply };
}

declare const FIRST_KEY_INDEX$2T = 1;
declare function transformArguments$5C(key: RedisCommandArgument$5, start: number, stop: number): RedisCommandArguments$5;
declare function transformReply$4M(): RedisCommandArgument$5;

declare namespace LTRIM {
  export { FIRST_KEY_INDEX$2T as FIRST_KEY_INDEX, transformArguments$5C as transformArguments, transformReply$4M as transformReply };
}

declare const FIRST_KEY_INDEX$2S = 1;
declare function transformArguments$5B(key: RedisCommandArgument$5, index: number, element: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4L(): RedisCommandArgument$5;

declare namespace LSET {
  export { FIRST_KEY_INDEX$2S as FIRST_KEY_INDEX, transformArguments$5B as transformArguments, transformReply$4L as transformReply };
}

declare const FIRST_KEY_INDEX$2R = 1;
declare function transformArguments$5A(key: RedisCommandArgument$5, count: number, element: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4K(): number;

declare namespace LREM {
  export { FIRST_KEY_INDEX$2R as FIRST_KEY_INDEX, transformArguments$5A as transformArguments, transformReply$4K as transformReply };
}

declare const FIRST_KEY_INDEX$2Q = 1;
declare const IS_READ_ONLY$1R = true;
declare function transformArguments$5z(key: RedisCommandArgument$5, start: number, stop: number): RedisCommandArguments$5;
declare function transformReply$4J(): Array<RedisCommandArgument$5>;

declare namespace LRANGE {
  export { FIRST_KEY_INDEX$2Q as FIRST_KEY_INDEX, IS_READ_ONLY$1R as IS_READ_ONLY, transformArguments$5z as transformArguments, transformReply$4J as transformReply };
}

declare const FIRST_KEY_INDEX$2P = 1;
declare function transformArguments$5y(key: RedisCommandArgument$5, element: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4I(): number;

declare namespace LPUSHX {
  export { FIRST_KEY_INDEX$2P as FIRST_KEY_INDEX, transformArguments$5y as transformArguments, transformReply$4I as transformReply };
}

declare const FIRST_KEY_INDEX$2O = 1;
declare function transformArguments$5x(key: RedisCommandArgument$5, elements: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4H(): number;

declare namespace LPUSH {
  export { FIRST_KEY_INDEX$2O as FIRST_KEY_INDEX, transformArguments$5x as transformArguments, transformReply$4H as transformReply };
}

declare const FIRST_KEY_INDEX$2N = 1;
declare const IS_READ_ONLY$1Q = true;
interface LPosOptions {
    RANK?: number;
    MAXLEN?: number;
}
declare function transformArguments$5w(key: RedisCommandArgument$5, element: RedisCommandArgument$5, options?: LPosOptions): RedisCommandArguments$5;
declare function transformReply$4G(): number | null;

type LPOS_LPosOptions = LPosOptions;
declare namespace LPOS {
  export { FIRST_KEY_INDEX$2N as FIRST_KEY_INDEX, IS_READ_ONLY$1Q as IS_READ_ONLY, type LPOS_LPosOptions as LPosOptions, transformArguments$5w as transformArguments, transformReply$4G as transformReply };
}

declare function transformArguments$5v(key: RedisCommandArgument$5, element: RedisCommandArgument$5, count: number, options?: LPosOptions): RedisCommandArguments$5;
declare function transformReply$4F(): Array<number>;

declare namespace LPOS_COUNT {
  export { FIRST_KEY_INDEX$2N as FIRST_KEY_INDEX, IS_READ_ONLY$1Q as IS_READ_ONLY, transformArguments$5v as transformArguments, transformReply$4F as transformReply };
}

declare const FIRST_KEY_INDEX$2M = 1;
declare function transformArguments$5u(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4E(): RedisCommandArgument$5 | null;

declare namespace LPOP {
  export { FIRST_KEY_INDEX$2M as FIRST_KEY_INDEX, transformArguments$5u as transformArguments, transformReply$4E as transformReply };
}

declare const FIRST_KEY_INDEX$2L = 1;
declare function transformArguments$5t(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;
declare function transformReply$4D(): Array<RedisCommandArgument$5> | null;

declare namespace LPOP_COUNT {
  export { FIRST_KEY_INDEX$2L as FIRST_KEY_INDEX, transformArguments$5t as transformArguments, transformReply$4D as transformReply };
}

declare const FIRST_KEY_INDEX$2K = 2;
declare function transformArguments$5s(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, side: ListSide, options?: LMPopOptions): RedisCommandArguments$5;
declare function transformReply$4C(): null | [
    key: string,
    elements: Array<string>
];

declare namespace LMPOP {
  export { FIRST_KEY_INDEX$2K as FIRST_KEY_INDEX, transformArguments$5s as transformArguments, transformReply$4C as transformReply };
}

declare const FIRST_KEY_INDEX$2J = 1;
declare function transformArguments$5r(source: RedisCommandArgument$5, destination: RedisCommandArgument$5, sourceSide: ListSide, destinationSide: ListSide): RedisCommandArguments$5;
declare function transformReply$4B(): RedisCommandArgument$5 | null;

declare namespace LMOVE {
  export { FIRST_KEY_INDEX$2J as FIRST_KEY_INDEX, transformArguments$5r as transformArguments, transformReply$4B as transformReply };
}

declare const FIRST_KEY_INDEX$2I = 1;
declare const IS_READ_ONLY$1P = true;
declare function transformArguments$5q(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4A(): number;

declare namespace LLEN {
  export { FIRST_KEY_INDEX$2I as FIRST_KEY_INDEX, IS_READ_ONLY$1P as IS_READ_ONLY, transformArguments$5q as transformArguments, transformReply$4A as transformReply };
}

declare const FIRST_KEY_INDEX$2H = 1;
type LInsertPosition = 'BEFORE' | 'AFTER';
declare function transformArguments$5p(key: RedisCommandArgument$5, position: LInsertPosition, pivot: RedisCommandArgument$5, element: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4z(): number;

declare namespace LINSERT {
  export { FIRST_KEY_INDEX$2H as FIRST_KEY_INDEX, transformArguments$5p as transformArguments, transformReply$4z as transformReply };
}

declare const FIRST_KEY_INDEX$2G = 1;
declare const IS_READ_ONLY$1O = true;
declare function transformArguments$5o(key: RedisCommandArgument$5, index: number): RedisCommandArguments$5;
declare function transformReply$4y(): RedisCommandArgument$5 | null;

declare namespace LINDEX {
  export { FIRST_KEY_INDEX$2G as FIRST_KEY_INDEX, IS_READ_ONLY$1O as IS_READ_ONLY, transformArguments$5o as transformArguments, transformReply$4y as transformReply };
}

declare const FIRST_KEY_INDEX$2F = 1;
declare const IS_READ_ONLY$1N = true;
declare function transformArguments$5n(key1: RedisCommandArgument$5, key2: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4x(): string | Buffer;

declare namespace LCS {
  export { FIRST_KEY_INDEX$2F as FIRST_KEY_INDEX, IS_READ_ONLY$1N as IS_READ_ONLY, transformArguments$5n as transformArguments, transformReply$4x as transformReply };
}

declare function transformArguments$5m(key1: RedisCommandArgument$5, key2: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4w(): number;

declare namespace LCS_LEN {
  export { FIRST_KEY_INDEX$2F as FIRST_KEY_INDEX, IS_READ_ONLY$1N as IS_READ_ONLY, transformArguments$5m as transformArguments, transformReply$4w as transformReply };
}

declare function transformArguments$5l(key1: RedisCommandArgument$5, key2: RedisCommandArgument$5): RedisCommandArguments$5;
type RawReply$2 = [
    'matches',
    Array<[
        key1: RawRangeReply,
        key2: RawRangeReply
    ]>,
    'len',
    number
];
interface Reply$2 {
    matches: Array<{
        key1: RangeReply;
        key2: RangeReply;
    }>;
    length: number;
}
declare function transformReply$4v(reply: RawReply$2): Reply$2;

declare namespace LCS_IDX {
  export { FIRST_KEY_INDEX$2F as FIRST_KEY_INDEX, IS_READ_ONLY$1N as IS_READ_ONLY, transformArguments$5l as transformArguments, transformReply$4v as transformReply };
}

declare function transformArguments$5k(key1: RedisCommandArgument$5, key2: RedisCommandArgument$5): RedisCommandArguments$5;
type RawReply$1 = [
    'matches',
    Array<[
        key1: RawRangeReply,
        key2: RawRangeReply,
        length: number
    ]>,
    'len',
    number
];
interface Reply$1 {
    matches: Array<{
        key1: RangeReply;
        key2: RangeReply;
        length: number;
    }>;
    length: number;
}
declare function transformReply$4u(reply: RawReply$1): Reply$1;

declare namespace LCS_IDX_WITHMATCHLEN {
  export { FIRST_KEY_INDEX$2F as FIRST_KEY_INDEX, IS_READ_ONLY$1N as IS_READ_ONLY, transformArguments$5k as transformArguments, transformReply$4u as transformReply };
}

declare const FIRST_KEY_INDEX$2E = 1;
declare function transformArguments$5j(key: RedisCommandArgument$5, increment: number): RedisCommandArguments$5;
declare function transformReply$4t(): RedisCommandArgument$5;

declare namespace INCRBYFLOAT {
  export { FIRST_KEY_INDEX$2E as FIRST_KEY_INDEX, transformArguments$5j as transformArguments, transformReply$4t as transformReply };
}

declare const FIRST_KEY_INDEX$2D = 1;
declare function transformArguments$5i(key: RedisCommandArgument$5, increment: number): RedisCommandArguments$5;
declare function transformReply$4s(): number;

declare namespace INCRBY {
  export { FIRST_KEY_INDEX$2D as FIRST_KEY_INDEX, transformArguments$5i as transformArguments, transformReply$4s as transformReply };
}

declare const FIRST_KEY_INDEX$2C = 1;
declare function transformArguments$5h(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4r(): number;

declare namespace INCR {
  export { FIRST_KEY_INDEX$2C as FIRST_KEY_INDEX, transformArguments$5h as transformArguments, transformReply$4r as transformReply };
}

declare const FIRST_KEY_INDEX$2B = 1;
declare function transformArguments$5g(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4q(): Array<RedisCommandArgument$5>;

declare namespace HVALS {
  export { FIRST_KEY_INDEX$2B as FIRST_KEY_INDEX, transformArguments$5g as transformArguments, transformReply$4q as transformReply };
}

declare const FIRST_KEY_INDEX$2A = 1;
declare const IS_READ_ONLY$1M = true;
declare function transformArguments$5f(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4p(): Array<number> | null;

declare namespace HTTL {
  export { FIRST_KEY_INDEX$2A as FIRST_KEY_INDEX, IS_READ_ONLY$1M as IS_READ_ONLY, transformArguments$5f as transformArguments, transformReply$4p as transformReply };
}

declare const FIRST_KEY_INDEX$2z = 1;
declare function transformArguments$5e(key: RedisCommandArgument$5, field: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4o(): number;

declare namespace HSTRLEN {
  export { FIRST_KEY_INDEX$2z as FIRST_KEY_INDEX, transformArguments$5e as transformArguments, transformReply$4o as transformReply };
}

declare const FIRST_KEY_INDEX$2y = 1;
declare function transformArguments$5d(key: RedisCommandArgument$5, field: RedisCommandArgument$5, value: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace HSETNX {
  export { FIRST_KEY_INDEX$2y as FIRST_KEY_INDEX, transformArguments$5d as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$2x = 1;
type Types = RedisCommandArgument$5 | number;
type HSETObject = Record<string | number, Types>;
type HSETMap = Map<Types, Types>;
type HSETTuples = Array<[Types, Types]> | Array<Types>;
type GenericArguments = [key: RedisCommandArgument$5];
type SingleFieldArguments = [...generic: GenericArguments, field: Types, value: Types];
type MultipleFieldsArguments = [...generic: GenericArguments, value: HSETObject | HSETMap | HSETTuples];
declare function transformArguments$5c(...[key, value, fieldValue]: SingleFieldArguments | MultipleFieldsArguments): RedisCommandArguments$5;
declare function transformReply$4n(): number;

declare namespace HSET {
  export { FIRST_KEY_INDEX$2x as FIRST_KEY_INDEX, transformArguments$5c as transformArguments, transformReply$4n as transformReply };
}

declare const FIRST_KEY_INDEX$2w = 1;
declare const IS_READ_ONLY$1L = true;
declare function transformArguments$5b(key: RedisCommandArgument$5, cursor: number, options?: ScanOptions): RedisCommandArguments$5;
type HScanRawReply = [RedisCommandArgument$5, Array<RedisCommandArgument$5>];
interface HScanTuple {
    field: RedisCommandArgument$5;
    value: RedisCommandArgument$5;
}
interface HScanReply {
    cursor: number;
    tuples: Array<HScanTuple>;
}
declare function transformReply$4m([cursor, rawTuples]: HScanRawReply): HScanReply;

type HSCAN_HScanRawReply = HScanRawReply;
type HSCAN_HScanTuple = HScanTuple;
declare namespace HSCAN {
  export { FIRST_KEY_INDEX$2w as FIRST_KEY_INDEX, type HSCAN_HScanRawReply as HScanRawReply, type HSCAN_HScanTuple as HScanTuple, IS_READ_ONLY$1L as IS_READ_ONLY, transformArguments$5b as transformArguments, transformReply$4m as transformReply };
}

declare function transformArguments$5a(key: RedisCommandArgument$5, cursor: number, options?: ScanOptions): RedisCommandArguments$5;
interface HScanNoValuesReply {
    cursor: number;
    keys: Array<RedisCommandArgument$5>;
}
declare function transformReply$4l([cursor, rawData]: HScanRawReply): HScanNoValuesReply;

declare namespace HSCAN_NOVALUES {
  export { FIRST_KEY_INDEX$2w as FIRST_KEY_INDEX, IS_READ_ONLY$1L as IS_READ_ONLY, transformArguments$5a as transformArguments, transformReply$4l as transformReply };
}

declare const FIRST_KEY_INDEX$2v = 1;
declare const IS_READ_ONLY$1K = true;
declare function transformArguments$59(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4k(): RedisCommandArgument$5 | null;

declare namespace HRANDFIELD {
  export { FIRST_KEY_INDEX$2v as FIRST_KEY_INDEX, IS_READ_ONLY$1K as IS_READ_ONLY, transformArguments$59 as transformArguments, transformReply$4k as transformReply };
}

declare function transformArguments$58(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;
declare function transformReply$4j(): Array<RedisCommandArgument$5>;

declare namespace HRANDFIELD_COUNT {
  export { FIRST_KEY_INDEX$2v as FIRST_KEY_INDEX, IS_READ_ONLY$1K as IS_READ_ONLY, transformArguments$58 as transformArguments, transformReply$4j as transformReply };
}

declare function transformArguments$57(key: RedisCommandArgument$5, count: number): RedisCommandArguments$5;

declare namespace HRANDFIELD_COUNT_WITHVALUES {
  export { FIRST_KEY_INDEX$2v as FIRST_KEY_INDEX, IS_READ_ONLY$1K as IS_READ_ONLY, transformArguments$57 as transformArguments, transformTuplesReply as transformReply };
}

declare const FIRST_KEY_INDEX$2u = 1;
declare const IS_READ_ONLY$1J = true;
declare function transformArguments$56(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4i(): Array<number> | null;

declare namespace HPTTL {
  export { FIRST_KEY_INDEX$2u as FIRST_KEY_INDEX, IS_READ_ONLY$1J as IS_READ_ONLY, transformArguments$56 as transformArguments, transformReply$4i as transformReply };
}

declare const FIRST_KEY_INDEX$2t = 1;
declare const IS_READ_ONLY$1I = true;
declare function transformArguments$55(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4h(): Array<number> | null;

declare namespace HPEXPIRETIME {
  export { FIRST_KEY_INDEX$2t as FIRST_KEY_INDEX, IS_READ_ONLY$1I as IS_READ_ONLY, transformArguments$55 as transformArguments, transformReply$4h as transformReply };
}

/**
 * @readonly
 * @enum {number}
 */
declare const HASH_EXPIRATION: {
    /** @property {number} */
    /** The field does not exist */
    readonly FIELD_NOT_EXISTS: -2;
    /** @property {number} */
    /** Specified NX | XX | GT | LT condition not met */
    readonly CONDITION_NOT_MET: 0;
    /** @property {number} */
    /** Expiration time was set or updated */
    readonly UPDATED: 1;
    /** @property {number} */
    /** Field deleted because the specified expiration time is in the past */
    readonly DELETED: 2;
};
type HashExpiration = typeof HASH_EXPIRATION[keyof typeof HASH_EXPIRATION];
declare const FIRST_KEY_INDEX$2s = 1;
declare function transformArguments$54(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, seconds: number, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;
declare function transformReply$4g(): Array<HashExpiration>;

declare const HEXPIRE_HASH_EXPIRATION: typeof HASH_EXPIRATION;
type HEXPIRE_HashExpiration = HashExpiration;
declare namespace HEXPIRE {
  export { FIRST_KEY_INDEX$2s as FIRST_KEY_INDEX, HEXPIRE_HASH_EXPIRATION as HASH_EXPIRATION, type HEXPIRE_HashExpiration as HashExpiration, transformArguments$54 as transformArguments, transformReply$4g as transformReply };
}

declare const FIRST_KEY_INDEX$2r = 1;
declare const IS_READ_ONLY$1H = true;
declare function transformArguments$53(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, timestamp: number | Date, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;
declare function transformReply$4f(): Array<HashExpiration> | null;

declare namespace HPEXPIREAT {
  export { FIRST_KEY_INDEX$2r as FIRST_KEY_INDEX, IS_READ_ONLY$1H as IS_READ_ONLY, transformArguments$53 as transformArguments, transformReply$4f as transformReply };
}

declare const FIRST_KEY_INDEX$2q = 1;
declare function transformArguments$52(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, ms: number, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;
declare function transformReply$4e(): Array<HashExpiration> | null;

declare namespace HPEXPIRE {
  export { FIRST_KEY_INDEX$2q as FIRST_KEY_INDEX, transformArguments$52 as transformArguments, transformReply$4e as transformReply };
}

declare const FIRST_KEY_INDEX$2p = 1;
declare function transformArguments$51(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4d(): Array<number> | null;

declare namespace HPERSIST {
  export { FIRST_KEY_INDEX$2p as FIRST_KEY_INDEX, transformArguments$51 as transformArguments, transformReply$4d as transformReply };
}

declare const FIRST_KEY_INDEX$2o = 1;
declare const IS_READ_ONLY$1G = true;
declare function transformArguments$50(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$4c(): Array<RedisCommandArgument$5>;

declare namespace HMGET {
  export { FIRST_KEY_INDEX$2o as FIRST_KEY_INDEX, IS_READ_ONLY$1G as IS_READ_ONLY, transformArguments$50 as transformArguments, transformReply$4c as transformReply };
}

declare const FIRST_KEY_INDEX$2n = 1;
declare function transformArguments$4$(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4b(): number;

declare namespace HLEN {
  export { FIRST_KEY_INDEX$2n as FIRST_KEY_INDEX, transformArguments$4$ as transformArguments, transformReply$4b as transformReply };
}

declare const FIRST_KEY_INDEX$2m = 1;
declare function transformArguments$4_(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$4a(): Array<RedisCommandArgument$5>;

declare namespace HKEYS {
  export { FIRST_KEY_INDEX$2m as FIRST_KEY_INDEX, transformArguments$4_ as transformArguments, transformReply$4a as transformReply };
}

declare const FIRST_KEY_INDEX$2l = 1;
declare function transformArguments$4Z(key: RedisCommandArgument$5, field: RedisCommandArgument$5, increment: number): RedisCommandArguments$5;
declare function transformReply$49(): number;

declare namespace HINCRBYFLOAT {
  export { FIRST_KEY_INDEX$2l as FIRST_KEY_INDEX, transformArguments$4Z as transformArguments, transformReply$49 as transformReply };
}

declare const FIRST_KEY_INDEX$2k = 1;
declare function transformArguments$4Y(key: RedisCommandArgument$5, field: RedisCommandArgument$5, increment: number): RedisCommandArguments$5;
declare function transformReply$48(): number;

declare namespace HINCRBY {
  export { FIRST_KEY_INDEX$2k as FIRST_KEY_INDEX, transformArguments$4Y as transformArguments, transformReply$48 as transformReply };
}

declare const FIRST_KEY_INDEX$2j = 1;
declare const IS_READ_ONLY$1F = true;
declare const TRANSFORM_LEGACY_REPLY = true;
declare function transformArguments$4X(key: RedisCommandArgument$5): RedisCommandArguments$5;

declare const HGETALL_TRANSFORM_LEGACY_REPLY: typeof TRANSFORM_LEGACY_REPLY;
declare namespace HGETALL {
  export { FIRST_KEY_INDEX$2j as FIRST_KEY_INDEX, IS_READ_ONLY$1F as IS_READ_ONLY, HGETALL_TRANSFORM_LEGACY_REPLY as TRANSFORM_LEGACY_REPLY, transformArguments$4X as transformArguments, transformTuplesReply as transformReply };
}

declare const FIRST_KEY_INDEX$2i = 1;
declare const IS_READ_ONLY$1E = true;
declare function transformArguments$4W(key: RedisCommandArgument$5, field: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$47(): RedisCommandArgument$5 | undefined;

declare namespace HGET {
  export { FIRST_KEY_INDEX$2i as FIRST_KEY_INDEX, IS_READ_ONLY$1E as IS_READ_ONLY, transformArguments$4W as transformArguments, transformReply$47 as transformReply };
}

declare const HASH_EXPIRATION_TIME: {
    /** @property {number} */
    /** The field does not exist */
    readonly FIELD_NOT_EXISTS: -2;
    /** @property {number} */
    /** The field exists but has no associated expire */
    readonly NO_EXPIRATION: -1;
};
declare const FIRST_KEY_INDEX$2h = 1;
declare const IS_READ_ONLY$1D = true;
declare function transformArguments$4V(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$46(): Array<number>;

declare const HEXPIRETIME_HASH_EXPIRATION_TIME: typeof HASH_EXPIRATION_TIME;
declare namespace HEXPIRETIME {
  export { FIRST_KEY_INDEX$2h as FIRST_KEY_INDEX, HEXPIRETIME_HASH_EXPIRATION_TIME as HASH_EXPIRATION_TIME, IS_READ_ONLY$1D as IS_READ_ONLY, transformArguments$4V as transformArguments, transformReply$46 as transformReply };
}

declare const FIRST_KEY_INDEX$2g = 1;
declare function transformArguments$4U(key: RedisCommandArgument$5, fields: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, timestamp: number | Date, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;
declare function transformReply$45(): Array<HashExpiration>;

declare namespace HEXPIREAT {
  export { FIRST_KEY_INDEX$2g as FIRST_KEY_INDEX, transformArguments$4U as transformArguments, transformReply$45 as transformReply };
}

declare const FIRST_KEY_INDEX$2f = 1;
declare function transformArguments$4T(key: RedisCommandArgument$5, field: RedisCommandArgument$5): RedisCommandArguments$5;

declare namespace HEXISTS {
  export { FIRST_KEY_INDEX$2f as FIRST_KEY_INDEX, transformArguments$4T as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$2e = 1;
declare function transformArguments$4S(key: RedisCommandArgument$5, field: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$44(): number;

declare namespace HDEL {
  export { FIRST_KEY_INDEX$2e as FIRST_KEY_INDEX, transformArguments$4S as transformArguments, transformReply$44 as transformReply };
}

declare const FIRST_KEY_INDEX$2d = 1;
declare function transformArguments$4R(key: RedisCommandArgument$5, value: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$43(): RedisCommandArgument$5 | null;

declare namespace GETSET {
  export { FIRST_KEY_INDEX$2d as FIRST_KEY_INDEX, transformArguments$4R as transformArguments, transformReply$43 as transformReply };
}

declare const FIRST_KEY_INDEX$2c = 1;
declare const IS_READ_ONLY$1C = true;
declare function transformArguments$4Q(key: RedisCommandArgument$5, start: number, end: number): RedisCommandArguments$5;
declare function transformReply$42(): RedisCommandArgument$5;

declare namespace GETRANGE {
  export { FIRST_KEY_INDEX$2c as FIRST_KEY_INDEX, IS_READ_ONLY$1C as IS_READ_ONLY, transformArguments$4Q as transformArguments, transformReply$42 as transformReply };
}

declare const FIRST_KEY_INDEX$2b = 1;
type GetExModes = {
    EX: number;
} | {
    PX: number;
} | {
    EXAT: number | Date;
} | {
    PXAT: number | Date;
} | {
    PERSIST: true;
};
declare function transformArguments$4P(key: RedisCommandArgument$5, mode: GetExModes): RedisCommandArguments$5;
declare function transformReply$41(): RedisCommandArgument$5 | null;

declare namespace GETEX {
  export { FIRST_KEY_INDEX$2b as FIRST_KEY_INDEX, transformArguments$4P as transformArguments, transformReply$41 as transformReply };
}

declare const FIRST_KEY_INDEX$2a = 1;
declare function transformArguments$4O(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$40(): RedisCommandArgument$5 | null;

declare namespace GETDEL {
  export { FIRST_KEY_INDEX$2a as FIRST_KEY_INDEX, transformArguments$4O as transformArguments, transformReply$40 as transformReply };
}

declare const FIRST_KEY_INDEX$29 = 1;
declare const IS_READ_ONLY$1B = true;
declare function transformArguments$4N(key: RedisCommandArgument$5, offset: number): RedisCommandArguments$5;
declare function transformReply$3$(): BitValue;

declare namespace GETBIT {
  export { FIRST_KEY_INDEX$29 as FIRST_KEY_INDEX, IS_READ_ONLY$1B as IS_READ_ONLY, transformArguments$4N as transformArguments, transformReply$3$ as transformReply };
}

declare const FIRST_KEY_INDEX$28 = 1;
declare const IS_READ_ONLY$1A = true;
declare function transformArguments$4M(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$3_(): RedisCommandArgument$5 | null;

declare namespace GET {
  export { FIRST_KEY_INDEX$28 as FIRST_KEY_INDEX, IS_READ_ONLY$1A as IS_READ_ONLY, transformArguments$4M as transformArguments, transformReply$3_ as transformReply };
}

declare const FIRST_KEY_INDEX$27 = 1;
declare const IS_READ_ONLY$1z = true;
declare function transformArguments$4L(key: RedisCommandArgument$5, from: GeoSearchFrom, by: GeoSearchBy, options?: GeoSearchOptions): RedisCommandArguments$5;
declare function transformReply$3Z(): Array<RedisCommandArgument$5>;

declare namespace GEOSEARCH {
  export { FIRST_KEY_INDEX$27 as FIRST_KEY_INDEX, IS_READ_ONLY$1z as IS_READ_ONLY, transformArguments$4L as transformArguments, transformReply$3Z as transformReply };
}

interface GeoSearchStoreOptions extends GeoSearchOptions {
    STOREDIST?: true;
}
declare function transformArguments$4K(destination: RedisCommandArgument$5, source: RedisCommandArgument$5, from: GeoSearchFrom, by: GeoSearchBy, options?: GeoSearchStoreOptions): RedisCommandArguments$5;
declare function transformReply$3Y(reply: number): number;

declare namespace GEOSEARCHSTORE {
  export { FIRST_KEY_INDEX$27 as FIRST_KEY_INDEX, IS_READ_ONLY$1z as IS_READ_ONLY, transformArguments$4K as transformArguments, transformReply$3Y as transformReply };
}

declare function transformArguments$4J(key: RedisCommandArgument$5, from: GeoSearchFrom, by: GeoSearchBy, replyWith: Array<GeoReplyWith$1>, options?: GeoSearchOptions): RedisCommandArguments$5;

declare namespace GEOSEARCH_WITH {
  export { FIRST_KEY_INDEX$27 as FIRST_KEY_INDEX, IS_READ_ONLY$1z as IS_READ_ONLY, transformArguments$4J as transformArguments, transformGeoMembersWithReply as transformReply };
}

declare const FIRST_KEY_INDEX$26 = 1;
declare const IS_READ_ONLY$1y = true;
declare function transformArguments$4I(key: RedisCommandArgument$5, coordinates: GeoCoordinates$1, radius: number, unit: GeoUnits, options?: GeoSearchOptions): RedisCommandArguments$5;
declare function transformReply$3X(): Array<RedisCommandArgument$5>;

declare namespace GEORADIUS {
  export { FIRST_KEY_INDEX$26 as FIRST_KEY_INDEX, IS_READ_ONLY$1y as IS_READ_ONLY, transformArguments$4I as transformArguments, transformReply$3X as transformReply };
}

declare function transformArguments$4H(key: RedisCommandArgument$5, coordinates: GeoCoordinates$1, radius: number, unit: GeoUnits, destination: RedisCommandArgument$5, options?: GeoRadiusStoreOptions): RedisCommandArguments$5;
declare function transformReply$3W(): number;

declare namespace GEORADIUSSTORE {
  export { FIRST_KEY_INDEX$26 as FIRST_KEY_INDEX, IS_READ_ONLY$1y as IS_READ_ONLY, transformArguments$4H as transformArguments, transformReply$3W as transformReply };
}

declare const FIRST_KEY_INDEX$25 = 1;
declare const IS_READ_ONLY$1x = true;
declare function transformArguments$4G(key: RedisCommandArgument$5, member: string, radius: number, unit: GeoUnits, options?: GeoSearchOptions): RedisCommandArguments$5;
declare function transformReply$3V(): Array<RedisCommandArgument$5>;

declare namespace GEORADIUSBYMEMBER {
  export { FIRST_KEY_INDEX$25 as FIRST_KEY_INDEX, IS_READ_ONLY$1x as IS_READ_ONLY, transformArguments$4G as transformArguments, transformReply$3V as transformReply };
}

declare function transformArguments$4F(key: RedisCommandArgument$5, member: string, radius: number, unit: GeoUnits, destination: RedisCommandArgument$5, options?: GeoRadiusStoreOptions): RedisCommandArguments$5;
declare function transformReply$3U(): number;

declare namespace GEORADIUSBYMEMBERSTORE {
  export { FIRST_KEY_INDEX$25 as FIRST_KEY_INDEX, IS_READ_ONLY$1x as IS_READ_ONLY, transformArguments$4F as transformArguments, transformReply$3U as transformReply };
}

declare function transformArguments$4E(key: RedisCommandArgument$5, member: string, radius: number, unit: GeoUnits, replyWith: Array<GeoReplyWith$1>, options?: GeoSearchOptions): RedisCommandArguments$5;

declare namespace GEORADIUSBYMEMBER_WITH {
  export { FIRST_KEY_INDEX$25 as FIRST_KEY_INDEX, IS_READ_ONLY$1x as IS_READ_ONLY, transformArguments$4E as transformArguments, transformGeoMembersWithReply as transformReply };
}

declare const FIRST_KEY_INDEX$24 = 1;
declare const IS_READ_ONLY$1w = true;
declare function transformArguments$4D(key: RedisCommandArgument$5, member: string, radius: number, unit: GeoUnits, options?: GeoSearchOptions): RedisCommandArguments$5;
declare function transformReply$3T(): Array<RedisCommandArgument$5>;

declare namespace GEORADIUSBYMEMBER_RO {
  export { FIRST_KEY_INDEX$24 as FIRST_KEY_INDEX, IS_READ_ONLY$1w as IS_READ_ONLY, transformArguments$4D as transformArguments, transformReply$3T as transformReply };
}

declare function transformArguments$4C(key: RedisCommandArgument$5, member: string, radius: number, unit: GeoUnits, replyWith: Array<GeoReplyWith$1>, options?: GeoSearchOptions): RedisCommandArguments$5;

declare namespace GEORADIUSBYMEMBER_RO_WITH {
  export { FIRST_KEY_INDEX$24 as FIRST_KEY_INDEX, IS_READ_ONLY$1w as IS_READ_ONLY, transformArguments$4C as transformArguments, transformGeoMembersWithReply as transformReply };
}

declare function transformArguments$4B(key: RedisCommandArgument$5, coordinates: GeoCoordinates$1, radius: number, unit: GeoUnits, replyWith: Array<GeoReplyWith$1>, options?: GeoSearchOptions): RedisCommandArguments$5;

declare namespace GEORADIUS_WITH {
  export { FIRST_KEY_INDEX$26 as FIRST_KEY_INDEX, IS_READ_ONLY$1y as IS_READ_ONLY, transformArguments$4B as transformArguments, transformGeoMembersWithReply as transformReply };
}

declare const FIRST_KEY_INDEX$23 = 1;
declare const IS_READ_ONLY$1v = true;
declare function transformArguments$4A(key: RedisCommandArgument$5, coordinates: GeoCoordinates$1, radius: number, unit: GeoUnits, options?: GeoSearchOptions): RedisCommandArguments$5;
declare function transformReply$3S(): Array<RedisCommandArgument$5>;

declare namespace GEORADIUS_RO {
  export { FIRST_KEY_INDEX$23 as FIRST_KEY_INDEX, IS_READ_ONLY$1v as IS_READ_ONLY, transformArguments$4A as transformArguments, transformReply$3S as transformReply };
}

declare function transformArguments$4z(key: RedisCommandArgument$5, coordinates: GeoCoordinates$1, radius: number, unit: GeoUnits, replyWith: Array<GeoReplyWith$1>, options?: GeoSearchOptions): RedisCommandArguments$5;

declare namespace GEORADIUS_RO_WITH {
  export { FIRST_KEY_INDEX$23 as FIRST_KEY_INDEX, IS_READ_ONLY$1v as IS_READ_ONLY, transformArguments$4z as transformArguments, transformGeoMembersWithReply as transformReply };
}

declare const FIRST_KEY_INDEX$22 = 1;
declare const IS_READ_ONLY$1u = true;
declare function transformArguments$4y(key: RedisCommandArgument$5, member: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
type GeoCoordinatesRawReply = Array<[RedisCommandArgument$5, RedisCommandArgument$5] | null>;
interface GeoCoordinates {
    longitude: RedisCommandArgument$5;
    latitude: RedisCommandArgument$5;
}
declare function transformReply$3R(reply: GeoCoordinatesRawReply): Array<GeoCoordinates | null>;

declare namespace GEOPOS {
  export { FIRST_KEY_INDEX$22 as FIRST_KEY_INDEX, IS_READ_ONLY$1u as IS_READ_ONLY, transformArguments$4y as transformArguments, transformReply$3R as transformReply };
}

declare const FIRST_KEY_INDEX$21 = 1;
declare const IS_READ_ONLY$1t = true;
declare function transformArguments$4x(key: RedisCommandArgument$5, member: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$3Q(): Array<RedisCommandArgument$5>;

declare namespace GEOHASH {
  export { FIRST_KEY_INDEX$21 as FIRST_KEY_INDEX, IS_READ_ONLY$1t as IS_READ_ONLY, transformArguments$4x as transformArguments, transformReply$3Q as transformReply };
}

declare const FIRST_KEY_INDEX$20 = 1;
declare const IS_READ_ONLY$1s = true;
declare function transformArguments$4w(key: RedisCommandArgument$5, member1: RedisCommandArgument$5, member2: RedisCommandArgument$5, unit?: GeoUnits): RedisCommandArguments$5;
declare function transformReply$3P(reply: RedisCommandArgument$5 | null): number | null;

declare namespace GEODIST {
  export { FIRST_KEY_INDEX$20 as FIRST_KEY_INDEX, IS_READ_ONLY$1s as IS_READ_ONLY, transformArguments$4w as transformArguments, transformReply$3P as transformReply };
}

declare const FIRST_KEY_INDEX$1$ = 1;
interface GeoMember extends GeoCoordinates$1 {
    member: RedisCommandArgument$5;
}
interface NX$1 {
    NX?: true;
}
interface XX$1 {
    XX?: true;
}
type SetGuards = NX$1 | XX$1;
interface GeoAddCommonOptions {
    CH?: true;
}
type GeoAddOptions = SetGuards & GeoAddCommonOptions;
declare function transformArguments$4v(key: RedisCommandArgument$5, toAdd: GeoMember | Array<GeoMember>, options?: GeoAddOptions): RedisCommandArguments$5;
declare function transformReply$3O(): number;

declare namespace GEOADD {
  export { FIRST_KEY_INDEX$1$ as FIRST_KEY_INDEX, transformArguments$4v as transformArguments, transformReply$3O as transformReply };
}

declare const FIRST_KEY_INDEX$1_: typeof evalFirstKeyIndex;
declare function transformArguments$4u(fn: string, options?: EvalOptions): Array<string>;

declare namespace FCALL {
  export { FIRST_KEY_INDEX$1_ as FIRST_KEY_INDEX, transformArguments$4u as transformArguments };
}

declare const FIRST_KEY_INDEX$1Z: typeof evalFirstKeyIndex;
declare const IS_READ_ONLY$1r = true;
declare function transformArguments$4t(fn: string, options?: EvalOptions): Array<string>;

declare namespace FCALL_RO {
  export { FIRST_KEY_INDEX$1Z as FIRST_KEY_INDEX, IS_READ_ONLY$1r as IS_READ_ONLY, transformArguments$4t as transformArguments };
}

declare const FIRST_KEY_INDEX$1Y = 1;
declare function transformArguments$4s(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$3N(): number;

declare namespace EXPIRETIME {
  export { FIRST_KEY_INDEX$1Y as FIRST_KEY_INDEX, transformArguments$4s as transformArguments, transformReply$3N as transformReply };
}

declare const FIRST_KEY_INDEX$1X = 1;
declare function transformArguments$4r(key: RedisCommandArgument$5, timestamp: number | Date, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;

declare namespace EXPIREAT {
  export { FIRST_KEY_INDEX$1X as FIRST_KEY_INDEX, transformArguments$4r as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$1W = 1;
declare function transformArguments$4q(key: RedisCommandArgument$5, seconds: number, mode?: 'NX' | 'XX' | 'GT' | 'LT'): RedisCommandArguments$5;

declare namespace EXPIRE {
  export { FIRST_KEY_INDEX$1W as FIRST_KEY_INDEX, transformArguments$4q as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$1V = 1;
declare const IS_READ_ONLY$1q = true;
declare function transformArguments$4p(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$3M(): number;

declare namespace EXISTS {
  export { FIRST_KEY_INDEX$1V as FIRST_KEY_INDEX, IS_READ_ONLY$1q as IS_READ_ONLY, transformArguments$4p as transformArguments, transformReply$3M as transformReply };
}

declare const FIRST_KEY_INDEX$1U: typeof evalFirstKeyIndex;
declare const IS_READ_ONLY$1p = true;
declare function transformArguments$4o(sha1: string, options?: EvalOptions): Array<string>;

declare namespace EVALSHA_RO {
  export { FIRST_KEY_INDEX$1U as FIRST_KEY_INDEX, IS_READ_ONLY$1p as IS_READ_ONLY, transformArguments$4o as transformArguments };
}

declare const FIRST_KEY_INDEX$1T: typeof evalFirstKeyIndex;
declare function transformArguments$4n(sha1: string, options?: EvalOptions): Array<string>;

declare namespace EVALSHA {
  export { FIRST_KEY_INDEX$1T as FIRST_KEY_INDEX, transformArguments$4n as transformArguments };
}

declare const FIRST_KEY_INDEX$1S: typeof evalFirstKeyIndex;
declare function transformArguments$4m(script: string, options?: EvalOptions): Array<string>;

declare namespace EVAL {
  export { FIRST_KEY_INDEX$1S as FIRST_KEY_INDEX, transformArguments$4m as transformArguments };
}

declare const FIRST_KEY_INDEX$1R: typeof evalFirstKeyIndex;
declare const IS_READ_ONLY$1o = true;
declare function transformArguments$4l(script: string, options?: EvalOptions): Array<string>;

declare namespace EVAL_RO {
  export { FIRST_KEY_INDEX$1R as FIRST_KEY_INDEX, IS_READ_ONLY$1o as IS_READ_ONLY, transformArguments$4l as transformArguments };
}

declare const FIRST_KEY_INDEX$1Q = 1;
declare function transformArguments$4k(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$3L(): RedisCommandArgument$5;

declare namespace DUMP {
  export { FIRST_KEY_INDEX$1Q as FIRST_KEY_INDEX, transformArguments$4k as transformArguments, transformReply$3L as transformReply };
}

declare const FIRST_KEY_INDEX$1P = 1;
declare function transformArguments$4j(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$3K(): number;

declare namespace DEL {
  export { FIRST_KEY_INDEX$1P as FIRST_KEY_INDEX, transformArguments$4j as transformArguments, transformReply$3K as transformReply };
}

declare const FIRST_KEY_INDEX$1O = 1;
declare function transformArguments$4i(key: RedisCommandArgument$5, decrement: number): RedisCommandArguments$5;
declare function transformReply$3J(): number;

declare namespace DECRBY {
  export { FIRST_KEY_INDEX$1O as FIRST_KEY_INDEX, transformArguments$4i as transformArguments, transformReply$3J as transformReply };
}

declare const FIRST_KEY_INDEX$1N = 1;
declare function transformArguments$4h(key: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$3I(): number;

declare namespace DECR {
  export { FIRST_KEY_INDEX$1N as FIRST_KEY_INDEX, transformArguments$4h as transformArguments, transformReply$3I as transformReply };
}

interface CopyCommandOptions {
    destinationDb?: number;
    replace?: boolean;
}
declare const FIRST_KEY_INDEX$1M = 1;
declare function transformArguments$4g(source: RedisCommandArgument$5, destination: RedisCommandArgument$5, options?: CopyCommandOptions): RedisCommandArguments$5;

declare namespace COPY {
  export { FIRST_KEY_INDEX$1M as FIRST_KEY_INDEX, transformArguments$4g as transformArguments, transformBooleanReply$2 as transformReply };
}

declare const FIRST_KEY_INDEX$1L = 1;
declare function transformArguments$4f(key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, timeout: number): RedisCommandArguments$5;
type ZMemberRawReply = [key: RedisCommandArgument$5, value: RedisCommandArgument$5, score: RedisCommandArgument$5] | null;
type BZPopMaxReply = (ZMember & {
    key: RedisCommandArgument$5;
}) | null;
declare function transformReply$3H(reply: ZMemberRawReply): BZPopMaxReply | null;

declare namespace BZPOPMAX {
  export { FIRST_KEY_INDEX$1L as FIRST_KEY_INDEX, transformArguments$4f as transformArguments, transformReply$3H as transformReply };
}

declare const FIRST_KEY_INDEX$1K = 1;
declare function transformArguments$4e(key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, timeout: number): RedisCommandArguments$5;

declare namespace BZPOPMIN {
  export { FIRST_KEY_INDEX$1K as FIRST_KEY_INDEX, transformArguments$4e as transformArguments, transformReply$3H as transformReply };
}

declare const FIRST_KEY_INDEX$1J = 3;
declare function transformArguments$4d(timeout: number, keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, side: SortedSetSide, options?: ZMPopOptions): RedisCommandArguments$5;

declare namespace BZMPOP {
  export { FIRST_KEY_INDEX$1J as FIRST_KEY_INDEX, transformArguments$4d as transformArguments, transformReply$5Y as transformReply };
}

declare const FIRST_KEY_INDEX$1I = 1;
declare function transformArguments$4c(source: RedisCommandArgument$5, destination: RedisCommandArgument$5, timeout: number): RedisCommandArguments$5;
declare function transformReply$3G(): RedisCommandArgument$5 | null;

declare namespace BRPOPLPUSH {
  export { FIRST_KEY_INDEX$1I as FIRST_KEY_INDEX, transformArguments$4c as transformArguments, transformReply$3G as transformReply };
}

declare const FIRST_KEY_INDEX$1H = 1;
declare function transformArguments$4b(keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, timeout: number): RedisCommandArguments$5;
type BLPopRawReply = null | [RedisCommandArgument$5, RedisCommandArgument$5];
type BLPopReply = null | {
    key: RedisCommandArgument$5;
    element: RedisCommandArgument$5;
};
declare function transformReply$3F(reply: BLPopRawReply): BLPopReply;

declare namespace BLPOP {
  export { FIRST_KEY_INDEX$1H as FIRST_KEY_INDEX, transformArguments$4b as transformArguments, transformReply$3F as transformReply };
}

declare const FIRST_KEY_INDEX$1G = 1;
declare function transformArguments$4a(key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, timeout: number): RedisCommandArguments$5;

declare namespace BRPOP {
  export { FIRST_KEY_INDEX$1G as FIRST_KEY_INDEX, transformArguments$4a as transformArguments, transformReply$3F as transformReply };
}

declare const FIRST_KEY_INDEX$1F = 3;
declare function transformArguments$49(timeout: number, keys: RedisCommandArgument$5 | Array<RedisCommandArgument$5>, side: ListSide, options?: LMPopOptions): RedisCommandArguments$5;

declare namespace BLMPOP {
  export { FIRST_KEY_INDEX$1F as FIRST_KEY_INDEX, transformArguments$49 as transformArguments, transformReply$4C as transformReply };
}

declare const FIRST_KEY_INDEX$1E = 1;
declare function transformArguments$48(source: RedisCommandArgument$5, destination: RedisCommandArgument$5, sourceDirection: ListSide, destinationDirection: ListSide, timeout: number): RedisCommandArguments$5;
declare function transformReply$3E(): RedisCommandArgument$5 | null;

declare namespace BLMOVE {
  export { FIRST_KEY_INDEX$1E as FIRST_KEY_INDEX, transformArguments$48 as transformArguments, transformReply$3E as transformReply };
}

declare const FIRST_KEY_INDEX$1D = 1;
declare const IS_READ_ONLY$1n = true;
declare function transformArguments$47(key: RedisCommandArgument$5, bit: BitValue, start?: number, end?: number, mode?: 'BYTE' | 'BIT'): RedisCommandArguments$5;
declare function transformReply$3D(): number;

declare namespace BITPOS {
  export { FIRST_KEY_INDEX$1D as FIRST_KEY_INDEX, IS_READ_ONLY$1n as IS_READ_ONLY, transformArguments$47 as transformArguments, transformReply$3D as transformReply };
}

declare const FIRST_KEY_INDEX$1C = 2;
type BitOperations = 'AND' | 'OR' | 'XOR' | 'NOT';
declare function transformArguments$46(operation: BitOperations, destKey: RedisCommandArgument$5, key: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$3C(): number;

declare namespace BITOP {
  export { FIRST_KEY_INDEX$1C as FIRST_KEY_INDEX, transformArguments$46 as transformArguments, transformReply$3C as transformReply };
}

declare const FIRST_KEY_INDEX$1B = 1;
type BitFieldEncoding = `${'i' | 'u'}${number}`;
interface BitFieldOperation<S extends string> {
    operation: S;
}
interface BitFieldGetOperation extends BitFieldOperation<'GET'> {
    encoding: BitFieldEncoding;
    offset: number | string;
}
interface BitFieldSetOperation extends BitFieldOperation<'SET'> {
    encoding: BitFieldEncoding;
    offset: number | string;
    value: number;
}
interface BitFieldIncrByOperation extends BitFieldOperation<'INCRBY'> {
    encoding: BitFieldEncoding;
    offset: number | string;
    increment: number;
}
interface BitFieldOverflowOperation extends BitFieldOperation<'OVERFLOW'> {
    behavior: string;
}
type BitFieldOperations = Array<BitFieldGetOperation | BitFieldSetOperation | BitFieldIncrByOperation | BitFieldOverflowOperation>;
declare function transformArguments$45(key: string, operations: BitFieldOperations): Array<string>;
declare function transformReply$3B(): Array<number | null>;

type BITFIELD_BitFieldEncoding = BitFieldEncoding;
type BITFIELD_BitFieldGetOperation = BitFieldGetOperation;
type BITFIELD_BitFieldOperation<S extends string> = BitFieldOperation<S>;
declare namespace BITFIELD {
  export { type BITFIELD_BitFieldEncoding as BitFieldEncoding, type BITFIELD_BitFieldGetOperation as BitFieldGetOperation, type BITFIELD_BitFieldOperation as BitFieldOperation, FIRST_KEY_INDEX$1B as FIRST_KEY_INDEX, transformArguments$45 as transformArguments, transformReply$3B as transformReply };
}

declare const FIRST_KEY_INDEX$1A = 1;
declare const IS_READ_ONLY$1m = true;
type BitFieldRoOperations = Array<Omit<BitFieldGetOperation, 'operation'> & Partial<Pick<BitFieldGetOperation, 'operation'>>>;
declare function transformArguments$44(key: string, operations: BitFieldRoOperations): Array<string>;
declare function transformReply$3A(): Array<number | null>;

declare namespace BITFIELD_RO {
  export { FIRST_KEY_INDEX$1A as FIRST_KEY_INDEX, IS_READ_ONLY$1m as IS_READ_ONLY, transformArguments$44 as transformArguments, transformReply$3A as transformReply };
}

declare const FIRST_KEY_INDEX$1z = 1;
declare const IS_READ_ONLY$1l = true;
interface BitCountRange {
    start: number;
    end: number;
    mode?: 'BYTE' | 'BIT';
}
declare function transformArguments$43(key: RedisCommandArgument$5, range?: BitCountRange): RedisCommandArguments$5;
declare function transformReply$3z(): number;

declare namespace BITCOUNT {
  export { FIRST_KEY_INDEX$1z as FIRST_KEY_INDEX, IS_READ_ONLY$1l as IS_READ_ONLY, transformArguments$43 as transformArguments, transformReply$3z as transformReply };
}

declare const FIRST_KEY_INDEX$1y = 1;
declare function transformArguments$42(key: RedisCommandArgument$5, value: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$3y(): number;

declare namespace APPEND {
  export { FIRST_KEY_INDEX$1y as FIRST_KEY_INDEX, transformArguments$42 as transformArguments, transformReply$3y as transformReply };
}

declare function transformArguments$41(categoryName?: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$3x(): Array<RedisCommandArgument$5>;

declare namespace ACL_CAT {
  export { transformArguments$41 as transformArguments, transformReply$3x as transformReply };
}

declare function transformArguments$40(username: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$3w(): number;

declare namespace ACL_DELUSER {
  export { transformArguments$40 as transformArguments, transformReply$3w as transformReply };
}

declare const IS_READ_ONLY$1k = true;
declare function transformArguments$3$(username: RedisCommandArgument$5, command: Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$3v(): RedisCommandArgument$5;

declare namespace ACL_DRYRUN {
  export { IS_READ_ONLY$1k as IS_READ_ONLY, transformArguments$3$ as transformArguments, transformReply$3v as transformReply };
}

declare function transformArguments$3_(bits?: number): RedisCommandArguments$5;
declare function transformReply$3u(): RedisCommandArgument$5;

declare namespace ACL_GENPASS {
  export { transformArguments$3_ as transformArguments, transformReply$3u as transformReply };
}

declare function transformArguments$3Z(username: RedisCommandArgument$5): RedisCommandArguments$5;
type AclGetUserRawReply = [
    'flags',
    Array<RedisCommandArgument$5>,
    'passwords',
    Array<RedisCommandArgument$5>,
    'commands',
    RedisCommandArgument$5,
    'keys',
    Array<RedisCommandArgument$5> | RedisCommandArgument$5,
    'channels',
    Array<RedisCommandArgument$5> | RedisCommandArgument$5,
    'selectors' | undefined,
    Array<Array<string>> | undefined
];
interface AclUser {
    flags: Array<RedisCommandArgument$5>;
    passwords: Array<RedisCommandArgument$5>;
    commands: RedisCommandArgument$5;
    keys: Array<RedisCommandArgument$5> | RedisCommandArgument$5;
    channels: Array<RedisCommandArgument$5> | RedisCommandArgument$5;
    selectors?: Array<Array<string>>;
}
declare function transformReply$3t(reply: AclGetUserRawReply): AclUser;

declare namespace ACL_GETUSER {
  export { transformArguments$3Z as transformArguments, transformReply$3t as transformReply };
}

declare function transformArguments$3Y(): RedisCommandArguments$5;
declare function transformReply$3s(): Array<RedisCommandArgument$5>;

declare namespace ACL_LIST {
  export { transformArguments$3Y as transformArguments, transformReply$3s as transformReply };
}

declare function transformArguments$3X(): RedisCommandArguments$5;
declare function transformReply$3r(): RedisCommandArgument$5;

declare namespace ACL_LOAD {
  export { transformArguments$3X as transformArguments, transformReply$3r as transformReply };
}

declare function transformArguments$3W(): RedisCommandArguments$5;
declare function transformReply$3q(): RedisCommandArgument$5;

declare namespace ACL_LOG_RESET {
  export { transformArguments$3W as transformArguments, transformReply$3q as transformReply };
}

declare function transformArguments$3V(count?: number): RedisCommandArguments$5;
type AclLogRawReply = [
    _: RedisCommandArgument$5,
    count: number,
    _: RedisCommandArgument$5,
    reason: RedisCommandArgument$5,
    _: RedisCommandArgument$5,
    context: RedisCommandArgument$5,
    _: RedisCommandArgument$5,
    object: RedisCommandArgument$5,
    _: RedisCommandArgument$5,
    username: RedisCommandArgument$5,
    _: RedisCommandArgument$5,
    ageSeconds: RedisCommandArgument$5,
    _: RedisCommandArgument$5,
    clientInfo: RedisCommandArgument$5
];
interface AclLog {
    count: number;
    reason: RedisCommandArgument$5;
    context: RedisCommandArgument$5;
    object: RedisCommandArgument$5;
    username: RedisCommandArgument$5;
    ageSeconds: number;
    clientInfo: RedisCommandArgument$5;
}
declare function transformReply$3p(reply: Array<AclLogRawReply>): Array<AclLog>;

declare namespace ACL_LOG {
  export { transformArguments$3V as transformArguments, transformReply$3p as transformReply };
}

declare function transformArguments$3U(): RedisCommandArguments$5;
declare function transformReply$3o(): RedisCommandArgument$5;

declare namespace ACL_SAVE {
  export { transformArguments$3U as transformArguments, transformReply$3o as transformReply };
}

declare function transformArguments$3T(username: RedisCommandArgument$5, rule: RedisCommandArgument$5 | Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$3n(): RedisCommandArgument$5;

declare namespace ACL_SETUSER {
  export { transformArguments$3T as transformArguments, transformReply$3n as transformReply };
}

declare function transformArguments$3S(): RedisCommandArguments$5;
declare function transformReply$3m(): Array<RedisCommandArgument$5>;

declare namespace ACL_USERS {
  export { transformArguments$3S as transformArguments, transformReply$3m as transformReply };
}

declare function transformArguments$3R(): RedisCommandArguments$5;
declare function transformReply$3l(): RedisCommandArgument$5;

declare namespace ACL_WHOAMI {
  export { transformArguments$3R as transformArguments, transformReply$3l as transformReply };
}

declare function transformArguments$3Q(): RedisCommandArguments$5;
declare function transformReply$3k(): RedisCommandArgument$5;

declare namespace ASKING {
  export { transformArguments$3Q as transformArguments, transformReply$3k as transformReply };
}

declare function transformArguments$3P(): RedisCommandArguments$5;
declare function transformReply$3j(): RedisCommandArgument$5;

declare namespace BGREWRITEAOF {
  export { transformArguments$3P as transformArguments, transformReply$3j as transformReply };
}

interface BgSaveOptions {
    SCHEDULE?: true;
}
declare function transformArguments$3O(options?: BgSaveOptions): RedisCommandArguments$5;
declare function transformReply$3i(): RedisCommandArgument$5;

declare namespace BGSAVE {
  export { transformArguments$3O as transformArguments, transformReply$3i as transformReply };
}

declare function transformArguments$3N(value: boolean): RedisCommandArguments$5;
declare function transformReply$3h(): 'OK' | Buffer;

declare namespace CLIENT_CACHING {
  export { transformArguments$3N as transformArguments, transformReply$3h as transformReply };
}

declare function transformArguments$3M(): RedisCommandArguments$5;
declare function transformReply$3g(): string | null;

declare namespace CLIENT_GETNAME {
  export { transformArguments$3M as transformArguments, transformReply$3g as transformReply };
}

declare function transformArguments$3L(): RedisCommandArguments$5;
declare function transformReply$3f(): number;

declare namespace CLIENT_GETREDIR {
  export { transformArguments$3L as transformArguments, transformReply$3f as transformReply };
}

declare const IS_READ_ONLY$1j = true;
declare function transformArguments$3K(): Array<string>;
declare function transformReply$3e(): number;

declare namespace CLIENT_ID {
  export { IS_READ_ONLY$1j as IS_READ_ONLY, transformArguments$3K as transformArguments, transformReply$3e as transformReply };
}

declare enum ClientKillFilters {
    ADDRESS = "ADDR",
    LOCAL_ADDRESS = "LADDR",
    ID = "ID",
    TYPE = "TYPE",
    USER = "USER",
    SKIP_ME = "SKIPME",
    MAXAGE = "MAXAGE"
}
interface KillFilter<T extends ClientKillFilters> {
    filter: T;
}
interface KillAddress extends KillFilter<ClientKillFilters.ADDRESS> {
    address: `${string}:${number}`;
}
interface KillLocalAddress extends KillFilter<ClientKillFilters.LOCAL_ADDRESS> {
    localAddress: `${string}:${number}`;
}
interface KillId extends KillFilter<ClientKillFilters.ID> {
    id: number | `${number}`;
}
interface KillType extends KillFilter<ClientKillFilters.TYPE> {
    type: 'normal' | 'master' | 'replica' | 'pubsub';
}
interface KillUser extends KillFilter<ClientKillFilters.USER> {
    username: string;
}
type KillSkipMe = ClientKillFilters.SKIP_ME | (KillFilter<ClientKillFilters.SKIP_ME> & {
    skipMe: boolean;
});
interface KillMaxAge extends KillFilter<ClientKillFilters.MAXAGE> {
    maxAge: number;
}
type KillFilters = KillAddress | KillLocalAddress | KillId | KillType | KillUser | KillSkipMe | KillMaxAge;
declare function transformArguments$3J(filters: KillFilters | Array<KillFilters>): RedisCommandArguments$5;
declare function transformReply$3d(): number;

type CLIENT_KILL_ClientKillFilters = ClientKillFilters;
declare const CLIENT_KILL_ClientKillFilters: typeof ClientKillFilters;
declare namespace CLIENT_KILL {
  export { CLIENT_KILL_ClientKillFilters as ClientKillFilters, transformArguments$3J as transformArguments, transformReply$3d as transformReply };
}

declare const IS_READ_ONLY$1i = true;
declare function transformArguments$3I(): Array<string>;
interface ClientInfoReply {
    id: number;
    addr: string;
    laddr?: string;
    fd: number;
    name: string;
    age: number;
    idle: number;
    flags: string;
    db: number;
    sub: number;
    psub: number;
    ssub?: number;
    multi: number;
    qbuf: number;
    qbufFree: number;
    argvMem?: number;
    multiMem?: number;
    obl: number;
    oll: number;
    omem: number;
    totMem?: number;
    events: string;
    cmd: string;
    user?: string;
    redir?: number;
    resp?: number;
    libName?: string;
    libVer?: string;
}
declare function transformReply$3c(rawReply: string): ClientInfoReply;

type CLIENT_INFO_ClientInfoReply = ClientInfoReply;
declare namespace CLIENT_INFO {
  export { type CLIENT_INFO_ClientInfoReply as ClientInfoReply, IS_READ_ONLY$1i as IS_READ_ONLY, transformArguments$3I as transformArguments, transformReply$3c as transformReply };
}

interface ListFilterType {
    TYPE: 'NORMAL' | 'MASTER' | 'REPLICA' | 'PUBSUB';
    ID?: never;
}
interface ListFilterId {
    ID: Array<RedisCommandArgument$5>;
    TYPE?: never;
}
type ListFilter = ListFilterType | ListFilterId;
declare const IS_READ_ONLY$1h = true;
declare function transformArguments$3H(filter?: ListFilter): RedisCommandArguments$5;
declare function transformReply$3b(rawReply: string): Array<ClientInfoReply>;

type CLIENT_LIST_ListFilter = ListFilter;
declare namespace CLIENT_LIST {
  export { IS_READ_ONLY$1h as IS_READ_ONLY, type CLIENT_LIST_ListFilter as ListFilter, transformArguments$3H as transformArguments, transformReply$3b as transformReply };
}

declare function transformArguments$3G(value: boolean): RedisCommandArguments$5;
declare function transformReply$3a(): 'OK' | Buffer;

declare namespace CLIENT_NO_EVICT {
  export { transformArguments$3G as transformArguments, transformReply$3a as transformReply };
}

declare function transformArguments$3F(value: boolean): RedisCommandArguments$5;
declare function transformReply$39(): 'OK' | Buffer;

declare namespace CLIENT_NO_TOUCH {
  export { transformArguments$3F as transformArguments, transformReply$39 as transformReply };
}

declare function transformArguments$3E(timeout: number, mode?: 'WRITE' | 'ALL'): RedisCommandArguments$5;
declare function transformReply$38(): 'OK' | Buffer;

declare namespace CLIENT_PAUSE {
  export { transformArguments$3E as transformArguments, transformReply$38 as transformReply };
}

declare function transformArguments$3D(name: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$37(): RedisCommandArgument$5;

declare namespace CLIENT_SETNAME {
  export { transformArguments$3D as transformArguments, transformReply$37 as transformReply };
}

interface CommonOptions {
    REDIRECT?: number;
    NOLOOP?: boolean;
}
interface BroadcastOptions {
    BCAST?: boolean;
    PREFIX?: RedisCommandArgument$5 | Array<RedisCommandArgument$5>;
}
interface OptInOptions {
    OPTIN?: boolean;
}
interface OptOutOptions {
    OPTOUT?: boolean;
}
type ClientTrackingOptions = CommonOptions & (BroadcastOptions | OptInOptions | OptOutOptions);
declare function transformArguments$3C<M extends boolean>(mode: M, options?: M extends true ? ClientTrackingOptions : undefined): RedisCommandArguments$5;
declare function transformReply$36(): 'OK' | Buffer;

declare namespace CLIENT_TRACKING {
  export { transformArguments$3C as transformArguments, transformReply$36 as transformReply };
}

declare function transformArguments$3B(): RedisCommandArguments$5;
type RawReply = [
    'flags',
    Array<string>,
    'redirect',
    number,
    'prefixes',
    Array<string>
];
interface Reply {
    flags: Set<string>;
    redirect: number;
    prefixes: Array<string>;
}
declare function transformReply$35(reply: RawReply): Reply;

declare namespace CLIENT_TRACKINGINFO {
  export { transformArguments$3B as transformArguments, transformReply$35 as transformReply };
}

declare function transformArguments$3A(): RedisCommandArguments$5;
declare function transformReply$34(): 'OK' | Buffer;

declare namespace CLIENT_UNPAUSE {
  export { transformArguments$3A as transformArguments, transformReply$34 as transformReply };
}

declare function transformArguments$3z(slots: number | Array<number>): RedisCommandArguments$5;
declare function transformReply$33(): string;

declare namespace CLUSTER_ADDSLOTS {
  export { transformArguments$3z as transformArguments, transformReply$33 as transformReply };
}

declare function transformArguments$3y(ranges: SlotRange | Array<SlotRange>): RedisCommandArguments$5;
declare function transformReply$32(): 'OK';

declare namespace CLUSTER_ADDSLOTSRANGE {
  export { transformArguments$3y as transformArguments, transformReply$32 as transformReply };
}

declare function transformArguments$3x(): Array<string>;
declare function transformReply$31(): 'BUMPED' | 'STILL';

declare namespace CLUSTER_BUMPEPOCH {
  export { transformArguments$3x as transformArguments, transformReply$31 as transformReply };
}

declare function transformArguments$3w(nodeId: string): Array<string>;
declare function transformReply$30(): number;

declare namespace CLUSTER_COUNT_FAILURE_REPORTS {
  export { transformArguments$3w as transformArguments, transformReply$30 as transformReply };
}

declare function transformArguments$3v(slot: number): Array<string>;
declare function transformReply$2$(): number;

declare namespace CLUSTER_COUNTKEYSINSLOT {
  export { transformArguments$3v as transformArguments, transformReply$2$ as transformReply };
}

declare function transformArguments$3u(slots: number | Array<number>): RedisCommandArguments$5;
declare function transformReply$2_(): 'OK';

declare namespace CLUSTER_DELSLOTS {
  export { transformArguments$3u as transformArguments, transformReply$2_ as transformReply };
}

declare function transformArguments$3t(ranges: SlotRange | Array<SlotRange>): RedisCommandArguments$5;
declare function transformReply$2Z(): 'OK';

declare namespace CLUSTER_DELSLOTSRANGE {
  export { transformArguments$3t as transformArguments, transformReply$2Z as transformReply };
}

declare enum FailoverModes {
    FORCE = "FORCE",
    TAKEOVER = "TAKEOVER"
}
declare function transformArguments$3s(mode?: FailoverModes): Array<string>;
declare function transformReply$2Y(): 'OK';

type CLUSTER_FAILOVER_FailoverModes = FailoverModes;
declare const CLUSTER_FAILOVER_FailoverModes: typeof FailoverModes;
declare namespace CLUSTER_FAILOVER {
  export { CLUSTER_FAILOVER_FailoverModes as FailoverModes, transformArguments$3s as transformArguments, transformReply$2Y as transformReply };
}

declare function transformArguments$3r(): Array<string>;
declare function transformReply$2X(): 'OK';

declare namespace CLUSTER_FLUSHSLOTS {
  export { transformArguments$3r as transformArguments, transformReply$2X as transformReply };
}

declare function transformArguments$3q(nodeId: string): Array<string>;
declare function transformReply$2W(): 'OK';

declare namespace CLUSTER_FORGET {
  export { transformArguments$3q as transformArguments, transformReply$2W as transformReply };
}

declare function transformArguments$3p(slot: number, count: number): Array<string>;
declare function transformReply$2V(): Array<string>;

declare namespace CLUSTER_GETKEYSINSLOT {
  export { transformArguments$3p as transformArguments, transformReply$2V as transformReply };
}

declare function transformArguments$3o(): Array<string>;
interface ClusterInfoReply {
    state: string;
    slots: {
        assigned: number;
        ok: number;
        pfail: number;
        fail: number;
    };
    knownNodes: number;
    size: number;
    currentEpoch: number;
    myEpoch: number;
    stats: {
        messagesSent: number;
        messagesReceived: number;
    };
}
declare function transformReply$2U(reply: string): ClusterInfoReply;
declare function extractLineValue(line: string): string;

declare const CLUSTER_INFO_extractLineValue: typeof extractLineValue;
declare namespace CLUSTER_INFO {
  export { CLUSTER_INFO_extractLineValue as extractLineValue, transformArguments$3o as transformArguments, transformReply$2U as transformReply };
}

declare function transformArguments$3n(key: string): Array<string>;
declare function transformReply$2T(): number;

declare namespace CLUSTER_KEYSLOT {
  export { transformArguments$3n as transformArguments, transformReply$2T as transformReply };
}

declare function transformArguments$3m(): Array<string>;
type ClusterLinksRawReply = Array<[
    'direction',
    string,
    'node',
    string,
    'createTime',
    number,
    'events',
    string,
    'send-buffer-allocated',
    number,
    'send-buffer-used',
    number
]>;
type ClusterLinksReply = Array<{
    direction: string;
    node: string;
    createTime: number;
    events: string;
    sendBufferAllocated: number;
    sendBufferUsed: number;
}>;
declare function transformReply$2S(reply: ClusterLinksRawReply): ClusterLinksReply;

declare namespace CLUSTER_LINKS {
  export { transformArguments$3m as transformArguments, transformReply$2S as transformReply };
}

declare function transformArguments$3l(ip: string, port: number): Array<string>;
declare function transformReply$2R(): 'OK';

declare namespace CLUSTER_MEET {
  export { transformArguments$3l as transformArguments, transformReply$2R as transformReply };
}

declare function transformArguments$3k(): Array<string>;
declare function transformReply$2Q(): string;

declare namespace CLUSTER_MYID {
  export { transformArguments$3k as transformArguments, transformReply$2Q as transformReply };
}

declare const IS_READ_ONLY$1g = true;
declare function transformArguments$3j(): string[];
declare function transformReply$2P(): string | Buffer;

declare namespace CLUSTER_MYSHARDID {
  export { IS_READ_ONLY$1g as IS_READ_ONLY, transformArguments$3j as transformArguments, transformReply$2P as transformReply };
}

declare function transformArguments$3i(): Array<string>;
declare enum RedisClusterNodeLinkStates {
    CONNECTED = "connected",
    DISCONNECTED = "disconnected"
}
interface RedisClusterNodeAddress {
    host: string;
    port: number;
    cport: number | null;
}
interface RedisClusterReplicaNode extends RedisClusterNodeAddress {
    id: string;
    address: string;
    flags: Array<string>;
    pingSent: number;
    pongRecv: number;
    configEpoch: number;
    linkState: RedisClusterNodeLinkStates;
}
interface RedisClusterMasterNode extends RedisClusterReplicaNode {
    slots: Array<{
        from: number;
        to: number;
    }>;
    replicas: Array<RedisClusterReplicaNode>;
}
declare function transformReply$2O(reply: string): Array<RedisClusterMasterNode>;

type CLUSTER_NODES_RedisClusterMasterNode = RedisClusterMasterNode;
type CLUSTER_NODES_RedisClusterNodeLinkStates = RedisClusterNodeLinkStates;
declare const CLUSTER_NODES_RedisClusterNodeLinkStates: typeof RedisClusterNodeLinkStates;
type CLUSTER_NODES_RedisClusterReplicaNode = RedisClusterReplicaNode;
declare namespace CLUSTER_NODES {
  export { type CLUSTER_NODES_RedisClusterMasterNode as RedisClusterMasterNode, CLUSTER_NODES_RedisClusterNodeLinkStates as RedisClusterNodeLinkStates, type CLUSTER_NODES_RedisClusterReplicaNode as RedisClusterReplicaNode, transformArguments$3i as transformArguments, transformReply$2O as transformReply };
}

declare function transformArguments$3h(nodeId: string): Array<string>;

declare namespace CLUSTER_REPLICAS {
  export { transformArguments$3h as transformArguments, transformReply$2O as transformReply };
}

declare function transformArguments$3g(nodeId: string): Array<string>;
declare function transformReply$2N(): 'OK';

declare namespace CLUSTER_REPLICATE {
  export { transformArguments$3g as transformArguments, transformReply$2N as transformReply };
}

declare function transformArguments$3f(mode?: 'HARD' | 'SOFT'): Array<string>;
declare function transformReply$2M(): string;

declare namespace CLUSTER_RESET {
  export { transformArguments$3f as transformArguments, transformReply$2M as transformReply };
}

declare function transformArguments$3e(): Array<string>;
declare function transformReply$2L(): 'OK';

declare namespace CLUSTER_SAVECONFIG {
  export { transformArguments$3e as transformArguments, transformReply$2L as transformReply };
}

declare function transformArguments$3d(configEpoch: number): Array<string>;
declare function transformReply$2K(): 'OK';

declare namespace CLUSTER_SET_CONFIG_EPOCH {
  export { transformArguments$3d as transformArguments, transformReply$2K as transformReply };
}

declare enum ClusterSlotStates {
    IMPORTING = "IMPORTING",
    MIGRATING = "MIGRATING",
    STABLE = "STABLE",
    NODE = "NODE"
}
declare function transformArguments$3c(slot: number, state: ClusterSlotStates, nodeId?: string): Array<string>;
declare function transformReply$2J(): 'OK';

type CLUSTER_SETSLOT_ClusterSlotStates = ClusterSlotStates;
declare const CLUSTER_SETSLOT_ClusterSlotStates: typeof ClusterSlotStates;
declare namespace CLUSTER_SETSLOT {
  export { CLUSTER_SETSLOT_ClusterSlotStates as ClusterSlotStates, transformArguments$3c as transformArguments, transformReply$2J as transformReply };
}

declare function transformArguments$3b(): RedisCommandArguments$5;
type ClusterSlotsRawNode = [ip: string, port: number, id: string];
type ClusterSlotsRawReply = Array<[
    from: number,
    to: number,
    master: ClusterSlotsRawNode,
    ...replicas: Array<ClusterSlotsRawNode>
]>;
interface ClusterSlotsNode {
    ip: string;
    port: number;
    id: string;
}
type ClusterSlotsReply = Array<{
    from: number;
    to: number;
    master: ClusterSlotsNode;
    replicas: Array<ClusterSlotsNode>;
}>;
declare function transformReply$2I(reply: ClusterSlotsRawReply): ClusterSlotsReply;

type CLUSTER_SLOTS_ClusterSlotsNode = ClusterSlotsNode;
type CLUSTER_SLOTS_ClusterSlotsReply = ClusterSlotsReply;
declare namespace CLUSTER_SLOTS {
  export { type CLUSTER_SLOTS_ClusterSlotsNode as ClusterSlotsNode, type CLUSTER_SLOTS_ClusterSlotsReply as ClusterSlotsReply, transformArguments$3b as transformArguments, transformReply$2I as transformReply };
}

declare const IS_READ_ONLY$1f = true;
declare function transformArguments$3a(): RedisCommandArguments$5;
declare function transformReply$2H(): number;

declare namespace COMMAND_COUNT {
  export { IS_READ_ONLY$1f as IS_READ_ONLY, transformArguments$3a as transformArguments, transformReply$2H as transformReply };
}

declare const IS_READ_ONLY$1e = true;
declare function transformArguments$39(args: Array<RedisCommandArgument$5>): RedisCommandArguments$5;
declare function transformReply$2G(): Array<RedisCommandArgument$5>;

declare namespace COMMAND_GETKEYS {
  export { IS_READ_ONLY$1e as IS_READ_ONLY, transformArguments$39 as transformArguments, transformReply$2G as transformReply };
}

declare const IS_READ_ONLY$1d = true;
declare function transformArguments$38(args: Array<RedisCommandArgument$5>): RedisCommandArguments$5;
type KeysAndFlagsRawReply = Array<[
    RedisCommandArgument$5,
    RedisCommandArguments$5
]>;
type KeysAndFlagsReply = Array<{
    key: RedisCommandArgument$5;
    flags: RedisCommandArguments$5;
}>;
declare function transformReply$2F(reply: KeysAndFlagsRawReply): KeysAndFlagsReply;

declare namespace COMMAND_GETKEYSANDFLAGS {
  export { IS_READ_ONLY$1d as IS_READ_ONLY, transformArguments$38 as transformArguments, transformReply$2F as transformReply };
}

declare const IS_READ_ONLY$1c = true;
declare function transformArguments$37(commands: Array<string>): RedisCommandArguments$5;
declare function transformReply$2E(reply: Array<CommandRawReply | null>): Array<CommandReply | null>;

declare namespace COMMAND_INFO {
  export { IS_READ_ONLY$1c as IS_READ_ONLY, transformArguments$37 as transformArguments, transformReply$2E as transformReply };
}

declare const IS_READ_ONLY$1b = true;
declare enum FilterBy {
    MODULE = "MODULE",
    ACLCAT = "ACLCAT",
    PATTERN = "PATTERN"
}
interface Filter$1 {
    filterBy: FilterBy;
    value: string;
}
declare function transformArguments$36(filter?: Filter$1): RedisCommandArguments$5;
declare function transformReply$2D(): Array<string>;

type COMMAND_LIST_FilterBy = FilterBy;
declare const COMMAND_LIST_FilterBy: typeof FilterBy;
declare namespace COMMAND_LIST {
  export { COMMAND_LIST_FilterBy as FilterBy, IS_READ_ONLY$1b as IS_READ_ONLY, transformArguments$36 as transformArguments, transformReply$2D as transformReply };
}

declare const IS_READ_ONLY$1a = true;
declare function transformArguments$35(): RedisCommandArguments$5;
declare function transformReply$2C(reply: Array<CommandRawReply>): Array<CommandReply>;

declare namespace COMMAND {
  export { IS_READ_ONLY$1a as IS_READ_ONLY, transformArguments$35 as transformArguments, transformReply$2C as transformReply };
}

declare function transformArguments$34(parameter: string): Array<string>;

declare namespace CONFIG_GET {
  export { transformArguments$34 as transformArguments, transformTuplesReply as transformReply };
}

declare function transformArguments$33(): Array<string>;
declare function transformReply$2B(): string;

declare namespace CONFIG_RESETASTAT {
  export { transformArguments$33 as transformArguments, transformReply$2B as transformReply };
}

declare function transformArguments$32(): Array<string>;
declare function transformReply$2A(): string;

declare namespace CONFIG_REWRITE {
  export { transformArguments$32 as transformArguments, transformReply$2A as transformReply };
}

type SingleParameter = [parameter: RedisCommandArgument$5, value: RedisCommandArgument$5];
type MultipleParameters = [config: Record<string, RedisCommandArgument$5>];
declare function transformArguments$31(...[parameterOrConfig, value]: SingleParameter | MultipleParameters): RedisCommandArguments$5;
declare function transformReply$2z(): string;

declare namespace CONFIG_SET {
  export { transformArguments$31 as transformArguments, transformReply$2z as transformReply };
}

declare const IS_READ_ONLY$19 = true;
declare function transformArguments$30(): Array<string>;
declare function transformReply$2y(): number;

declare namespace DBSIZE {
  export { IS_READ_ONLY$19 as IS_READ_ONLY, transformArguments$30 as transformArguments, transformReply$2y as transformReply };
}

declare function transformArguments$2$(): Array<string>;
declare function transformReply$2x(): RedisCommandArgument$5;

declare namespace DISCARD {
  export { transformArguments$2$ as transformArguments, transformReply$2x as transformReply };
}

declare const IS_READ_ONLY$18 = true;
declare function transformArguments$2_(message: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$2w(): RedisCommandArgument$5;

declare namespace ECHO {
  export { IS_READ_ONLY$18 as IS_READ_ONLY, transformArguments$2_ as transformArguments, transformReply$2w as transformReply };
}

interface FailoverOptions {
    TO?: {
        host: string;
        port: number;
        FORCE?: true;
    };
    ABORT?: true;
    TIMEOUT?: number;
}
declare function transformArguments$2Z(options?: FailoverOptions): Array<string>;
declare function transformReply$2v(): string;

declare namespace FAILOVER {
  export { transformArguments$2Z as transformArguments, transformReply$2v as transformReply };
}

declare enum RedisFlushModes$1 {
    ASYNC = "ASYNC",
    SYNC = "SYNC"
}
declare function transformArguments$2Y(mode?: RedisFlushModes$1): Array<string>;
declare function transformReply$2u(): string;

declare namespace FLUSHALL {
  export { RedisFlushModes$1 as RedisFlushModes, transformArguments$2Y as transformArguments, transformReply$2u as transformReply };
}

declare function transformArguments$2X(mode?: RedisFlushModes$1): Array<string>;
declare function transformReply$2t(): string;

declare namespace FLUSHDB {
  export { transformArguments$2X as transformArguments, transformReply$2t as transformReply };
}

declare function transformArguments$2W(library: string): RedisCommandArguments$5;
declare function transformReply$2s(): 'OK';

declare namespace FUNCTION_DELETE {
  export { transformArguments$2W as transformArguments, transformReply$2s as transformReply };
}

declare function transformArguments$2V(): RedisCommandArguments$5;
declare function transformReply$2r(): RedisCommandArgument$5;

declare namespace FUNCTION_DUMP {
  export { transformArguments$2V as transformArguments, transformReply$2r as transformReply };
}

declare function transformArguments$2U(mode?: 'ASYNC' | 'SYNC'): RedisCommandArguments$5;
declare function transformReply$2q(): 'OK';

declare namespace FUNCTION_FLUSH {
  export { transformArguments$2U as transformArguments, transformReply$2q as transformReply };
}

declare function transformArguments$2T(): RedisCommandArguments$5;
declare function transformReply$2p(): 'OK';

declare namespace FUNCTION_KILL {
  export { transformArguments$2T as transformArguments, transformReply$2p as transformReply };
}

declare function transformArguments$2S(pattern?: string): RedisCommandArguments$5;
type FunctionListWithCodeRawItemReply = [
    ...FunctionListRawItemReply,
    'library_code',
    string
];
interface FunctionListWithCodeItemReply extends FunctionListItemReply {
    libraryCode: string;
}
declare function transformReply$2o(reply: Array<FunctionListWithCodeRawItemReply>): Array<FunctionListWithCodeItemReply>;

declare namespace FUNCTION_LIST_WITHCODE {
  export { transformArguments$2S as transformArguments, transformReply$2o as transformReply };
}

declare function transformArguments$2R(pattern?: string): RedisCommandArguments$5;
declare function transformReply$2n(reply: Array<FunctionListRawItemReply>): Array<FunctionListItemReply>;

declare namespace FUNCTION_LIST {
  export { transformArguments$2R as transformArguments, transformReply$2n as transformReply };
}

interface FunctionLoadOptions {
    REPLACE?: boolean;
}
declare function transformArguments$2Q(code: string, options?: FunctionLoadOptions): RedisCommandArguments$5;
declare function transformReply$2m(): string;

declare namespace FUNCTION_LOAD {
  export { transformArguments$2Q as transformArguments, transformReply$2m as transformReply };
}

declare function transformArguments$2P(dump: RedisCommandArgument$5, mode?: 'FLUSH' | 'APPEND' | 'REPLACE'): RedisCommandArguments$5;
declare function transformReply$2l(): 'OK';

declare namespace FUNCTION_RESTORE {
  export { transformArguments$2P as transformArguments, transformReply$2l as transformReply };
}

declare function transformArguments$2O(): RedisCommandArguments$5;
type FunctionStatsRawReply = [
    'running_script',
    null | [
        'name',
        string,
        'command',
        string,
        'duration_ms',
        number
    ],
    'engines',
    Array<any>
];
interface FunctionStatsReply {
    runningScript: null | {
        name: string;
        command: string;
        durationMs: number;
    };
    engines: Record<string, {
        librariesCount: number;
        functionsCount: number;
    }>;
}
declare function transformReply$2k(reply: FunctionStatsRawReply): FunctionStatsReply;

declare namespace FUNCTION_STATS {
  export { transformArguments$2O as transformArguments, transformReply$2k as transformReply };
}

interface HelloOptions {
    protover: number;
    auth?: Required<AuthOptions>;
    clientName?: string;
}
declare function transformArguments$2N(options?: HelloOptions): RedisCommandArguments$5;
type HelloRawReply = [
    _: never,
    server: RedisCommandArgument$5,
    _: never,
    version: RedisCommandArgument$5,
    _: never,
    proto: number,
    _: never,
    id: number,
    _: never,
    mode: RedisCommandArgument$5,
    _: never,
    role: RedisCommandArgument$5,
    _: never,
    modules: Array<RedisCommandArgument$5>
];
interface HelloTransformedReply {
    server: RedisCommandArgument$5;
    version: RedisCommandArgument$5;
    proto: number;
    id: number;
    mode: RedisCommandArgument$5;
    role: RedisCommandArgument$5;
    modules: Array<RedisCommandArgument$5>;
}
declare function transformReply$2j(reply: HelloRawReply): HelloTransformedReply;

declare namespace HELLO {
  export { transformArguments$2N as transformArguments, transformReply$2j as transformReply };
}

declare const IS_READ_ONLY$17 = true;
declare function transformArguments$2M(section?: string): Array<string>;
declare function transformReply$2i(): string;

declare namespace INFO {
  export { IS_READ_ONLY$17 as IS_READ_ONLY, transformArguments$2M as transformArguments, transformReply$2i as transformReply };
}

declare function transformArguments$2L(pattern: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$2h(): Array<RedisCommandArgument$5>;

declare namespace KEYS {
  export { transformArguments$2L as transformArguments, transformReply$2h as transformReply };
}

declare const IS_READ_ONLY$16 = true;
declare function transformArguments$2K(): Array<string>;
declare function transformReply$2g(reply: number): Date;

declare namespace LASTSAVE {
  export { IS_READ_ONLY$16 as IS_READ_ONLY, transformArguments$2K as transformArguments, transformReply$2g as transformReply };
}

declare function transformArguments$2J(): Array<string>;
declare function transformReply$2f(): string;

declare namespace LATENCY_DOCTOR {
  export { transformArguments$2J as transformArguments, transformReply$2f as transformReply };
}

type EventType$1 = 'active-defrag-cycle' | 'aof-fsync-always' | 'aof-stat' | 'aof-rewrite-diff-write' | 'aof-rename' | 'aof-write' | 'aof-write-active-child' | 'aof-write-alone' | 'aof-write-pending-fsync' | 'command' | 'expire-cycle' | 'eviction-cycle' | 'eviction-del' | 'fast-command' | 'fork' | 'rdb-unlink-temp-file';
declare function transformArguments$2I(event: EventType$1): RedisCommandArguments$5;
declare function transformReply$2e(): string;

declare namespace LATENCY_GRAPH {
  export { type EventType$1 as EventType, transformArguments$2I as transformArguments, transformReply$2e as transformReply };
}

type EventType = ('active-defrag-cycle' | 'aof-fsync-always' | 'aof-stat' | 'aof-rewrite-diff-write' | 'aof-rename' | 'aof-write' | 'aof-write-active-child' | 'aof-write-alone' | 'aof-write-pending-fsync' | 'command' | 'expire-cycle' | 'eviction-cycle' | 'eviction-del' | 'fast-command' | 'fork' | 'rdb-unlink-temp-file');
declare function transformArguments$2H(event: EventType): string[];
declare function transformReply$2d(): Array<[
    timestamp: number,
    latency: number
]>;

type LATENCY_HISTORY_EventType = EventType;
declare namespace LATENCY_HISTORY {
  export { type LATENCY_HISTORY_EventType as EventType, transformArguments$2H as transformArguments, transformReply$2d as transformReply };
}

declare function transformArguments$2G(): RedisCommandArguments$5;
declare function transformReply$2c(): Array<[
    name: string,
    timestamp: number,
    latestLatency: number,
    allTimeLatency: number
]>;

declare namespace LATENCY_LATEST {
  export { transformArguments$2G as transformArguments, transformReply$2c as transformReply };
}

declare const IS_READ_ONLY$15 = true;
declare function transformArguments$2F(version?: number, ...optionalArguments: Array<number>): Array<string>;
declare function transformReply$2b(): RedisCommandArgument$5;

declare namespace LOLWUT {
  export { IS_READ_ONLY$15 as IS_READ_ONLY, transformArguments$2F as transformArguments, transformReply$2b as transformReply };
}

declare function transformArguments$2E(): Array<string>;
declare function transformReply$2a(): string;

declare namespace MEMORY_DOCTOR {
  export { transformArguments$2E as transformArguments, transformReply$2a as transformReply };
}

declare function transformArguments$2D(): Array<string>;
declare function transformReply$29(): string;

declare namespace MEMORY_MALLOC_STATS {
  export { transformArguments$2D as transformArguments, transformReply$29 as transformReply };
}

declare function transformArguments$2C(): Array<string>;
declare function transformReply$28(): string;

declare namespace MEMORY_PURGE {
  export { transformArguments$2C as transformArguments, transformReply$28 as transformReply };
}

declare function transformArguments$2B(): Array<string>;
interface MemoryStatsReply {
    peakAllocated: number;
    totalAllocated: number;
    startupAllocated: number;
    replicationBacklog: number;
    clientsReplicas: number;
    clientsNormal: number;
    aofBuffer: number;
    luaCaches: number;
    overheadTotal: number;
    keysCount: number;
    keysBytesPerKey: number;
    datasetBytes: number;
    datasetPercentage: number;
    peakPercentage: number;
    allocatorAllocated?: number;
    allocatorActive?: number;
    allocatorResident?: number;
    allocatorFragmentationRatio?: number;
    allocatorFragmentationBytes?: number;
    allocatorRssRatio?: number;
    allocatorRssBytes?: number;
    rssOverheadRatio?: number;
    rssOverheadBytes?: number;
    fragmentation?: number;
    fragmentationBytes: number;
    db: {
        [key: number]: {
            overheadHashtableMain: number;
            overheadHashtableExpires: number;
        };
    };
}
declare function transformReply$27(rawReply: Array<string | number | Array<string | number>>): MemoryStatsReply;

declare namespace MEMORY_STATS {
  export { transformArguments$2B as transformArguments, transformReply$27 as transformReply };
}

declare const FIRST_KEY_INDEX$1x = 1;
declare const IS_READ_ONLY$14 = true;
interface MemoryUsageOptions {
    SAMPLES?: number;
}
declare function transformArguments$2A(key: string, options?: MemoryUsageOptions): Array<string>;
declare function transformReply$26(): number | null;

declare namespace MEMORY_USAGE {
  export { FIRST_KEY_INDEX$1x as FIRST_KEY_INDEX, IS_READ_ONLY$14 as IS_READ_ONLY, transformArguments$2A as transformArguments, transformReply$26 as transformReply };
}

declare function transformArguments$2z(): Array<string>;
declare function transformReply$25(): string;

declare namespace MODULE_LIST {
  export { transformArguments$2z as transformArguments, transformReply$25 as transformReply };
}

declare function transformArguments$2y(path: string, moduleArgs?: Array<string>): Array<string>;
declare function transformReply$24(): string;

declare namespace MODULE_LOAD {
  export { transformArguments$2y as transformArguments, transformReply$24 as transformReply };
}

declare function transformArguments$2x(name: string): Array<string>;
declare function transformReply$23(): string;

declare namespace MODULE_UNLOAD {
  export { transformArguments$2x as transformArguments, transformReply$23 as transformReply };
}

declare const FIRST_KEY_INDEX$1w = 1;
declare function transformArguments$2w(key: string, db: number): Array<string>;

declare namespace MOVE {
  export { FIRST_KEY_INDEX$1w as FIRST_KEY_INDEX, transformArguments$2w as transformArguments, transformBooleanReply$2 as transformReply };
}

declare function transformArguments$2v(message?: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$22(): RedisCommandArgument$5;

declare namespace PING {
  export { transformArguments$2v as transformArguments, transformReply$22 as transformReply };
}

declare const IS_READ_ONLY$13 = true;
declare function transformArguments$2u(pattern?: string): Array<string>;
declare function transformReply$21(): Array<string>;

declare namespace PUBSUB_CHANNELS {
  export { IS_READ_ONLY$13 as IS_READ_ONLY, transformArguments$2u as transformArguments, transformReply$21 as transformReply };
}

declare const IS_READ_ONLY$12 = true;
declare function transformArguments$2t(): Array<string>;
declare function transformReply$20(): string;

declare namespace PUBSUB_NUMPAT {
  export { IS_READ_ONLY$12 as IS_READ_ONLY, transformArguments$2t as transformArguments, transformReply$20 as transformReply };
}

declare const IS_READ_ONLY$11 = true;
declare function transformArguments$2s(channels?: Array<RedisCommandArgument$5> | RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$1$(rawReply: Array<string | number>): Record<string, number>;

declare namespace PUBSUB_NUMSUB {
  export { IS_READ_ONLY$11 as IS_READ_ONLY, transformArguments$2s as transformArguments, transformReply$1$ as transformReply };
}

declare const IS_READ_ONLY$10 = true;
declare function transformArguments$2r(pattern?: RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$1_(): Array<RedisCommandArgument$5>;

declare namespace PUBSUB_SHARDCHANNELS {
  export { IS_READ_ONLY$10 as IS_READ_ONLY, transformArguments$2r as transformArguments, transformReply$1_ as transformReply };
}

declare const IS_READ_ONLY$$ = true;
declare function transformArguments$2q(channels?: Array<RedisCommandArgument$5> | RedisCommandArgument$5): RedisCommandArguments$5;
declare function transformReply$1Z(rawReply: Array<string | number>): Record<string, number>;

declare namespace PUBSUB_SHARDNUMSUB {
  export { IS_READ_ONLY$$ as IS_READ_ONLY, transformArguments$2q as transformArguments, transformReply$1Z as transformReply };
}

declare const IS_READ_ONLY$_ = true;
declare function transformArguments$2p(): RedisCommandArguments$5;
declare function transformReply$1Y(): RedisCommandArgument$5 | null;

declare namespace RANDOMKEY {
  export { IS_READ_ONLY$_ as IS_READ_ONLY, transformArguments$2p as transformArguments, transformReply$1Y as transformReply };
}

declare function transformArguments$2o(): Array<string>;
declare function transformReply$1X(): string;

declare namespace READONLY {
  export { transformArguments$2o as transformArguments, transformReply$1X as transformReply };
}

declare function transformArguments$2n(): Array<string>;
declare function transformReply$1W(): string;

declare namespace READWRITE {
  export { transformArguments$2n as transformArguments, transformReply$1W as transformReply };
}

declare function transformArguments$2m(host: string, port: number): Array<string>;
declare function transformReply$1V(): string;

declare namespace REPLICAOF {
  export { transformArguments$2m as transformArguments, transformReply$1V as transformReply };
}

declare function transformArguments$2l(): Array<string>;
declare function transformReply$1U(): string;

declare namespace RESTORE_ASKING {
  export { transformArguments$2l as transformArguments, transformReply$1U as transformReply };
}

declare const IS_READ_ONLY$Z = true;
declare function transformArguments$2k(): Array<string>;
interface RoleReplyInterface<T extends string> {
    role: T;
}
type RoleMasterRawReply = ['master', number, Array<[string, string, string]>];
interface RoleMasterReply extends RoleReplyInterface<'master'> {
    replicationOffest: number;
    replicas: Array<{
        ip: string;
        port: number;
        replicationOffest: number;
    }>;
}
type RoleReplicaState = 'connect' | 'connecting' | 'sync' | 'connected';
type RoleReplicaRawReply = ['slave', string, number, RoleReplicaState, number];
interface RoleReplicaReply extends RoleReplyInterface<'slave'> {
    master: {
        ip: string;
        port: number;
    };
    state: RoleReplicaState;
    dataReceived: number;
}
type RoleSentinelRawReply = ['sentinel', Array<string>];
interface RoleSentinelReply extends RoleReplyInterface<'sentinel'> {
    masterNames: Array<string>;
}
type RoleRawReply = RoleMasterRawReply | RoleReplicaRawReply | RoleSentinelRawReply;
type RoleReply = RoleMasterReply | RoleReplicaReply | RoleSentinelReply;
declare function transformReply$1T(reply: RoleRawReply): RoleReply;

declare namespace ROLE {
  export { IS_READ_ONLY$Z as IS_READ_ONLY, transformArguments$2k as transformArguments, transformReply$1T as transformReply };
}

declare function transformArguments$2j(): Array<string>;
declare function transformReply$1S(): RedisCommandArgument$5;

declare namespace SAVE {
  export { transformArguments$2j as transformArguments, transformReply$1S as transformReply };
}

declare const IS_READ_ONLY$Y = true;
interface ScanCommandOptions extends ScanOptions {
    TYPE?: RedisCommandArgument$5;
}
declare function transformArguments$2i(cursor: number, options?: ScanCommandOptions): RedisCommandArguments$5;
type ScanRawReply = [string, Array<string>];
interface ScanReply {
    cursor: number;
    keys: Array<RedisCommandArgument$5>;
}
declare function transformReply$1R([cursor, keys]: ScanRawReply): ScanReply;

type SCAN_ScanCommandOptions = ScanCommandOptions;
type SCAN_ScanReply = ScanReply;
declare namespace SCAN {
  export { IS_READ_ONLY$Y as IS_READ_ONLY, type SCAN_ScanCommandOptions as ScanCommandOptions, type SCAN_ScanReply as ScanReply, transformArguments$2i as transformArguments, transformReply$1R as transformReply };
}

declare function transformArguments$2h(mode: 'YES' | 'SYNC' | 'NO'): Array<string>;
declare function transformReply$1Q(): string;

declare namespace SCRIPT_DEBUG {
  export { transformArguments$2h as transformArguments, transformReply$1Q as transformReply };
}

declare function transformArguments$2g(sha1: string | Array<string>): RedisCommandArguments$5;

declare namespace SCRIPT_EXISTS {
  export { transformArguments$2g as transformArguments, transformBooleanArrayReply$1 as transformReply };
}

declare function transformArguments$2f(mode?: 'ASYNC' | 'SYNC'): Array<string>;
declare function transformReply$1P(): string;

declare namespace SCRIPT_FLUSH {
  export { transformArguments$2f as transformArguments, transformReply$1P as transformReply };
}

declare function transformArguments$2e(): Array<string>;
declare function transformReply$1O(): string;

declare namespace SCRIPT_KILL {
  export { transformArguments$2e as transformArguments, transformReply$1O as transformReply };
}

declare function transformArguments$2d(script: string): Array<string>;
declare function transformReply$1N(): string;

declare namespace SCRIPT_LOAD {
  export { transformArguments$2d as transformArguments, transformReply$1N as transformReply };
}

declare function transformArguments$2c(mode?: 'NOSAVE' | 'SAVE'): Array<string>;
declare function transformReply$1M(): void;

declare namespace SHUTDOWN {
  export { transformArguments$2c as transformArguments, transformReply$1M as transformReply };
}

declare function transformArguments$2b(index1: number, index2: number): Array<string>;
declare function transformReply$1L(): string;

declare namespace SWAPDB {
  export { transformArguments$2b as transformArguments, transformReply$1L as transformReply };
}

declare function transformArguments$2a(): Array<string>;
interface TimeReply extends Date {
    microseconds: number;
}
declare function transformReply$1K(reply: [string, string]): TimeReply;

declare namespace TIME {
  export { transformArguments$2a as transformArguments, transformReply$1K as transformReply };
}

declare function transformArguments$29(): Array<string>;
declare function transformReply$1J(): string;

declare namespace UNWATCH {
  export { transformArguments$29 as transformArguments, transformReply$1J as transformReply };
}

declare const FIRST_KEY_INDEX$1v = 1;
declare function transformArguments$28(numberOfReplicas: number, timeout: number): Array<string>;
declare function transformReply$1I(): number;

declare namespace WAIT {
  export { FIRST_KEY_INDEX$1v as FIRST_KEY_INDEX, transformArguments$28 as transformArguments, transformReply$1I as transformReply };
}

declare const _default$1: {
    ACL_CAT: typeof ACL_CAT;
    aclCat: typeof ACL_CAT;
    ACL_DELUSER: typeof ACL_DELUSER;
    aclDelUser: typeof ACL_DELUSER;
    ACL_DRYRUN: typeof ACL_DRYRUN;
    aclDryRun: typeof ACL_DRYRUN;
    ACL_GENPASS: typeof ACL_GENPASS;
    aclGenPass: typeof ACL_GENPASS;
    ACL_GETUSER: typeof ACL_GETUSER;
    aclGetUser: typeof ACL_GETUSER;
    ACL_LIST: typeof ACL_LIST;
    aclList: typeof ACL_LIST;
    ACL_LOAD: typeof ACL_LOAD;
    aclLoad: typeof ACL_LOAD;
    ACL_LOG_RESET: typeof ACL_LOG_RESET;
    aclLogReset: typeof ACL_LOG_RESET;
    ACL_LOG: typeof ACL_LOG;
    aclLog: typeof ACL_LOG;
    ACL_SAVE: typeof ACL_SAVE;
    aclSave: typeof ACL_SAVE;
    ACL_SETUSER: typeof ACL_SETUSER;
    aclSetUser: typeof ACL_SETUSER;
    ACL_USERS: typeof ACL_USERS;
    aclUsers: typeof ACL_USERS;
    ACL_WHOAMI: typeof ACL_WHOAMI;
    aclWhoAmI: typeof ACL_WHOAMI;
    ASKING: typeof ASKING;
    asking: typeof ASKING;
    AUTH: typeof AUTH;
    auth: typeof AUTH;
    BGREWRITEAOF: typeof BGREWRITEAOF;
    bgRewriteAof: typeof BGREWRITEAOF;
    BGSAVE: typeof BGSAVE;
    bgSave: typeof BGSAVE;
    CLIENT_CACHING: typeof CLIENT_CACHING;
    clientCaching: typeof CLIENT_CACHING;
    CLIENT_GETNAME: typeof CLIENT_GETNAME;
    clientGetName: typeof CLIENT_GETNAME;
    CLIENT_GETREDIR: typeof CLIENT_GETREDIR;
    clientGetRedir: typeof CLIENT_GETREDIR;
    CLIENT_ID: typeof CLIENT_ID;
    clientId: typeof CLIENT_ID;
    CLIENT_KILL: typeof CLIENT_KILL;
    clientKill: typeof CLIENT_KILL;
    'CLIENT_NO-EVICT': typeof CLIENT_NO_EVICT;
    clientNoEvict: typeof CLIENT_NO_EVICT;
    'CLIENT_NO-TOUCH': typeof CLIENT_NO_TOUCH;
    clientNoTouch: typeof CLIENT_NO_TOUCH;
    CLIENT_LIST: typeof CLIENT_LIST;
    clientList: typeof CLIENT_LIST;
    CLIENT_PAUSE: typeof CLIENT_PAUSE;
    clientPause: typeof CLIENT_PAUSE;
    CLIENT_SETNAME: typeof CLIENT_SETNAME;
    clientSetName: typeof CLIENT_SETNAME;
    CLIENT_TRACKING: typeof CLIENT_TRACKING;
    clientTracking: typeof CLIENT_TRACKING;
    CLIENT_TRACKINGINFO: typeof CLIENT_TRACKINGINFO;
    clientTrackingInfo: typeof CLIENT_TRACKINGINFO;
    CLIENT_UNPAUSE: typeof CLIENT_UNPAUSE;
    clientUnpause: typeof CLIENT_UNPAUSE;
    CLIENT_INFO: typeof CLIENT_INFO;
    clientInfo: typeof CLIENT_INFO;
    CLUSTER_ADDSLOTS: typeof CLUSTER_ADDSLOTS;
    clusterAddSlots: typeof CLUSTER_ADDSLOTS;
    CLUSTER_ADDSLOTSRANGE: typeof CLUSTER_ADDSLOTSRANGE;
    clusterAddSlotsRange: typeof CLUSTER_ADDSLOTSRANGE;
    CLUSTER_BUMPEPOCH: typeof CLUSTER_BUMPEPOCH;
    clusterBumpEpoch: typeof CLUSTER_BUMPEPOCH;
    CLUSTER_COUNT_FAILURE_REPORTS: typeof CLUSTER_COUNT_FAILURE_REPORTS;
    clusterCountFailureReports: typeof CLUSTER_COUNT_FAILURE_REPORTS;
    CLUSTER_COUNTKEYSINSLOT: typeof CLUSTER_COUNTKEYSINSLOT;
    clusterCountKeysInSlot: typeof CLUSTER_COUNTKEYSINSLOT;
    CLUSTER_DELSLOTS: typeof CLUSTER_DELSLOTS;
    clusterDelSlots: typeof CLUSTER_DELSLOTS;
    CLUSTER_DELSLOTSRANGE: typeof CLUSTER_DELSLOTSRANGE;
    clusterDelSlotsRange: typeof CLUSTER_DELSLOTSRANGE;
    CLUSTER_FAILOVER: typeof CLUSTER_FAILOVER;
    clusterFailover: typeof CLUSTER_FAILOVER;
    CLUSTER_FLUSHSLOTS: typeof CLUSTER_FLUSHSLOTS;
    clusterFlushSlots: typeof CLUSTER_FLUSHSLOTS;
    CLUSTER_FORGET: typeof CLUSTER_FORGET;
    clusterForget: typeof CLUSTER_FORGET;
    CLUSTER_GETKEYSINSLOT: typeof CLUSTER_GETKEYSINSLOT;
    clusterGetKeysInSlot: typeof CLUSTER_GETKEYSINSLOT;
    CLUSTER_INFO: typeof CLUSTER_INFO;
    clusterInfo: typeof CLUSTER_INFO;
    CLUSTER_KEYSLOT: typeof CLUSTER_KEYSLOT;
    clusterKeySlot: typeof CLUSTER_KEYSLOT;
    CLUSTER_LINKS: typeof CLUSTER_LINKS;
    clusterLinks: typeof CLUSTER_LINKS;
    CLUSTER_MEET: typeof CLUSTER_MEET;
    clusterMeet: typeof CLUSTER_MEET;
    CLUSTER_MYID: typeof CLUSTER_MYID;
    clusterMyId: typeof CLUSTER_MYID;
    CLUSTER_MYSHARDID: typeof CLUSTER_MYSHARDID;
    clusterMyShardId: typeof CLUSTER_MYSHARDID;
    CLUSTER_NODES: typeof CLUSTER_NODES;
    clusterNodes: typeof CLUSTER_NODES;
    CLUSTER_REPLICAS: typeof CLUSTER_REPLICAS;
    clusterReplicas: typeof CLUSTER_REPLICAS;
    CLUSTER_REPLICATE: typeof CLUSTER_REPLICATE;
    clusterReplicate: typeof CLUSTER_REPLICATE;
    CLUSTER_RESET: typeof CLUSTER_RESET;
    clusterReset: typeof CLUSTER_RESET;
    CLUSTER_SAVECONFIG: typeof CLUSTER_SAVECONFIG;
    clusterSaveConfig: typeof CLUSTER_SAVECONFIG;
    CLUSTER_SET_CONFIG_EPOCH: typeof CLUSTER_SET_CONFIG_EPOCH;
    clusterSetConfigEpoch: typeof CLUSTER_SET_CONFIG_EPOCH;
    CLUSTER_SETSLOT: typeof CLUSTER_SETSLOT;
    clusterSetSlot: typeof CLUSTER_SETSLOT;
    CLUSTER_SLOTS: typeof CLUSTER_SLOTS;
    clusterSlots: typeof CLUSTER_SLOTS;
    COMMAND_COUNT: typeof COMMAND_COUNT;
    commandCount: typeof COMMAND_COUNT;
    COMMAND_GETKEYS: typeof COMMAND_GETKEYS;
    commandGetKeys: typeof COMMAND_GETKEYS;
    COMMAND_GETKEYSANDFLAGS: typeof COMMAND_GETKEYSANDFLAGS;
    commandGetKeysAndFlags: typeof COMMAND_GETKEYSANDFLAGS;
    COMMAND_INFO: typeof COMMAND_INFO;
    commandInfo: typeof COMMAND_INFO;
    COMMAND_LIST: typeof COMMAND_LIST;
    commandList: typeof COMMAND_LIST;
    COMMAND: typeof COMMAND;
    command: typeof COMMAND;
    CONFIG_GET: typeof CONFIG_GET;
    configGet: typeof CONFIG_GET;
    CONFIG_RESETASTAT: typeof CONFIG_RESETASTAT;
    configResetStat: typeof CONFIG_RESETASTAT;
    CONFIG_REWRITE: typeof CONFIG_REWRITE;
    configRewrite: typeof CONFIG_REWRITE;
    CONFIG_SET: typeof CONFIG_SET;
    configSet: typeof CONFIG_SET;
    DBSIZE: typeof DBSIZE;
    dbSize: typeof DBSIZE;
    DISCARD: typeof DISCARD;
    discard: typeof DISCARD;
    ECHO: typeof ECHO;
    echo: typeof ECHO;
    FAILOVER: typeof FAILOVER;
    failover: typeof FAILOVER;
    FLUSHALL: typeof FLUSHALL;
    flushAll: typeof FLUSHALL;
    FLUSHDB: typeof FLUSHDB;
    flushDb: typeof FLUSHDB;
    FUNCTION_DELETE: typeof FUNCTION_DELETE;
    functionDelete: typeof FUNCTION_DELETE;
    FUNCTION_DUMP: typeof FUNCTION_DUMP;
    functionDump: typeof FUNCTION_DUMP;
    FUNCTION_FLUSH: typeof FUNCTION_FLUSH;
    functionFlush: typeof FUNCTION_FLUSH;
    FUNCTION_KILL: typeof FUNCTION_KILL;
    functionKill: typeof FUNCTION_KILL;
    FUNCTION_LIST_WITHCODE: typeof FUNCTION_LIST_WITHCODE;
    functionListWithCode: typeof FUNCTION_LIST_WITHCODE;
    FUNCTION_LIST: typeof FUNCTION_LIST;
    functionList: typeof FUNCTION_LIST;
    FUNCTION_LOAD: typeof FUNCTION_LOAD;
    functionLoad: typeof FUNCTION_LOAD;
    FUNCTION_RESTORE: typeof FUNCTION_RESTORE;
    functionRestore: typeof FUNCTION_RESTORE;
    FUNCTION_STATS: typeof FUNCTION_STATS;
    functionStats: typeof FUNCTION_STATS;
    HELLO: typeof HELLO;
    hello: typeof HELLO;
    INFO: typeof INFO;
    info: typeof INFO;
    KEYS: typeof KEYS;
    keys: typeof KEYS;
    LASTSAVE: typeof LASTSAVE;
    lastSave: typeof LASTSAVE;
    LATENCY_DOCTOR: typeof LATENCY_DOCTOR;
    latencyDoctor: typeof LATENCY_DOCTOR;
    LATENCY_GRAPH: typeof LATENCY_GRAPH;
    latencyGraph: typeof LATENCY_GRAPH;
    LATENCY_HISTORY: typeof LATENCY_HISTORY;
    latencyHistory: typeof LATENCY_HISTORY;
    LATENCY_LATEST: typeof LATENCY_LATEST;
    latencyLatest: typeof LATENCY_LATEST;
    LOLWUT: typeof LOLWUT;
    lolwut: typeof LOLWUT;
    MEMORY_DOCTOR: typeof MEMORY_DOCTOR;
    memoryDoctor: typeof MEMORY_DOCTOR;
    'MEMORY_MALLOC-STATS': typeof MEMORY_MALLOC_STATS;
    memoryMallocStats: typeof MEMORY_MALLOC_STATS;
    MEMORY_PURGE: typeof MEMORY_PURGE;
    memoryPurge: typeof MEMORY_PURGE;
    MEMORY_STATS: typeof MEMORY_STATS;
    memoryStats: typeof MEMORY_STATS;
    MEMORY_USAGE: typeof MEMORY_USAGE;
    memoryUsage: typeof MEMORY_USAGE;
    MODULE_LIST: typeof MODULE_LIST;
    moduleList: typeof MODULE_LIST;
    MODULE_LOAD: typeof MODULE_LOAD;
    moduleLoad: typeof MODULE_LOAD;
    MODULE_UNLOAD: typeof MODULE_UNLOAD;
    moduleUnload: typeof MODULE_UNLOAD;
    MOVE: typeof MOVE;
    move: typeof MOVE;
    PING: typeof PING;
    ping: typeof PING;
    PUBSUB_CHANNELS: typeof PUBSUB_CHANNELS;
    pubSubChannels: typeof PUBSUB_CHANNELS;
    PUBSUB_NUMPAT: typeof PUBSUB_NUMPAT;
    pubSubNumPat: typeof PUBSUB_NUMPAT;
    PUBSUB_NUMSUB: typeof PUBSUB_NUMSUB;
    pubSubNumSub: typeof PUBSUB_NUMSUB;
    PUBSUB_SHARDCHANNELS: typeof PUBSUB_SHARDCHANNELS;
    pubSubShardChannels: typeof PUBSUB_SHARDCHANNELS;
    PUBSUB_SHARDNUMSUB: typeof PUBSUB_SHARDNUMSUB;
    pubSubShardNumSub: typeof PUBSUB_SHARDNUMSUB;
    RANDOMKEY: typeof RANDOMKEY;
    randomKey: typeof RANDOMKEY;
    READONLY: typeof READONLY;
    readonly: typeof READONLY;
    READWRITE: typeof READWRITE;
    readwrite: typeof READWRITE;
    REPLICAOF: typeof REPLICAOF;
    replicaOf: typeof REPLICAOF;
    'RESTORE-ASKING': typeof RESTORE_ASKING;
    restoreAsking: typeof RESTORE_ASKING;
    ROLE: typeof ROLE;
    role: typeof ROLE;
    SAVE: typeof SAVE;
    save: typeof SAVE;
    SCAN: typeof SCAN;
    scan: typeof SCAN;
    SCRIPT_DEBUG: typeof SCRIPT_DEBUG;
    scriptDebug: typeof SCRIPT_DEBUG;
    SCRIPT_EXISTS: typeof SCRIPT_EXISTS;
    scriptExists: typeof SCRIPT_EXISTS;
    SCRIPT_FLUSH: typeof SCRIPT_FLUSH;
    scriptFlush: typeof SCRIPT_FLUSH;
    SCRIPT_KILL: typeof SCRIPT_KILL;
    scriptKill: typeof SCRIPT_KILL;
    SCRIPT_LOAD: typeof SCRIPT_LOAD;
    scriptLoad: typeof SCRIPT_LOAD;
    SHUTDOWN: typeof SHUTDOWN;
    shutdown: typeof SHUTDOWN;
    SWAPDB: typeof SWAPDB;
    swapDb: typeof SWAPDB;
    TIME: typeof TIME;
    time: typeof TIME;
    UNWATCH: typeof UNWATCH;
    unwatch: typeof UNWATCH;
    WAIT: typeof WAIT;
    wait: typeof WAIT;
    APPEND: typeof APPEND;
    append: typeof APPEND;
    BITCOUNT: typeof BITCOUNT;
    bitCount: typeof BITCOUNT;
    BITFIELD_RO: typeof BITFIELD_RO;
    bitFieldRo: typeof BITFIELD_RO;
    BITFIELD: typeof BITFIELD;
    bitField: typeof BITFIELD;
    BITOP: typeof BITOP;
    bitOp: typeof BITOP;
    BITPOS: typeof BITPOS;
    bitPos: typeof BITPOS;
    BLMOVE: typeof BLMOVE;
    blMove: typeof BLMOVE;
    BLMPOP: typeof BLMPOP;
    blmPop: typeof BLMPOP;
    BLPOP: typeof BLPOP;
    blPop: typeof BLPOP;
    BRPOP: typeof BRPOP;
    brPop: typeof BRPOP;
    BRPOPLPUSH: typeof BRPOPLPUSH;
    brPopLPush: typeof BRPOPLPUSH;
    BZMPOP: typeof BZMPOP;
    bzmPop: typeof BZMPOP;
    BZPOPMAX: typeof BZPOPMAX;
    bzPopMax: typeof BZPOPMAX;
    BZPOPMIN: typeof BZPOPMIN;
    bzPopMin: typeof BZPOPMIN;
    COPY: typeof COPY;
    copy: typeof COPY;
    DECR: typeof DECR;
    decr: typeof DECR;
    DECRBY: typeof DECRBY;
    decrBy: typeof DECRBY;
    DEL: typeof DEL;
    del: typeof DEL;
    DUMP: typeof DUMP;
    dump: typeof DUMP;
    EVAL_RO: typeof EVAL_RO;
    evalRo: typeof EVAL_RO;
    EVAL: typeof EVAL;
    eval: typeof EVAL;
    EVALSHA: typeof EVALSHA;
    evalSha: typeof EVALSHA;
    EVALSHA_RO: typeof EVALSHA_RO;
    evalShaRo: typeof EVALSHA_RO;
    EXISTS: typeof EXISTS;
    exists: typeof EXISTS;
    EXPIRE: typeof EXPIRE;
    expire: typeof EXPIRE;
    EXPIREAT: typeof EXPIREAT;
    expireAt: typeof EXPIREAT;
    EXPIRETIME: typeof EXPIRETIME;
    expireTime: typeof EXPIRETIME;
    FCALL_RO: typeof FCALL_RO;
    fCallRo: typeof FCALL_RO;
    FCALL: typeof FCALL;
    fCall: typeof FCALL;
    GEOADD: typeof GEOADD;
    geoAdd: typeof GEOADD;
    GEODIST: typeof GEODIST;
    geoDist: typeof GEODIST;
    GEOHASH: typeof GEOHASH;
    geoHash: typeof GEOHASH;
    GEOPOS: typeof GEOPOS;
    geoPos: typeof GEOPOS;
    GEORADIUS_RO_WITH: typeof GEORADIUS_RO_WITH;
    geoRadiusRoWith: typeof GEORADIUS_RO_WITH;
    GEORADIUS_RO: typeof GEORADIUS_RO;
    geoRadiusRo: typeof GEORADIUS_RO;
    GEORADIUS_WITH: typeof GEORADIUS_WITH;
    geoRadiusWith: typeof GEORADIUS_WITH;
    GEORADIUS: typeof GEORADIUS;
    geoRadius: typeof GEORADIUS;
    GEORADIUSBYMEMBER_RO_WITH: typeof GEORADIUSBYMEMBER_RO_WITH;
    geoRadiusByMemberRoWith: typeof GEORADIUSBYMEMBER_RO_WITH;
    GEORADIUSBYMEMBER_RO: typeof GEORADIUSBYMEMBER_RO;
    geoRadiusByMemberRo: typeof GEORADIUSBYMEMBER_RO;
    GEORADIUSBYMEMBER_WITH: typeof GEORADIUSBYMEMBER_WITH;
    geoRadiusByMemberWith: typeof GEORADIUSBYMEMBER_WITH;
    GEORADIUSBYMEMBER: typeof GEORADIUSBYMEMBER;
    geoRadiusByMember: typeof GEORADIUSBYMEMBER;
    GEORADIUSBYMEMBERSTORE: typeof GEORADIUSBYMEMBERSTORE;
    geoRadiusByMemberStore: typeof GEORADIUSBYMEMBERSTORE;
    GEORADIUSSTORE: typeof GEORADIUSSTORE;
    geoRadiusStore: typeof GEORADIUSSTORE;
    GEOSEARCH_WITH: typeof GEOSEARCH_WITH;
    geoSearchWith: typeof GEOSEARCH_WITH;
    GEOSEARCH: typeof GEOSEARCH;
    geoSearch: typeof GEOSEARCH;
    GEOSEARCHSTORE: typeof GEOSEARCHSTORE;
    geoSearchStore: typeof GEOSEARCHSTORE;
    GET: typeof GET;
    get: typeof GET;
    GETBIT: typeof GETBIT;
    getBit: typeof GETBIT;
    GETDEL: typeof GETDEL;
    getDel: typeof GETDEL;
    GETEX: typeof GETEX;
    getEx: typeof GETEX;
    GETRANGE: typeof GETRANGE;
    getRange: typeof GETRANGE;
    GETSET: typeof GETSET;
    getSet: typeof GETSET;
    HDEL: typeof HDEL;
    hDel: typeof HDEL;
    HEXISTS: typeof HEXISTS;
    hExists: typeof HEXISTS;
    HEXPIRE: typeof HEXPIRE;
    hExpire: typeof HEXPIRE;
    HEXPIREAT: typeof HEXPIREAT;
    hExpireAt: typeof HEXPIREAT;
    HEXPIRETIME: typeof HEXPIRETIME;
    hExpireTime: typeof HEXPIRETIME;
    HGET: typeof HGET;
    hGet: typeof HGET;
    HGETALL: typeof HGETALL;
    hGetAll: typeof HGETALL;
    HINCRBY: typeof HINCRBY;
    hIncrBy: typeof HINCRBY;
    HINCRBYFLOAT: typeof HINCRBYFLOAT;
    hIncrByFloat: typeof HINCRBYFLOAT;
    HKEYS: typeof HKEYS;
    hKeys: typeof HKEYS;
    HLEN: typeof HLEN;
    hLen: typeof HLEN;
    HMGET: typeof HMGET;
    hmGet: typeof HMGET;
    HPERSIST: typeof HPERSIST;
    hPersist: typeof HPERSIST;
    HPEXPIRE: typeof HPEXPIRE;
    hpExpire: typeof HPEXPIRE;
    HPEXPIREAT: typeof HPEXPIREAT;
    hpExpireAt: typeof HPEXPIREAT;
    HPEXPIRETIME: typeof HPEXPIRETIME;
    hpExpireTime: typeof HPEXPIRETIME;
    HPTTL: typeof HPTTL;
    hpTTL: typeof HPTTL;
    HRANDFIELD_COUNT_WITHVALUES: typeof HRANDFIELD_COUNT_WITHVALUES;
    hRandFieldCountWithValues: typeof HRANDFIELD_COUNT_WITHVALUES;
    HRANDFIELD_COUNT: typeof HRANDFIELD_COUNT;
    hRandFieldCount: typeof HRANDFIELD_COUNT;
    HRANDFIELD: typeof HRANDFIELD;
    hRandField: typeof HRANDFIELD;
    HSCAN: typeof HSCAN;
    hScan: typeof HSCAN;
    HSCAN_NOVALUES: typeof HSCAN_NOVALUES;
    hScanNoValues: typeof HSCAN_NOVALUES;
    HSET: typeof HSET;
    hSet: typeof HSET;
    HSETNX: typeof HSETNX;
    hSetNX: typeof HSETNX;
    HSTRLEN: typeof HSTRLEN;
    hStrLen: typeof HSTRLEN;
    HTTL: typeof HTTL;
    hTTL: typeof HTTL;
    HVALS: typeof HVALS;
    hVals: typeof HVALS;
    INCR: typeof INCR;
    incr: typeof INCR;
    INCRBY: typeof INCRBY;
    incrBy: typeof INCRBY;
    INCRBYFLOAT: typeof INCRBYFLOAT;
    incrByFloat: typeof INCRBYFLOAT;
    LCS_IDX_WITHMATCHLEN: typeof LCS_IDX_WITHMATCHLEN;
    lcsIdxWithMatchLen: typeof LCS_IDX_WITHMATCHLEN;
    LCS_IDX: typeof LCS_IDX;
    lcsIdx: typeof LCS_IDX;
    LCS_LEN: typeof LCS_LEN;
    lcsLen: typeof LCS_LEN;
    LCS: typeof LCS;
    lcs: typeof LCS;
    LINDEX: typeof LINDEX;
    lIndex: typeof LINDEX;
    LINSERT: typeof LINSERT;
    lInsert: typeof LINSERT;
    LLEN: typeof LLEN;
    lLen: typeof LLEN;
    LMOVE: typeof LMOVE;
    lMove: typeof LMOVE;
    LMPOP: typeof LMPOP;
    lmPop: typeof LMPOP;
    LPOP_COUNT: typeof LPOP_COUNT;
    lPopCount: typeof LPOP_COUNT;
    LPOP: typeof LPOP;
    lPop: typeof LPOP;
    LPOS_COUNT: typeof LPOS_COUNT;
    lPosCount: typeof LPOS_COUNT;
    LPOS: typeof LPOS;
    lPos: typeof LPOS;
    LPUSH: typeof LPUSH;
    lPush: typeof LPUSH;
    LPUSHX: typeof LPUSHX;
    lPushX: typeof LPUSHX;
    LRANGE: typeof LRANGE;
    lRange: typeof LRANGE;
    LREM: typeof LREM;
    lRem: typeof LREM;
    LSET: typeof LSET;
    lSet: typeof LSET;
    LTRIM: typeof LTRIM;
    lTrim: typeof LTRIM;
    MGET: typeof MGET;
    mGet: typeof MGET;
    MIGRATE: typeof MIGRATE;
    migrate: typeof MIGRATE;
    MSET: typeof MSET;
    mSet: typeof MSET;
    MSETNX: typeof MSETNX;
    mSetNX: typeof MSETNX;
    OBJECT_ENCODING: typeof OBJECT_ENCODING;
    objectEncoding: typeof OBJECT_ENCODING;
    OBJECT_FREQ: typeof OBJECT_FREQ;
    objectFreq: typeof OBJECT_FREQ;
    OBJECT_IDLETIME: typeof OBJECT_IDLETIME;
    objectIdleTime: typeof OBJECT_IDLETIME;
    OBJECT_REFCOUNT: typeof OBJECT_REFCOUNT;
    objectRefCount: typeof OBJECT_REFCOUNT;
    PERSIST: typeof PERSIST;
    persist: typeof PERSIST;
    PEXPIRE: typeof PEXPIRE;
    pExpire: typeof PEXPIRE;
    PEXPIREAT: typeof PEXPIREAT;
    pExpireAt: typeof PEXPIREAT;
    PEXPIRETIME: typeof PEXPIRETIME;
    pExpireTime: typeof PEXPIRETIME;
    PFADD: typeof PFADD;
    pfAdd: typeof PFADD;
    PFCOUNT: typeof PFCOUNT;
    pfCount: typeof PFCOUNT;
    PFMERGE: typeof PFMERGE;
    pfMerge: typeof PFMERGE;
    PSETEX: typeof PSETEX;
    pSetEx: typeof PSETEX;
    PTTL: typeof PTTL;
    pTTL: typeof PTTL;
    PUBLISH: typeof PUBLISH;
    publish: typeof PUBLISH;
    RENAME: typeof RENAME;
    rename: typeof RENAME;
    RENAMENX: typeof RENAMENX;
    renameNX: typeof RENAMENX;
    RESTORE: typeof RESTORE;
    restore: typeof RESTORE;
    RPOP_COUNT: typeof RPOP_COUNT;
    rPopCount: typeof RPOP_COUNT;
    RPOP: typeof RPOP;
    rPop: typeof RPOP;
    RPOPLPUSH: typeof RPOPLPUSH;
    rPopLPush: typeof RPOPLPUSH;
    RPUSH: typeof RPUSH;
    rPush: typeof RPUSH;
    RPUSHX: typeof RPUSHX;
    rPushX: typeof RPUSHX;
    SADD: typeof SADD;
    sAdd: typeof SADD;
    SCARD: typeof SCARD;
    sCard: typeof SCARD;
    SDIFF: typeof SDIFF;
    sDiff: typeof SDIFF;
    SDIFFSTORE: typeof SDIFFSTORE;
    sDiffStore: typeof SDIFFSTORE;
    SINTER: typeof SINTER;
    sInter: typeof SINTER;
    SINTERCARD: typeof SINTERCARD;
    sInterCard: typeof SINTERCARD;
    SINTERSTORE: typeof SINTERSTORE;
    sInterStore: typeof SINTERSTORE;
    SET: typeof SET;
    set: typeof SET;
    SETBIT: typeof SETBIT;
    setBit: typeof SETBIT;
    SETEX: typeof SETEX;
    setEx: typeof SETEX;
    SETNX: typeof SETNX;
    setNX: typeof SETNX;
    SETRANGE: typeof SETRANGE;
    setRange: typeof SETRANGE;
    SISMEMBER: typeof SISMEMBER;
    sIsMember: typeof SISMEMBER;
    SMEMBERS: typeof SMEMBERS;
    sMembers: typeof SMEMBERS;
    SMISMEMBER: typeof SMISMEMBER;
    smIsMember: typeof SMISMEMBER;
    SMOVE: typeof SMOVE;
    sMove: typeof SMOVE;
    SORT_RO: typeof SORT_RO;
    sortRo: typeof SORT_RO;
    SORT_STORE: typeof SORT_STORE;
    sortStore: typeof SORT_STORE;
    SORT: typeof SORT;
    sort: typeof SORT;
    SPOP: typeof SPOP;
    sPop: typeof SPOP;
    SPUBLISH: typeof SPUBLISH;
    sPublish: typeof SPUBLISH;
    SRANDMEMBER_COUNT: typeof SRANDMEMBER_COUNT;
    sRandMemberCount: typeof SRANDMEMBER_COUNT;
    SRANDMEMBER: typeof SRANDMEMBER;
    sRandMember: typeof SRANDMEMBER;
    SREM: typeof SREM;
    sRem: typeof SREM;
    SSCAN: typeof SSCAN;
    sScan: typeof SSCAN;
    STRLEN: typeof STRLEN;
    strLen: typeof STRLEN;
    SUNION: typeof SUNION;
    sUnion: typeof SUNION;
    SUNIONSTORE: typeof SUNIONSTORE;
    sUnionStore: typeof SUNIONSTORE;
    TOUCH: typeof TOUCH;
    touch: typeof TOUCH;
    TTL: typeof TTL;
    ttl: typeof TTL;
    TYPE: typeof TYPE;
    type: typeof TYPE;
    UNLINK: typeof UNLINK;
    unlink: typeof UNLINK;
    WATCH: typeof WATCH;
    watch: typeof WATCH;
    XACK: typeof XACK;
    xAck: typeof XACK;
    XADD: typeof XADD;
    xAdd: typeof XADD;
    XAUTOCLAIM_JUSTID: typeof XAUTOCLAIM_JUSTID;
    xAutoClaimJustId: typeof XAUTOCLAIM_JUSTID;
    XAUTOCLAIM: typeof XAUTOCLAIM;
    xAutoClaim: typeof XAUTOCLAIM;
    XCLAIM: typeof XCLAIM;
    xClaim: typeof XCLAIM;
    XCLAIM_JUSTID: typeof XCLAIM_JUSTID;
    xClaimJustId: typeof XCLAIM_JUSTID;
    XDEL: typeof XDEL;
    xDel: typeof XDEL;
    XGROUP_CREATE: typeof XGROUP_CREATE;
    xGroupCreate: typeof XGROUP_CREATE;
    XGROUP_CREATECONSUMER: typeof XGROUP_CREATECONSUMER;
    xGroupCreateConsumer: typeof XGROUP_CREATECONSUMER;
    XGROUP_DELCONSUMER: typeof XGROUP_DELCONSUMER;
    xGroupDelConsumer: typeof XGROUP_DELCONSUMER;
    XGROUP_DESTROY: typeof XGROUP_DESTROY;
    xGroupDestroy: typeof XGROUP_DESTROY;
    XGROUP_SETID: typeof XGROUP_SETID;
    xGroupSetId: typeof XGROUP_SETID;
    XINFO_CONSUMERS: typeof XINFO_CONSUMERS;
    xInfoConsumers: typeof XINFO_CONSUMERS;
    XINFO_GROUPS: typeof XINFO_GROUPS;
    xInfoGroups: typeof XINFO_GROUPS;
    XINFO_STREAM: typeof XINFO_STREAM;
    xInfoStream: typeof XINFO_STREAM;
    XLEN: typeof XLEN;
    xLen: typeof XLEN;
    XPENDING_RANGE: typeof XPENDING_RANGE;
    xPendingRange: typeof XPENDING_RANGE;
    XPENDING: typeof XPENDING;
    xPending: typeof XPENDING;
    XRANGE: typeof XRANGE;
    xRange: typeof XRANGE;
    XREAD: typeof XREAD;
    xRead: typeof XREAD;
    XREADGROUP: typeof XREADGROUP;
    xReadGroup: typeof XREADGROUP;
    XREVRANGE: typeof XREVRANGE;
    xRevRange: typeof XREVRANGE;
    XSETID: typeof XSETID;
    xSetId: typeof XSETID;
    XTRIM: typeof XTRIM;
    xTrim: typeof XTRIM;
    ZADD: typeof ZADD;
    zAdd: typeof ZADD;
    ZCARD: typeof ZCARD;
    zCard: typeof ZCARD;
    ZCOUNT: typeof ZCOUNT;
    zCount: typeof ZCOUNT;
    ZDIFF_WITHSCORES: typeof ZDIFF_WITHSCORES;
    zDiffWithScores: typeof ZDIFF_WITHSCORES;
    ZDIFF: typeof ZDIFF;
    zDiff: typeof ZDIFF;
    ZDIFFSTORE: typeof ZDIFFSTORE;
    zDiffStore: typeof ZDIFFSTORE;
    ZINCRBY: typeof ZINCRBY;
    zIncrBy: typeof ZINCRBY;
    ZINTER_WITHSCORES: typeof ZINTER_WITHSCORES;
    zInterWithScores: typeof ZINTER_WITHSCORES;
    ZINTER: typeof ZINTER;
    zInter: typeof ZINTER;
    ZINTERCARD: typeof ZINTERCARD;
    zInterCard: typeof ZINTERCARD;
    ZINTERSTORE: typeof ZINTERSTORE;
    zInterStore: typeof ZINTERSTORE;
    ZLEXCOUNT: typeof ZLEXCOUNT;
    zLexCount: typeof ZLEXCOUNT;
    ZMPOP: typeof ZMPOP;
    zmPop: typeof ZMPOP;
    ZMSCORE: typeof ZMSCORE;
    zmScore: typeof ZMSCORE;
    ZPOPMAX_COUNT: typeof ZPOPMAX_COUNT;
    zPopMaxCount: typeof ZPOPMAX_COUNT;
    ZPOPMAX: typeof ZPOPMAX;
    zPopMax: typeof ZPOPMAX;
    ZPOPMIN_COUNT: typeof ZPOPMIN_COUNT;
    zPopMinCount: typeof ZPOPMIN_COUNT;
    ZPOPMIN: typeof ZPOPMIN;
    zPopMin: typeof ZPOPMIN;
    ZRANDMEMBER_COUNT_WITHSCORES: typeof ZRANDMEMBER_COUNT_WITHSCORES;
    zRandMemberCountWithScores: typeof ZRANDMEMBER_COUNT_WITHSCORES;
    ZRANDMEMBER_COUNT: typeof ZRANDMEMBER_COUNT;
    zRandMemberCount: typeof ZRANDMEMBER_COUNT;
    ZRANDMEMBER: typeof ZRANDMEMBER;
    zRandMember: typeof ZRANDMEMBER;
    ZRANGE_WITHSCORES: typeof ZRANGE_WITHSCORES;
    zRangeWithScores: typeof ZRANGE_WITHSCORES;
    ZRANGE: typeof ZRANGE;
    zRange: typeof ZRANGE;
    ZRANGEBYLEX: typeof ZRANGEBYLEX;
    zRangeByLex: typeof ZRANGEBYLEX;
    ZRANGEBYSCORE_WITHSCORES: typeof ZRANGEBYSCORE_WITHSCORES;
    zRangeByScoreWithScores: typeof ZRANGEBYSCORE_WITHSCORES;
    ZRANGEBYSCORE: typeof ZRANGEBYSCORE;
    zRangeByScore: typeof ZRANGEBYSCORE;
    ZRANGESTORE: typeof ZRANGESTORE;
    zRangeStore: typeof ZRANGESTORE;
    ZRANK: typeof ZRANK;
    zRank: typeof ZRANK;
    ZREM: typeof ZREM;
    zRem: typeof ZREM;
    ZREMRANGEBYLEX: typeof ZREMRANGEBYLEX;
    zRemRangeByLex: typeof ZREMRANGEBYLEX;
    ZREMRANGEBYRANK: typeof ZREMRANGEBYRANK;
    zRemRangeByRank: typeof ZREMRANGEBYRANK;
    ZREMRANGEBYSCORE: typeof ZREMRANGEBYSCORE;
    zRemRangeByScore: typeof ZREMRANGEBYSCORE;
    ZREVRANK: typeof ZREVRANK;
    zRevRank: typeof ZREVRANK;
    ZSCAN: typeof ZSCAN;
    zScan: typeof ZSCAN;
    ZSCORE: typeof ZSCORE;
    zScore: typeof ZSCORE;
    ZUNION_WITHSCORES: typeof ZUNION_WITHSCORES;
    zUnionWithScores: typeof ZUNION_WITHSCORES;
    ZUNION: typeof ZUNION;
    zUnion: typeof ZUNION;
    ZUNIONSTORE: typeof ZUNIONSTORE;
    zUnionStore: typeof ZUNIONSTORE;
};

interface RedisSocketCommonOptions {
    /**
     * Connection Timeout (in milliseconds)
     */
    connectTimeout?: number;
    /**
     * Toggle [`Nagle's algorithm`](https://nodejs.org/api/net.html#net_socket_setnodelay_nodelay)
     */
    noDelay?: boolean;
    /**
     * Toggle [`keep-alive`](https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay)
     */
    keepAlive?: number | false;
    /**
     * When the socket closes unexpectedly (without calling `.quit()`/`.disconnect()`), the client uses `reconnectStrategy` to decide what to do. The following values are supported:
     * 1. `false` -> do not reconnect, close the client and flush the command queue.
     * 2. `number` -> wait for `X` milliseconds before reconnecting.
     * 3. `(retries: number, cause: Error) => false | number | Error` -> `number` is the same as configuring a `number` directly, `Error` is the same as `false`, but with a custom error.
     * Defaults to `retries => Math.min(retries * 50, 500)`
     */
    reconnectStrategy?: false | number | ((retries: number, cause: Error) => false | Error | number);
}
type RedisNetSocketOptions = Partial<net.SocketConnectOpts> & {
    tls?: false;
};
interface RedisTlsSocketOptions extends tls.ConnectionOptions {
    tls: true;
}
type RedisSocketOptions = RedisSocketCommonOptions & (RedisNetSocketOptions | RedisTlsSocketOptions);

declare enum PubSubType {
    CHANNELS = "CHANNELS",
    PATTERNS = "PATTERNS",
    SHARDED = "SHARDED"
}
type PubSubListener<RETURN_BUFFERS extends boolean = false> = <T extends RETURN_BUFFERS extends true ? Buffer : string>(message: T, channel: T) => unknown;
interface ChannelListeners {
    unsubscribing: boolean;
    buffers: Set<PubSubListener<true>>;
    strings: Set<PubSubListener<false>>;
}
type PubSubTypeListeners = Map<string, ChannelListeners>;

interface QueueCommandOptions {
    asap?: boolean;
    chainId?: symbol;
    signal?: AbortSignal;
    returnBuffers?: boolean;
}

declare class AbortError$1 extends Error {
    constructor();
}
declare class WatchError$1 extends Error {
    constructor();
}
declare class ConnectionTimeoutError$1 extends Error {
    constructor();
}
declare class ClientClosedError$1 extends Error {
    constructor();
}
declare class ClientOfflineError$1 extends Error {
    constructor();
}
declare class DisconnectsClientError$1 extends Error {
    constructor();
}
declare class SocketClosedUnexpectedlyError$1 extends Error {
    constructor();
}
declare class RootNodesUnavailableError$1 extends Error {
    constructor();
}
declare class ReconnectStrategyError$1 extends Error {
    originalError: Error;
    socketError: unknown;
    constructor(originalError: Error, socketError: unknown);
}
declare class ErrorReply$1 extends Error {
    constructor(message: string);
}
declare class MultiErrorReply$1 extends ErrorReply$1 {
    replies: (RedisCommandRawReply | ErrorReply$1)[];
    errorIndexes: number[];
    constructor(replies: Array<RedisCommandRawReply | ErrorReply$1>, errorIndexes: Array<number>);
    errors(): Generator<RedisCommandRawReply | ErrorReply$1, void, unknown>;
}

interface RedisMultiQueuedCommand {
    args: RedisCommandArguments$5;
    transformReply?: RedisCommand$1['transformReply'];
}

type CommandSignature<C extends RedisCommand$1, M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = (...args: Parameters<C['transformArguments']>) => RedisClientMultiCommandType<M, F, S>;
type WithCommands$4<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof typeof _default$1]: CommandSignature<(typeof _default$1)[P], M, F, S>;
};
type WithModules$3<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof M as ExcludeMappedString<P>]: {
        [C in keyof M[P] as ExcludeMappedString<C>]: CommandSignature<M[P][C], M, F, S>;
    };
};
type WithFunctions$3<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof F as ExcludeMappedString<P>]: {
        [FF in keyof F[P] as ExcludeMappedString<FF>]: CommandSignature<F[P][FF], M, F, S>;
    };
};
type WithScripts$3<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof S as ExcludeMappedString<P>]: CommandSignature<S[P], M, F, S>;
};
type RedisClientMultiCommandType<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = RedisClientMultiCommand & WithCommands$4<M, F, S> & WithModules$3<M, F, S> & WithFunctions$3<M, F, S> & WithScripts$3<M, F, S>;
type InstantiableRedisMultiCommand<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = new (...args: ConstructorParameters<typeof RedisClientMultiCommand>) => RedisClientMultiCommandType<M, F, S>;
type RedisClientMultiExecutor = (queue: Array<RedisMultiQueuedCommand>, selectedDB?: number, chainId?: symbol) => Promise<Array<RedisCommandRawReply>>;
declare class RedisClientMultiCommand {
    #private;
    static extend<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(extensions?: RedisExtensions<M, F, S>): InstantiableRedisMultiCommand<M, F, S>;
    readonly v4: Record<string, any>;
    constructor(executor: RedisClientMultiExecutor, legacyMode?: boolean);
    commandsExecutor(command: RedisCommand$1, args: Array<unknown>): this;
    SELECT(db: number, transformReply?: RedisCommand$1['transformReply']): this;
    select: (db: number, transformReply?: RedisCommand$1['transformReply']) => this;
    addCommand(args: RedisCommandArguments$5, transformReply?: RedisCommand$1['transformReply']): this;
    functionsExecutor(fn: RedisFunction$1, args: Array<unknown>, name: string): this;
    scriptsExecutor(script: RedisScript$1, args: Array<unknown>): this;
    exec(execAsPipeline?: boolean): Promise<Array<RedisCommandRawReply>>;
    EXEC: (execAsPipeline?: boolean) => Promise<Array<RedisCommandRawReply>>;
    execAsPipeline(): Promise<Array<RedisCommandRawReply>>;
}

// Type definitions for node-pool 3.1
// Derived from https://github.com/DefinitelyTyped/DefinitelyTyped
// -> https://github.com/DefinitelyTyped/DefinitelyTyped/blob/454dcbcbe5e932010b128dca9793758dd28adb45/types/generic-pool/index.d.ts



interface Options {
    max?: number;
    min?: number;
    maxWaitingClients?: number;
    testOnBorrow?: boolean;
    testOnReturn?: boolean;
    acquireTimeoutMillis?: number;
    fifo?: boolean;
    priorityRange?: number;
    autostart?: boolean;
    evictionRunIntervalMillis?: number;
    numTestsPerEvictionRun?: number;
    softIdleTimeoutMillis?: number;
    idleTimeoutMillis?: number;
}

interface RedisClientOptions$1<M extends RedisModules = RedisModules, F extends RedisFunctions$1 = RedisFunctions$1, S extends RedisScripts$1 = RedisScripts$1> extends RedisExtensions<M, F, S> {
    /**
     * `redis[s]://[[username][:password]@][host][:port][/db-number]`
     * See [`redis`](https://www.iana.org/assignments/uri-schemes/prov/redis) and [`rediss`](https://www.iana.org/assignments/uri-schemes/prov/rediss) IANA registration for more details
     */
    url?: string;
    /**
     * Socket connection properties
     */
    socket?: RedisSocketOptions;
    /**
     * ACL username ([see ACL guide](https://redis.io/topics/acl))
     */
    username?: string;
    /**
     * ACL password or the old "--requirepass" password
     */
    password?: string;
    /**
     * Client name ([see `CLIENT SETNAME`](https://redis.io/commands/client-setname))
     */
    name?: string;
    /**
     * Redis database number (see [`SELECT`](https://redis.io/commands/select) command)
     */
    database?: number;
    /**
     * Maximum length of the client's internal command queue
     */
    commandsQueueMaxLength?: number;
    /**
     * When `true`, commands are rejected when the client is reconnecting.
     * When `false`, commands are queued for execution after reconnection.
     */
    disableOfflineQueue?: boolean;
    /**
     * Connect in [`READONLY`](https://redis.io/commands/readonly) mode
     */
    readonly?: boolean;
    legacyMode?: boolean;
    isolationPoolOptions?: Options;
    /**
     * Send `PING` command at interval (in ms).
     * Useful with Redis deployments that do not use TCP Keep-Alive.
     */
    pingInterval?: number;
    /**
     * If set to true, disables sending client identifier (user-agent like message) to the redis server
     */
    disableClientInfo?: boolean;
    /**
     * Tag to append to library name that is sent to the Redis server
     */
    clientInfoTag?: string;
}
type WithCommands$3 = {
    [P in keyof typeof _default$1]: RedisCommandSignature<(typeof _default$1)[P]>;
};
type WithModules$2<M extends RedisModules> = {
    [P in keyof M as ExcludeMappedString<P>]: {
        [C in keyof M[P] as ExcludeMappedString<C>]: RedisCommandSignature<M[P][C]>;
    };
};
type WithFunctions$2<F extends RedisFunctions$1> = {
    [P in keyof F as ExcludeMappedString<P>]: {
        [FF in keyof F[P] as ExcludeMappedString<FF>]: RedisCommandSignature<F[P][FF]>;
    };
};
type WithScripts$2<S extends RedisScripts$1> = {
    [P in keyof S as ExcludeMappedString<P>]: RedisCommandSignature<S[P]>;
};
type RedisClientType$2<M extends RedisModules = Record<string, never>, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisClient$1<M, F, S> & WithCommands$3 & WithModules$2<M> & WithFunctions$2<F> & WithScripts$2<S>;
type InstantiableRedisClient$1<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = new (options?: RedisClientOptions$1<M, F, S>) => RedisClientType$2<M, F, S>;
interface ClientCommandOptions$1 extends QueueCommandOptions {
    isolated?: boolean;
}
declare class RedisClient$1<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> extends EventEmitter {
    #private;
    static commandOptions<T extends ClientCommandOptions$1>(options: T): CommandOptions<T>;
    commandOptions: typeof RedisClient$1.commandOptions;
    static extend<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(extensions?: RedisExtensions<M, F, S>): InstantiableRedisClient$1<M, F, S>;
    static create<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(options?: RedisClientOptions$1<M, F, S>): RedisClientType$2<M, F, S>;
    static parseURL(url: string): RedisClientOptions$1;
    get options(): RedisClientOptions$1<M, F, S> | undefined;
    get isOpen(): boolean;
    get isReady(): boolean;
    get isPubSubActive(): boolean;
    get v4(): Record<string, any>;
    constructor(options?: RedisClientOptions$1<M, F, S>);
    duplicate(overrides?: Partial<RedisClientOptions$1<M, F, S>>): RedisClientType$2<M, F, S>;
    connect(): Promise<RedisClientType$2<M, F, S>>;
    commandsExecutor<C extends RedisCommand$1>(command: C, args: Array<unknown>): Promise<RedisCommandReply<C>>;
    sendCommand<T = RedisCommandRawReply>(args: RedisCommandArguments$5, options?: ClientCommandOptions$1): Promise<T>;
    functionsExecuter<F extends RedisFunction$1>(fn: F, args: Array<unknown>, name: string): Promise<RedisCommandReply<F>>;
    executeFunction(name: string, fn: RedisFunction$1, args: RedisCommandArguments$5, options?: ClientCommandOptions$1): Promise<RedisCommandRawReply>;
    scriptsExecuter<S extends RedisScript$1>(script: S, args: Array<unknown>): Promise<RedisCommandReply<S>>;
    executeScript(script: RedisScript$1, args: RedisCommandArguments$5, options?: ClientCommandOptions$1): Promise<RedisCommandRawReply>;
    SELECT(db: number): Promise<void>;
    SELECT(options: CommandOptions<ClientCommandOptions$1>, db: number): Promise<void>;
    select: {
        (db: number): Promise<void>;
        (options: CommandOptions<ClientCommandOptions$1>, db: number): Promise<void>;
    };
    SUBSCRIBE<T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    subscribe: <T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    UNSUBSCRIBE<T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    unsubscribe: <T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    PSUBSCRIBE<T extends boolean = false>(patterns: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    pSubscribe: <T extends boolean = false>(patterns: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    PUNSUBSCRIBE<T extends boolean = false>(patterns?: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    pUnsubscribe: <T extends boolean = false>(patterns?: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    SSUBSCRIBE<T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    sSubscribe: <T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    SUNSUBSCRIBE<T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    sUnsubscribe: <T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    getPubSubListeners(type: PubSubType): PubSubTypeListeners;
    extendPubSubChannelListeners(type: PubSubType, channel: string, listeners: ChannelListeners): Promise<void>;
    extendPubSubListeners(type: PubSubType, listeners: PubSubTypeListeners): Promise<void>;
    QUIT(): Promise<string>;
    quit: () => Promise<string>;
    executeIsolated<T>(fn: (client: RedisClientType$2<M, F, S>) => T | Promise<T>): Promise<T>;
    MULTI(): RedisClientMultiCommandType<M, F, S>;
    multi: () => RedisClientMultiCommandType<M, F, S>;
    multiExecutor(commands: Array<RedisMultiQueuedCommand>, selectedDB?: number, chainId?: symbol): Promise<Array<RedisCommandRawReply>>;
    scanIterator(options?: ScanCommandOptions): AsyncIterable<string>;
    hScanIterator(key: string, options?: ScanOptions): AsyncIterable<ConvertArgumentType<HScanTuple, string>>;
    hScanNoValuesIterator(key: string, options?: ScanOptions): AsyncIterable<ConvertArgumentType<RedisCommandArgument$5, string>>;
    sScanIterator(key: string, options?: ScanOptions): AsyncIterable<string>;
    zScanIterator(key: string, options?: ScanOptions): AsyncIterable<ConvertArgumentType<ZMember, string>>;
    disconnect(): Promise<void>;
    ref(): void;
    unref(): void;
}

type RedisCommandArgument$4 = string | Buffer;
type RedisCommandArguments$4 = Array<RedisCommandArgument$4> & {
    preserve?: unknown;
};

declare const FIRST_KEY_INDEX$1u = 1;
declare const IS_READ_ONLY$X = true;
declare function transformArguments$27(key: string, items: string | Array<string>): RedisCommandArguments$4;
declare function transformReply$1H(): Array<number>;

declare namespace _redis_bloom_dist_commands_top_k_QUERY {
  export { FIRST_KEY_INDEX$1u as FIRST_KEY_INDEX, IS_READ_ONLY$X as IS_READ_ONLY, transformArguments$27 as transformArguments, transformReply$1H as transformReply };
}

declare const FIRST_KEY_INDEX$1t = 1;
declare const IS_READ_ONLY$W = true;
declare function transformArguments$26(key: string): Array<string>;
declare function transformReply$1G(): Array<string | null>;

declare namespace _redis_bloom_dist_commands_top_k_LIST {
  export { FIRST_KEY_INDEX$1t as FIRST_KEY_INDEX, IS_READ_ONLY$W as IS_READ_ONLY, transformArguments$26 as transformArguments, transformReply$1G as transformReply };
}

declare const FIRST_KEY_INDEX$1s = 1;
declare const IS_READ_ONLY$V = true;
declare function transformArguments$25(key: string): Array<string>;
type ListWithCountRawReply = Array<string | number>;
type ListWithCountReply = Array<{
    item: string;
    count: number;
}>;
declare function transformReply$1F(rawReply: ListWithCountRawReply): ListWithCountReply;

declare namespace _redis_bloom_dist_commands_top_k_LIST_WITHCOUNT {
  export { FIRST_KEY_INDEX$1s as FIRST_KEY_INDEX, IS_READ_ONLY$V as IS_READ_ONLY, transformArguments$25 as transformArguments, transformReply$1F as transformReply };
}

declare const FIRST_KEY_INDEX$1r = 1;
declare const IS_READ_ONLY$U = true;
declare function transformArguments$24(key: string): Array<string>;
type InfoRawReply$7 = [
    _: string,
    k: number,
    _: string,
    width: number,
    _: string,
    depth: number,
    _: string,
    decay: string
];
interface InfoReply$7 {
    k: number;
    width: number;
    depth: number;
    decay: number;
}
declare function transformReply$1E(reply: InfoRawReply$7): InfoReply$7;

declare namespace _redis_bloom_dist_commands_top_k_INFO {
  export { FIRST_KEY_INDEX$1r as FIRST_KEY_INDEX, IS_READ_ONLY$U as IS_READ_ONLY, type InfoRawReply$7 as InfoRawReply, type InfoReply$7 as InfoReply, transformArguments$24 as transformArguments, transformReply$1E as transformReply };
}

declare const FIRST_KEY_INDEX$1q = 1;
interface IncrByItem$1 {
    item: string;
    incrementBy: number;
}
declare function transformArguments$23(key: string, items: IncrByItem$1 | Array<IncrByItem$1>): Array<string>;
declare function transformReply$1D(): Array<string | null>;

declare namespace _redis_bloom_dist_commands_top_k_INCRBY {
  export { FIRST_KEY_INDEX$1q as FIRST_KEY_INDEX, transformArguments$23 as transformArguments, transformReply$1D as transformReply };
}

declare const FIRST_KEY_INDEX$1p = 1;
declare const IS_READ_ONLY$T = true;
declare function transformArguments$22(key: string, items: string | Array<string>): RedisCommandArguments$4;
declare function transformReply$1C(): Array<number>;

declare namespace _redis_bloom_dist_commands_top_k_COUNT {
  export { FIRST_KEY_INDEX$1p as FIRST_KEY_INDEX, IS_READ_ONLY$T as IS_READ_ONLY, transformArguments$22 as transformArguments, transformReply$1C as transformReply };
}

declare const FIRST_KEY_INDEX$1o = 1;
declare function transformArguments$21(key: string, items: string | Array<string>): RedisCommandArguments$4;
declare function transformReply$1B(): Array<null | string>;

declare namespace _redis_bloom_dist_commands_top_k_ADD {
  export { FIRST_KEY_INDEX$1o as FIRST_KEY_INDEX, transformArguments$21 as transformArguments, transformReply$1B as transformReply };
}

interface CompressionOption {
    COMPRESSION?: number;
}
declare function transformDoubleReply(reply: string): number;
declare function transformDoublesReply(reply: Array<string>): Array<number>;

declare const FIRST_KEY_INDEX$1n = 1;
declare const IS_READ_ONLY$S = true;
declare function transformArguments$20(key: RedisCommandArgument$4, lowCutPercentile: number, highCutPercentile: number): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_t_digest_TRIMMED_MEAN {
  export { FIRST_KEY_INDEX$1n as FIRST_KEY_INDEX, IS_READ_ONLY$S as IS_READ_ONLY, transformArguments$20 as transformArguments, transformDoubleReply as transformReply };
}

declare const FIRST_KEY_INDEX$1m = 1;
declare const IS_READ_ONLY$R = true;
declare function transformArguments$1$(key: RedisCommandArgument$4, values: Array<number>): RedisCommandArguments$4;
declare function transformReply$1A(): Array<number>;

declare namespace _redis_bloom_dist_commands_t_digest_REVRANK {
  export { FIRST_KEY_INDEX$1m as FIRST_KEY_INDEX, IS_READ_ONLY$R as IS_READ_ONLY, transformArguments$1$ as transformArguments, transformReply$1A as transformReply };
}

declare const FIRST_KEY_INDEX$1l = 1;
declare function transformArguments$1_(key: RedisCommandArgument$4): RedisCommandArguments$4;
declare function transformReply$1z(): 'OK';

declare namespace _redis_bloom_dist_commands_t_digest_RESET {
  export { FIRST_KEY_INDEX$1l as FIRST_KEY_INDEX, transformArguments$1_ as transformArguments, transformReply$1z as transformReply };
}

declare const FIRST_KEY_INDEX$1k = 1;
declare const IS_READ_ONLY$Q = true;
declare function transformArguments$1Z(key: RedisCommandArgument$4, values: Array<number>): RedisCommandArguments$4;
declare function transformReply$1y(): Array<number>;

declare namespace _redis_bloom_dist_commands_t_digest_RANK {
  export { FIRST_KEY_INDEX$1k as FIRST_KEY_INDEX, IS_READ_ONLY$Q as IS_READ_ONLY, transformArguments$1Z as transformArguments, transformReply$1y as transformReply };
}

declare const FIRST_KEY_INDEX$1j = 1;
declare const IS_READ_ONLY$P = true;
declare function transformArguments$1Y(key: RedisCommandArgument$4, quantiles: Array<number>): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_t_digest_QUANTILE {
  export { FIRST_KEY_INDEX$1j as FIRST_KEY_INDEX, IS_READ_ONLY$P as IS_READ_ONLY, transformArguments$1Y as transformArguments, transformDoublesReply as transformReply };
}

declare const FIRST_KEY_INDEX$1i = 1;
declare const IS_READ_ONLY$O = true;
declare function transformArguments$1X(key: RedisCommandArgument$4): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_t_digest_MIN {
  export { FIRST_KEY_INDEX$1i as FIRST_KEY_INDEX, IS_READ_ONLY$O as IS_READ_ONLY, transformArguments$1X as transformArguments, transformDoubleReply as transformReply };
}

declare const FIRST_KEY_INDEX$1h = 1;
interface MergeOptions extends CompressionOption {
    OVERRIDE?: boolean;
}
declare function transformArguments$1W(destKey: RedisCommandArgument$4, srcKeys: RedisCommandArgument$4 | Array<RedisCommandArgument$4>, options?: MergeOptions): RedisCommandArguments$4;
declare function transformReply$1x(): 'OK';

declare namespace _redis_bloom_dist_commands_t_digest_MERGE {
  export { FIRST_KEY_INDEX$1h as FIRST_KEY_INDEX, transformArguments$1W as transformArguments, transformReply$1x as transformReply };
}

declare const FIRST_KEY_INDEX$1g = 1;
declare const IS_READ_ONLY$N = true;
declare function transformArguments$1V(key: RedisCommandArgument$4): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_t_digest_MAX {
  export { FIRST_KEY_INDEX$1g as FIRST_KEY_INDEX, IS_READ_ONLY$N as IS_READ_ONLY, transformArguments$1V as transformArguments, transformDoubleReply as transformReply };
}

declare const FIRST_KEY_INDEX$1f = 1;
declare const IS_READ_ONLY$M = true;
declare function transformArguments$1U(key: RedisCommandArgument$4): RedisCommandArguments$4;
type InfoRawReply$6 = [
    'Compression',
    number,
    'Capacity',
    number,
    'Merged nodes',
    number,
    'Unmerged nodes',
    number,
    'Merged weight',
    string,
    'Unmerged weight',
    string,
    'Total compressions',
    number
];
interface InfoReply$6 {
    comperssion: number;
    capacity: number;
    mergedNodes: number;
    unmergedNodes: number;
    mergedWeight: number;
    unmergedWeight: number;
    totalCompression: number;
}
declare function transformReply$1w(reply: InfoRawReply$6): InfoReply$6;

declare namespace _redis_bloom_dist_commands_t_digest_INFO {
  export { FIRST_KEY_INDEX$1f as FIRST_KEY_INDEX, IS_READ_ONLY$M as IS_READ_ONLY, transformArguments$1U as transformArguments, transformReply$1w as transformReply };
}

declare const FIRST_KEY_INDEX$1e = 1;
declare function transformArguments$1T(key: RedisCommandArgument$4, options?: CompressionOption): RedisCommandArguments$4;
declare function transformReply$1v(): 'OK';

declare namespace _redis_bloom_dist_commands_t_digest_CREATE {
  export { FIRST_KEY_INDEX$1e as FIRST_KEY_INDEX, transformArguments$1T as transformArguments, transformReply$1v as transformReply };
}

declare const FIRST_KEY_INDEX$1d = 1;
declare const IS_READ_ONLY$L = true;
declare function transformArguments$1S(key: RedisCommandArgument$4, values: Array<number>): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_t_digest_CDF {
  export { FIRST_KEY_INDEX$1d as FIRST_KEY_INDEX, IS_READ_ONLY$L as IS_READ_ONLY, transformArguments$1S as transformArguments, transformDoublesReply as transformReply };
}

declare const FIRST_KEY_INDEX$1c = 1;
declare const IS_READ_ONLY$K = true;
declare function transformArguments$1R(key: RedisCommandArgument$4, ranks: Array<number>): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_t_digest_BYREVRANK {
  export { FIRST_KEY_INDEX$1c as FIRST_KEY_INDEX, IS_READ_ONLY$K as IS_READ_ONLY, transformArguments$1R as transformArguments, transformDoublesReply as transformReply };
}

declare const FIRST_KEY_INDEX$1b = 1;
declare const IS_READ_ONLY$J = true;
declare function transformArguments$1Q(key: RedisCommandArgument$4, ranks: Array<number>): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_t_digest_BYRANK {
  export { FIRST_KEY_INDEX$1b as FIRST_KEY_INDEX, IS_READ_ONLY$J as IS_READ_ONLY, transformArguments$1Q as transformArguments, transformDoublesReply as transformReply };
}

declare const FIRST_KEY_INDEX$1a = 1;
declare function transformArguments$1P(key: RedisCommandArgument$4, values: Array<number>): RedisCommandArguments$4;
declare function transformReply$1u(): 'OK';

declare namespace _redis_bloom_dist_commands_t_digest_ADD {
  export { FIRST_KEY_INDEX$1a as FIRST_KEY_INDEX, transformArguments$1P as transformArguments, transformReply$1u as transformReply };
}

declare const FIRST_KEY_INDEX$19 = 1;
declare function transformArguments$1O(key: string, iterator: number): Array<string>;
type ScanDumpRawReply$1 = [
    iterator: number,
    chunk: string | null
];
interface ScanDumpReply$1 {
    iterator: number;
    chunk: string | null;
}
declare function transformReply$1t([iterator, chunk]: ScanDumpRawReply$1): ScanDumpReply$1;

declare namespace _redis_bloom_dist_commands_cuckoo_SCANDUMP {
  export { FIRST_KEY_INDEX$19 as FIRST_KEY_INDEX, transformArguments$1O as transformArguments, transformReply$1t as transformReply };
}

declare const FIRST_KEY_INDEX$18 = 1;
interface ReserveOptions$1 {
    BUCKETSIZE?: number;
    MAXITERATIONS?: number;
    EXPANSION?: number;
}
declare function transformArguments$1N(key: string, capacity: number, options?: ReserveOptions$1): Array<string>;
declare function transformReply$1s(): 'OK';

declare namespace _redis_bloom_dist_commands_cuckoo_RESERVE {
  export { FIRST_KEY_INDEX$18 as FIRST_KEY_INDEX, transformArguments$1N as transformArguments, transformReply$1s as transformReply };
}

declare const FIRST_KEY_INDEX$17 = 1;
declare function transformArguments$1M(key: string, iterator: number, chunk: RedisCommandArgument$4): RedisCommandArguments$4;
declare function transformReply$1r(): 'OK';

declare namespace _redis_bloom_dist_commands_cuckoo_LOADCHUNK {
  export { FIRST_KEY_INDEX$17 as FIRST_KEY_INDEX, transformArguments$1M as transformArguments, transformReply$1r as transformReply };
}

declare function transformBooleanReply$1(reply: number): boolean;
declare function transformBooleanArrayReply(reply: Array<number>): Array<boolean>;

interface InsertOptions$1 {
    CAPACITY?: number;
    NOCREATE?: true;
}

declare const FIRST_KEY_INDEX$16 = 1;
declare function transformArguments$1L(key: string, items: string | Array<string>, options?: InsertOptions$1): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_cuckoo_INSERTNX {
  export { FIRST_KEY_INDEX$16 as FIRST_KEY_INDEX, transformArguments$1L as transformArguments, transformBooleanArrayReply as transformReply };
}

declare const FIRST_KEY_INDEX$15 = 1;
declare function transformArguments$1K(key: string, items: string | Array<string>, options?: InsertOptions$1): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_cuckoo_INSERT {
  export { FIRST_KEY_INDEX$15 as FIRST_KEY_INDEX, transformArguments$1K as transformArguments, transformBooleanArrayReply as transformReply };
}

declare const FIRST_KEY_INDEX$14 = 1;
declare const IS_READ_ONLY$I = true;
declare function transformArguments$1J(key: string): Array<string>;
type InfoRawReply$5 = [
    _: string,
    size: number,
    _: string,
    numberOfBuckets: number,
    _: string,
    numberOfFilters: number,
    _: string,
    numberOfInsertedItems: number,
    _: string,
    numberOfDeletedItems: number,
    _: string,
    bucketSize: number,
    _: string,
    expansionRate: number,
    _: string,
    maxIteration: number
];
interface InfoReply$5 {
    size: number;
    numberOfBuckets: number;
    numberOfFilters: number;
    numberOfInsertedItems: number;
    numberOfDeletedItems: number;
    bucketSize: number;
    expansionRate: number;
    maxIteration: number;
}
declare function transformReply$1q(reply: InfoRawReply$5): InfoReply$5;

declare namespace _redis_bloom_dist_commands_cuckoo_INFO {
  export { FIRST_KEY_INDEX$14 as FIRST_KEY_INDEX, IS_READ_ONLY$I as IS_READ_ONLY, type InfoRawReply$5 as InfoRawReply, type InfoReply$5 as InfoReply, transformArguments$1J as transformArguments, transformReply$1q as transformReply };
}

declare const FIRST_KEY_INDEX$13 = 1;
declare const IS_READ_ONLY$H = true;
declare function transformArguments$1I(key: string, item: string): Array<string>;

declare namespace _redis_bloom_dist_commands_cuckoo_EXISTS {
  export { FIRST_KEY_INDEX$13 as FIRST_KEY_INDEX, IS_READ_ONLY$H as IS_READ_ONLY, transformArguments$1I as transformArguments, transformBooleanReply$1 as transformReply };
}

declare const FIRST_KEY_INDEX$12 = 1;
declare function transformArguments$1H(key: string, item: string): Array<string>;

declare namespace _redis_bloom_dist_commands_cuckoo_DEL {
  export { FIRST_KEY_INDEX$12 as FIRST_KEY_INDEX, transformArguments$1H as transformArguments, transformBooleanReply$1 as transformReply };
}

declare const FIRST_KEY_INDEX$11 = 1;
declare function transformArguments$1G(key: string, item: string): Array<string>;
declare function transformReply$1p(): number;

declare namespace _redis_bloom_dist_commands_cuckoo_COUNT {
  export { FIRST_KEY_INDEX$11 as FIRST_KEY_INDEX, transformArguments$1G as transformArguments, transformReply$1p as transformReply };
}

declare const FIRST_KEY_INDEX$10 = 1;
declare function transformArguments$1F(key: string, item: string): Array<string>;

declare namespace _redis_bloom_dist_commands_cuckoo_ADDNX {
  export { FIRST_KEY_INDEX$10 as FIRST_KEY_INDEX, transformArguments$1F as transformArguments, transformBooleanReply$1 as transformReply };
}

declare const FIRST_KEY_INDEX$$ = 1;
declare function transformArguments$1E(key: string, item: string): Array<string>;

declare namespace _redis_bloom_dist_commands_cuckoo_ADD {
  export { FIRST_KEY_INDEX$$ as FIRST_KEY_INDEX, transformArguments$1E as transformArguments, transformBooleanReply$1 as transformReply };
}

declare const FIRST_KEY_INDEX$_ = 1;
declare const IS_READ_ONLY$G = true;
declare function transformArguments$1D(key: string, items: string | Array<string>): RedisCommandArguments$4;
declare function transformReply$1o(): Array<number>;

declare namespace _redis_bloom_dist_commands_count_min_sketch_QUERY {
  export { FIRST_KEY_INDEX$_ as FIRST_KEY_INDEX, IS_READ_ONLY$G as IS_READ_ONLY, transformArguments$1D as transformArguments, transformReply$1o as transformReply };
}

declare const FIRST_KEY_INDEX$Z = 1;
interface Sketch {
    name: string;
    weight: number;
}
type Sketches = Array<string> | Array<Sketch>;
declare function transformArguments$1C(dest: string, src: Sketches): Array<string>;
declare function transformReply$1n(): 'OK';

declare namespace _redis_bloom_dist_commands_count_min_sketch_MERGE {
  export { FIRST_KEY_INDEX$Z as FIRST_KEY_INDEX, transformArguments$1C as transformArguments, transformReply$1n as transformReply };
}

declare const FIRST_KEY_INDEX$Y = 1;
declare function transformArguments$1B(key: string, error: number, probability: number): Array<string>;
declare function transformReply$1m(): 'OK';

declare namespace _redis_bloom_dist_commands_count_min_sketch_INITBYPROB {
  export { FIRST_KEY_INDEX$Y as FIRST_KEY_INDEX, transformArguments$1B as transformArguments, transformReply$1m as transformReply };
}

declare const FIRST_KEY_INDEX$X = 1;
declare function transformArguments$1A(key: string, width: number, depth: number): Array<string>;
declare function transformReply$1l(): 'OK';

declare namespace _redis_bloom_dist_commands_count_min_sketch_INITBYDIM {
  export { FIRST_KEY_INDEX$X as FIRST_KEY_INDEX, transformArguments$1A as transformArguments, transformReply$1l as transformReply };
}

declare const FIRST_KEY_INDEX$W = 1;
declare const IS_READ_ONLY$F = true;
declare function transformArguments$1z(key: string): Array<string>;
type InfoRawReply$4 = [
    _: string,
    width: number,
    _: string,
    depth: number,
    _: string,
    count: number
];
interface InfoReply$4 {
    width: number;
    depth: number;
    count: number;
}
declare function transformReply$1k(reply: InfoRawReply$4): InfoReply$4;

declare namespace _redis_bloom_dist_commands_count_min_sketch_INFO {
  export { FIRST_KEY_INDEX$W as FIRST_KEY_INDEX, IS_READ_ONLY$F as IS_READ_ONLY, type InfoRawReply$4 as InfoRawReply, type InfoReply$4 as InfoReply, transformArguments$1z as transformArguments, transformReply$1k as transformReply };
}

declare const FIRST_KEY_INDEX$V = 1;
interface IncrByItem {
    item: string;
    incrementBy: number;
}
declare function transformArguments$1y(key: string, items: IncrByItem | Array<IncrByItem>): Array<string>;
declare function transformReply$1j(): Array<number>;

declare namespace _redis_bloom_dist_commands_count_min_sketch_INCRBY {
  export { FIRST_KEY_INDEX$V as FIRST_KEY_INDEX, transformArguments$1y as transformArguments, transformReply$1j as transformReply };
}

declare const FIRST_KEY_INDEX$U = 1;
declare const IS_READ_ONLY$E = true;
declare function transformArguments$1x(key: string, iterator: number): Array<string>;
type ScanDumpRawReply = [
    iterator: number,
    chunk: string
];
interface ScanDumpReply {
    iterator: number;
    chunk: string;
}
declare function transformReply$1i([iterator, chunk]: ScanDumpRawReply): ScanDumpReply;

declare namespace _redis_bloom_dist_commands_bloom_SCANDUMP {
  export { FIRST_KEY_INDEX$U as FIRST_KEY_INDEX, IS_READ_ONLY$E as IS_READ_ONLY, transformArguments$1x as transformArguments, transformReply$1i as transformReply };
}

declare const FIRST_KEY_INDEX$T = 1;
interface ReserveOptions {
    EXPANSION?: number;
    NONSCALING?: true;
}
declare function transformArguments$1w(key: string, errorRate: number, capacity: number, options?: ReserveOptions): Array<string>;
declare function transformReply$1h(): 'OK';

declare namespace _redis_bloom_dist_commands_bloom_RESERVE {
  export { FIRST_KEY_INDEX$T as FIRST_KEY_INDEX, transformArguments$1w as transformArguments, transformReply$1h as transformReply };
}

declare const FIRST_KEY_INDEX$S = 1;
declare const IS_READ_ONLY$D = true;
declare function transformArguments$1v(key: string, items: Array<string>): Array<string>;

declare namespace _redis_bloom_dist_commands_bloom_MEXISTS {
  export { FIRST_KEY_INDEX$S as FIRST_KEY_INDEX, IS_READ_ONLY$D as IS_READ_ONLY, transformArguments$1v as transformArguments, transformBooleanArrayReply as transformReply };
}

declare const FIRST_KEY_INDEX$R = 1;
declare function transformArguments$1u(key: string, items: Array<string>): Array<string>;

declare namespace _redis_bloom_dist_commands_bloom_MADD {
  export { FIRST_KEY_INDEX$R as FIRST_KEY_INDEX, transformArguments$1u as transformArguments, transformBooleanArrayReply as transformReply };
}

declare const FIRST_KEY_INDEX$Q = 1;
declare function transformArguments$1t(key: string, iteretor: number, chunk: RedisCommandArgument$4): RedisCommandArguments$4;
declare function transformReply$1g(): 'OK';

declare namespace _redis_bloom_dist_commands_bloom_LOADCHUNK {
  export { FIRST_KEY_INDEX$Q as FIRST_KEY_INDEX, transformArguments$1t as transformArguments, transformReply$1g as transformReply };
}

declare const FIRST_KEY_INDEX$P = 1;
interface InsertOptions {
    CAPACITY?: number;
    ERROR?: number;
    EXPANSION?: number;
    NOCREATE?: true;
    NONSCALING?: true;
}
declare function transformArguments$1s(key: string, items: RedisCommandArgument$4 | Array<RedisCommandArgument$4>, options?: InsertOptions): RedisCommandArguments$4;

declare namespace _redis_bloom_dist_commands_bloom_INSERT {
  export { FIRST_KEY_INDEX$P as FIRST_KEY_INDEX, transformArguments$1s as transformArguments, transformBooleanArrayReply as transformReply };
}

declare const FIRST_KEY_INDEX$O = 1;
declare const IS_READ_ONLY$C = true;
declare function transformArguments$1r(key: string): Array<string>;
type InfoRawReply$3 = [
    _: string,
    capacity: number,
    _: string,
    size: number,
    _: string,
    numberOfFilters: number,
    _: string,
    numberOfInsertedItems: number,
    _: string,
    expansionRate: number
];
interface InfoReply$3 {
    capacity: number;
    size: number;
    numberOfFilters: number;
    numberOfInsertedItems: number;
    expansionRate: number;
}
declare function transformReply$1f(reply: InfoRawReply$3): InfoReply$3;

declare namespace _redis_bloom_dist_commands_bloom_INFO {
  export { FIRST_KEY_INDEX$O as FIRST_KEY_INDEX, IS_READ_ONLY$C as IS_READ_ONLY, type InfoRawReply$3 as InfoRawReply, type InfoReply$3 as InfoReply, transformArguments$1r as transformArguments, transformReply$1f as transformReply };
}

declare const FIRST_KEY_INDEX$N = 1;
declare const IS_READ_ONLY$B = true;
declare function transformArguments$1q(key: string, item: string): Array<string>;

declare namespace _redis_bloom_dist_commands_bloom_EXISTS {
  export { FIRST_KEY_INDEX$N as FIRST_KEY_INDEX, IS_READ_ONLY$B as IS_READ_ONLY, transformArguments$1q as transformArguments, transformBooleanReply$1 as transformReply };
}

declare const FIRST_KEY_INDEX$M = 1;
declare const IS_READ_ONLY$A = true;
declare function transformArguments$1p(key: string): Array<string>;
declare function transformReply$1e(): number;

declare namespace _redis_bloom_dist_commands_bloom_CARD {
  export { FIRST_KEY_INDEX$M as FIRST_KEY_INDEX, IS_READ_ONLY$A as IS_READ_ONLY, transformArguments$1p as transformArguments, transformReply$1e as transformReply };
}

declare const FIRST_KEY_INDEX$L = 1;
declare function transformArguments$1o(key: string, item: string): Array<string>;

declare namespace _redis_bloom_dist_commands_bloom_ADD {
  export { FIRST_KEY_INDEX$L as FIRST_KEY_INDEX, transformArguments$1o as transformArguments, transformBooleanReply$1 as transformReply };
}

type RedisCommandArgument$3 = string | Buffer;
type RedisCommandArguments$3 = Array<RedisCommandArgument$3> & {
    preserve?: unknown;
};

interface TsIgnoreOptions$1 {
    MAX_TIME_DIFF: number;
    MAX_VAL_DIFF: number;
}

declare const FIRST_KEY_INDEX$K = 1;
declare const IS_READ_ONLY$z = true;
type InfoRawReply$2 = [
    'totalSamples',
    number,
    'memoryUsage',
    number,
    'firstTimestamp',
    number,
    'lastTimestamp',
    number,
    'retentionTime',
    number,
    'chunkCount',
    number,
    'chunkSize',
    number,
    'chunkType',
    string,
    'duplicatePolicy',
    TimeSeriesDuplicatePolicies$1 | null,
    'labels',
    Array<[name: string, value: string]>,
    'sourceKey',
    string | null,
    'rules',
    Array<[key: string, timeBucket: number, aggregationType: TimeSeriesAggregationType$1]>
];
interface InfoReply$2 {
    totalSamples: number;
    memoryUsage: number;
    firstTimestamp: number;
    lastTimestamp: number;
    retentionTime: number;
    chunkCount: number;
    chunkSize: number;
    chunkType: string;
    duplicatePolicy: TimeSeriesDuplicatePolicies$1 | null;
    labels: Array<{
        name: string;
        value: string;
    }>;
    sourceKey: string | null;
    rules: Array<{
        key: string;
        timeBucket: number;
        aggregationType: TimeSeriesAggregationType$1;
    }>;
}

interface MGetOptions$1 {
    LATEST?: boolean;
}
type MGetRawReply$1 = Array<[
    key: string,
    labels: RawLabels,
    sample: SampleRawReply
]>;
interface MGetReply$1 {
    key: string;
    sample: SampleReply;
}

declare enum TimeSeriesAggregationType$1 {
    AVG = "AVG",
    AVERAGE = "AVG",
    FIRST = "FIRST",
    LAST = "LAST",
    MIN = "MIN",
    MINIMUM = "MIN",
    MAX = "MAX",
    MAXIMUM = "MAX",
    SUM = "SUM",
    RANGE = "RANGE",
    COUNT = "COUNT",
    STD_P = "STD.P",
    STD_S = "STD.S",
    VAR_P = "VAR.P",
    VAR_S = "VAR.S",
    TWA = "TWA"
}
declare enum TimeSeriesDuplicatePolicies$1 {
    BLOCK = "BLOCK",
    FIRST = "FIRST",
    LAST = "LAST",
    MIN = "MIN",
    MAX = "MAX",
    SUM = "SUM"
}
declare enum TimeSeriesReducers$1 {
    AVG = "AVG",
    SUM = "SUM",
    MIN = "MIN",
    MINIMUM = "MIN",
    MAX = "MAX",
    MAXIMUM = "MAX",
    RANGE = "range",
    COUNT = "COUNT",
    STD_P = "STD.P",
    STD_S = "STD.S",
    VAR_P = "VAR.P",
    VAR_S = "VAR.S"
}
type Timestamp = number | Date | string;
declare enum TimeSeriesEncoding$1 {
    COMPRESSED = "COMPRESSED",
    UNCOMPRESSED = "UNCOMPRESSED"
}
type RawLabels = Array<[label: string, value: string]>;
type Labels = {
    [label: string]: string;
};
interface IncrDecrOptions {
    TIMESTAMP?: Timestamp;
    RETENTION?: number;
    UNCOMPRESSED?: boolean;
    CHUNK_SIZE?: number;
    LABELS?: Labels;
}
type SampleRawReply = [timestamp: number, value: string];
interface SampleReply {
    timestamp: number;
    value: number;
}
declare enum TimeSeriesBucketTimestamp$1 {
    LOW = "-",
    HIGH = "+",
    MID = "~"
}
interface RangeOptions {
    LATEST?: boolean;
    FILTER_BY_TS?: Array<Timestamp>;
    FILTER_BY_VALUE?: {
        min: number;
        max: number;
    };
    COUNT?: number;
    ALIGN?: Timestamp;
    AGGREGATION?: {
        type: TimeSeriesAggregationType$1;
        timeBucket: Timestamp;
        BUCKETTIMESTAMP?: TimeSeriesBucketTimestamp$1;
        EMPTY?: boolean;
    };
}
interface MRangeGroupBy {
    label: string;
    reducer: TimeSeriesReducers$1;
}
type Filter = string | Array<string>;
interface MRangeOptions extends RangeOptions {
    GROUPBY?: MRangeGroupBy;
}
type SelectedLabels = string | Array<string>;
interface MRangeWithLabelsOptions extends MRangeOptions {
    SELECTED_LABELS?: SelectedLabels;
}
type MRangeRawReply = Array<[
    key: string,
    labels: RawLabels,
    samples: Array<SampleRawReply>
]>;
interface MRangeReplyItem {
    key: string;
    samples: Array<SampleReply>;
}
declare function transformMRangeReply(reply: MRangeRawReply): Array<MRangeReplyItem>;
interface MRangeWithLabelsReplyItem extends MRangeReplyItem {
    labels: Labels;
}
declare function transformMRangeWithLabelsReply(reply: MRangeRawReply): Array<MRangeWithLabelsReplyItem>;

declare const IS_READ_ONLY$y = true;
declare function transformArguments$1n(fromTimestamp: Timestamp, toTimestamp: Timestamp, filters: Filter, options?: MRangeWithLabelsOptions): RedisCommandArguments$3;

declare namespace _redis_time_series_dist_commands_MREVRANGE_WITHLABELS {
  export { IS_READ_ONLY$y as IS_READ_ONLY, transformArguments$1n as transformArguments, transformMRangeWithLabelsReply as transformReply };
}

declare const IS_READ_ONLY$x = true;
declare function transformArguments$1m(fromTimestamp: Timestamp, toTimestamp: Timestamp, filters: Filter, options?: MRangeOptions): RedisCommandArguments$3;

declare namespace _redis_time_series_dist_commands_MREVRANGE {
  export { IS_READ_ONLY$x as IS_READ_ONLY, transformArguments$1m as transformArguments, transformMRangeReply as transformReply };
}

declare const IS_READ_ONLY$w = true;
declare function transformArguments$1l(fromTimestamp: Timestamp, toTimestamp: Timestamp, filters: string | Array<string>, options?: MRangeWithLabelsOptions): RedisCommandArguments$3;

declare namespace _redis_time_series_dist_commands_MRANGE_WITHLABELS {
  export { IS_READ_ONLY$w as IS_READ_ONLY, transformArguments$1l as transformArguments, transformMRangeWithLabelsReply as transformReply };
}

declare const IS_READ_ONLY$v = true;
declare function transformArguments$1k(fromTimestamp: Timestamp, toTimestamp: Timestamp, filters: Filter, options?: MRangeOptions): RedisCommandArguments$3;

declare namespace _redis_time_series_dist_commands_MRANGE {
  export { IS_READ_ONLY$v as IS_READ_ONLY, transformArguments$1k as transformArguments, transformMRangeReply as transformReply };
}

declare const FIRST_KEY_INDEX$J = 1;
declare const IS_READ_ONLY$u = true;
declare function transformArguments$1j(key: string, fromTimestamp: Timestamp, toTimestamp: Timestamp, options?: RangeOptions): RedisCommandArguments$3;
declare function transformReply$1d(reply: Array<SampleRawReply>): Array<SampleReply>;

declare namespace _redis_time_series_dist_commands_REVRANGE {
  export { FIRST_KEY_INDEX$J as FIRST_KEY_INDEX, IS_READ_ONLY$u as IS_READ_ONLY, transformArguments$1j as transformArguments, transformReply$1d as transformReply };
}

declare const FIRST_KEY_INDEX$I = 1;
declare const IS_READ_ONLY$t = true;
declare function transformArguments$1i(key: string, fromTimestamp: Timestamp, toTimestamp: Timestamp, options?: RangeOptions): RedisCommandArguments$3;
declare function transformReply$1c(reply: Array<SampleRawReply>): Array<SampleReply>;

declare namespace _redis_time_series_dist_commands_RANGE {
  export { FIRST_KEY_INDEX$I as FIRST_KEY_INDEX, IS_READ_ONLY$t as IS_READ_ONLY, transformArguments$1i as transformArguments, transformReply$1c as transformReply };
}

declare const IS_READ_ONLY$s = true;
declare function transformArguments$1h(filter: Filter): RedisCommandArguments$3;
declare function transformReply$1b(): Array<string>;

declare namespace _redis_time_series_dist_commands_QUERYINDEX {
  export { IS_READ_ONLY$s as IS_READ_ONLY, transformArguments$1h as transformArguments, transformReply$1b as transformReply };
}

declare const IS_READ_ONLY$r = true;
interface MGetWithLabelsOptions extends MGetOptions$1 {
    SELECTED_LABELS?: SelectedLabels;
}
declare function transformArguments$1g(filter: Filter, options?: MGetWithLabelsOptions): RedisCommandArguments$3;
interface MGetWithLabelsReply extends MGetReply$1 {
    labels: Labels;
}
declare function transformReply$1a(reply: MGetRawReply$1): Array<MGetWithLabelsReply>;

type _redis_time_series_dist_commands_MGET_WITHLABELS_MGetWithLabelsReply = MGetWithLabelsReply;
declare namespace _redis_time_series_dist_commands_MGET_WITHLABELS {
  export { IS_READ_ONLY$r as IS_READ_ONLY, type _redis_time_series_dist_commands_MGET_WITHLABELS_MGetWithLabelsReply as MGetWithLabelsReply, transformArguments$1g as transformArguments, transformReply$1a as transformReply };
}

declare const IS_READ_ONLY$q = true;
interface MGetOptions {
    LATEST?: boolean;
}
declare function transformArguments$1f(filter: Filter, options?: MGetOptions): RedisCommandArguments$3;
type MGetRawReply = Array<[
    key: string,
    labels: RawLabels,
    sample: SampleRawReply
]>;
interface MGetReply {
    key: string;
    sample: SampleReply;
}
declare function transformReply$19(reply: MGetRawReply): Array<MGetReply>;

type _redis_time_series_dist_commands_MGET_MGetOptions = MGetOptions;
type _redis_time_series_dist_commands_MGET_MGetRawReply = MGetRawReply;
type _redis_time_series_dist_commands_MGET_MGetReply = MGetReply;
declare namespace _redis_time_series_dist_commands_MGET {
  export { IS_READ_ONLY$q as IS_READ_ONLY, type _redis_time_series_dist_commands_MGET_MGetOptions as MGetOptions, type _redis_time_series_dist_commands_MGET_MGetRawReply as MGetRawReply, type _redis_time_series_dist_commands_MGET_MGetReply as MGetReply, transformArguments$1f as transformArguments, transformReply$19 as transformReply };
}

declare const FIRST_KEY_INDEX$H = 1;
interface MAddSample {
    key: string;
    timestamp: Timestamp;
    value: number;
}
declare function transformArguments$1e(toAdd: Array<MAddSample>): Array<string>;
declare function transformReply$18(): Array<number>;

declare namespace _redis_time_series_dist_commands_MADD {
  export { FIRST_KEY_INDEX$H as FIRST_KEY_INDEX, transformArguments$1e as transformArguments, transformReply$18 as transformReply };
}

declare const FIRST_KEY_INDEX$G = 1;
declare const IS_READ_ONLY$p = true;
declare function transformArguments$1d(key: string): Array<string>;
type InfoRawReply$1 = [
    'totalSamples',
    number,
    'memoryUsage',
    number,
    'firstTimestamp',
    number,
    'lastTimestamp',
    number,
    'retentionTime',
    number,
    'chunkCount',
    number,
    'chunkSize',
    number,
    'chunkType',
    string,
    'duplicatePolicy',
    TimeSeriesDuplicatePolicies$1 | null,
    'labels',
    Array<[name: string, value: string]>,
    'sourceKey',
    string | null,
    'rules',
    Array<[key: string, timeBucket: number, aggregationType: TimeSeriesAggregationType$1]>
];
interface InfoReply$1 {
    totalSamples: number;
    memoryUsage: number;
    firstTimestamp: number;
    lastTimestamp: number;
    retentionTime: number;
    chunkCount: number;
    chunkSize: number;
    chunkType: string;
    duplicatePolicy: TimeSeriesDuplicatePolicies$1 | null;
    labels: Array<{
        name: string;
        value: string;
    }>;
    sourceKey: string | null;
    rules: Array<{
        key: string;
        timeBucket: number;
        aggregationType: TimeSeriesAggregationType$1;
    }>;
}
declare function transformReply$17(reply: InfoRawReply$1): InfoReply$1;

declare namespace _redis_time_series_dist_commands_INFO {
  export { FIRST_KEY_INDEX$G as FIRST_KEY_INDEX, IS_READ_ONLY$p as IS_READ_ONLY, type InfoRawReply$1 as InfoRawReply, type InfoReply$1 as InfoReply, transformArguments$1d as transformArguments, transformReply$17 as transformReply };
}

declare function transformArguments$1c(key: string): Array<string>;
type InfoDebugRawReply = [
    ...InfoRawReply$2,
    'keySelfName',
    string,
    'chunks',
    Array<[
        'startTimestamp',
        number,
        'endTimestamp',
        number,
        'samples',
        number,
        'size',
        number,
        'bytesPerSample',
        string
    ]>
];
interface InfoDebugReply extends InfoReply$2 {
    keySelfName: string;
    chunks: Array<{
        startTimestamp: number;
        endTimestamp: number;
        samples: number;
        size: number;
        bytesPerSample: string;
    }>;
}
declare function transformReply$16(rawReply: InfoDebugRawReply): InfoDebugReply;

declare namespace _redis_time_series_dist_commands_INFO_DEBUG {
  export { FIRST_KEY_INDEX$K as FIRST_KEY_INDEX, IS_READ_ONLY$z as IS_READ_ONLY, transformArguments$1c as transformArguments, transformReply$16 as transformReply };
}

declare const FIRST_KEY_INDEX$F = 1;
declare function transformArguments$1b(key: string, value: number, options?: IncrDecrOptions): RedisCommandArguments$3;
declare function transformReply$15(): number;

declare namespace _redis_time_series_dist_commands_INCRBY {
  export { FIRST_KEY_INDEX$F as FIRST_KEY_INDEX, transformArguments$1b as transformArguments, transformReply$15 as transformReply };
}

declare const FIRST_KEY_INDEX$E = 1;
declare const IS_READ_ONLY$o = true;
interface GetOptions$1 {
    LATEST?: boolean;
}
declare function transformArguments$1a(key: string, options?: GetOptions$1): RedisCommandArguments$3;
declare function transformReply$14(reply: [] | SampleRawReply): null | SampleReply;

declare namespace _redis_time_series_dist_commands_GET {
  export { FIRST_KEY_INDEX$E as FIRST_KEY_INDEX, IS_READ_ONLY$o as IS_READ_ONLY, transformArguments$1a as transformArguments, transformReply$14 as transformReply };
}

declare const FIRST_KEY_INDEX$D = 1;
declare function transformArguments$19(sourceKey: string, destinationKey: string): Array<string>;
declare function transformReply$13(): 'OK';

declare namespace _redis_time_series_dist_commands_DELETERULE {
  export { FIRST_KEY_INDEX$D as FIRST_KEY_INDEX, transformArguments$19 as transformArguments, transformReply$13 as transformReply };
}

declare const FIRTS_KEY_INDEX = 1;
declare function transformArguments$18(key: string, fromTimestamp: Timestamp, toTimestamp: Timestamp): RedisCommandArguments$3;
declare function transformReply$12(): number;

declare const _redis_time_series_dist_commands_DEL_FIRTS_KEY_INDEX: typeof FIRTS_KEY_INDEX;
declare namespace _redis_time_series_dist_commands_DEL {
  export { _redis_time_series_dist_commands_DEL_FIRTS_KEY_INDEX as FIRTS_KEY_INDEX, transformArguments$18 as transformArguments, transformReply$12 as transformReply };
}

declare const FIRST_KEY_INDEX$C = 1;
declare function transformArguments$17(key: string, value: number, options?: IncrDecrOptions): RedisCommandArguments$3;
declare function transformReply$11(): number;

declare namespace _redis_time_series_dist_commands_DECRBY {
  export { FIRST_KEY_INDEX$C as FIRST_KEY_INDEX, transformArguments$17 as transformArguments, transformReply$11 as transformReply };
}

declare const FIRST_KEY_INDEX$B = 1;
declare function transformArguments$16(sourceKey: string, destinationKey: string, aggregationType: TimeSeriesAggregationType$1, bucketDuration: number, alignTimestamp?: number): Array<string>;
declare function transformReply$10(): 'OK';

declare namespace _redis_time_series_dist_commands_CREATERULE {
  export { FIRST_KEY_INDEX$B as FIRST_KEY_INDEX, transformArguments$16 as transformArguments, transformReply$10 as transformReply };
}

declare const FIRST_KEY_INDEX$A = 1;
interface CreateOptions$1 {
    RETENTION?: number;
    ENCODING?: TimeSeriesEncoding$1;
    CHUNK_SIZE?: number;
    DUPLICATE_POLICY?: TimeSeriesDuplicatePolicies$1;
    LABELS?: Labels;
    IGNORE?: TsIgnoreOptions$1;
}
declare function transformArguments$15(key: string, options?: CreateOptions$1): Array<string>;
declare function transformReply$$(): 'OK';

declare namespace _redis_time_series_dist_commands_CREATE {
  export { FIRST_KEY_INDEX$A as FIRST_KEY_INDEX, transformArguments$15 as transformArguments, transformReply$$ as transformReply };
}

declare const FIRST_KEY_INDEX$z = 1;
interface AlterOptions {
    RETENTION?: number;
    CHUNK_SIZE?: number;
    DUPLICATE_POLICY?: TimeSeriesDuplicatePolicies$1;
    LABELS?: Labels;
    IGNORE?: TsIgnoreOptions$1;
}
declare function transformArguments$14(key: string, options?: AlterOptions): Array<string>;
declare function transformReply$_(): 'OK';

declare namespace _redis_time_series_dist_commands_ALTER {
  export { FIRST_KEY_INDEX$z as FIRST_KEY_INDEX, transformArguments$14 as transformArguments, transformReply$_ as transformReply };
}

interface TsIgnoreOptions {
    MAX_TIME_DIFF: number;
    MAX_VAL_DIFF: number;
}
interface AddOptions {
    RETENTION?: number;
    ENCODING?: TimeSeriesEncoding$1;
    CHUNK_SIZE?: number;
    ON_DUPLICATE?: TimeSeriesDuplicatePolicies$1;
    LABELS?: Labels;
    IGNORE?: TsIgnoreOptions;
}
declare const FIRST_KEY_INDEX$y = 1;
declare function transformArguments$13(key: string, timestamp: Timestamp, value: number, options?: AddOptions): Array<string>;
declare function transformReply$Z(): number;

type _redis_time_series_dist_commands_ADD_TsIgnoreOptions = TsIgnoreOptions;
declare namespace _redis_time_series_dist_commands_ADD {
  export { FIRST_KEY_INDEX$y as FIRST_KEY_INDEX, type _redis_time_series_dist_commands_ADD_TsIgnoreOptions as TsIgnoreOptions, transformArguments$13 as transformArguments, transformReply$Z as transformReply };
}

declare function transformArguments$12(index: string, fieldName: string): Array<string>;
declare function transformReply$Y(): Array<string>;

declare namespace _redis_search_dist_commands_TAGVALS {
  export { transformArguments$12 as transformArguments, transformReply$Y as transformReply };
}

type RedisCommandArgument$2 = string | Buffer;
type RedisCommandArguments$2 = Array<RedisCommandArgument$2> & {
    preserve?: unknown;
};

interface SynUpdateOptions {
    SKIPINITIALSCAN?: true;
}
declare function transformArguments$11(index: string, groupId: string, terms: string | Array<string>, options?: SynUpdateOptions): RedisCommandArguments$2;
declare function transformReply$X(): 'OK';

declare namespace _redis_search_dist_commands_SYNUPDATE {
  export { transformArguments$11 as transformArguments, transformReply$X as transformReply };
}

declare function transformArguments$10(index: string): Array<string>;
declare function transformReply$W(): Array<string>;

declare namespace _redis_search_dist_commands_SYNDUMP {
  export { transformArguments$10 as transformArguments, transformReply$W as transformReply };
}

declare const IS_READ_ONLY$n = true;
declare function transformArguments$$(key: string): Array<string>;
declare function transformReply$V(): number;

declare namespace _redis_search_dist_commands_SUGLEN {
  export { IS_READ_ONLY$n as IS_READ_ONLY, transformArguments$$ as transformArguments, transformReply$V as transformReply };
}

declare const IS_READ_ONLY$m = true;
interface SugGetOptions$1 {
    FUZZY?: true;
    MAX?: number;
}
declare function transformArguments$_(key: string, prefix: string, options?: SugGetOptions$1): Array<string>;
declare function transformReply$U(): null | Array<string>;

declare namespace _redis_search_dist_commands_SUGGET {
  export { IS_READ_ONLY$m as IS_READ_ONLY, type SugGetOptions$1 as SugGetOptions, transformArguments$_ as transformArguments, transformReply$U as transformReply };
}

declare const IS_READ_ONLY$l = true;
interface SugGetOptions {
    FUZZY?: true;
    MAX?: number;
}

declare function transformArguments$Z(key: string, prefix: string, options?: SugGetOptions): Array<string>;
interface SuggestionWithScores$1 {
    suggestion: string;
    score: number;
}
declare function transformReply$T(rawReply: Array<string> | null): Array<SuggestionWithScores$1> | null;

declare namespace _redis_search_dist_commands_SUGGET_WITHSCORES {
  export { IS_READ_ONLY$l as IS_READ_ONLY, type SuggestionWithScores$1 as SuggestionWithScores, transformArguments$Z as transformArguments, transformReply$T as transformReply };
}

interface SuggestionWithPayload$1 {
    suggestion: string;
    payload: string | null;
}

interface SuggestionWithScores {
    suggestion: string;
    score: number;
}

declare function transformArguments$Y(key: string, prefix: string, options?: SugGetOptions): Array<string>;
type SuggestionWithScoresAndPayloads = SuggestionWithScores & SuggestionWithPayload$1;
declare function transformReply$S(rawReply: Array<string | null> | null): Array<SuggestionWithScoresAndPayloads> | null;

declare namespace _redis_search_dist_commands_SUGGET_WITHSCORES_WITHPAYLOADS {
  export { IS_READ_ONLY$l as IS_READ_ONLY, transformArguments$Y as transformArguments, transformReply$S as transformReply };
}

declare function transformArguments$X(key: string, prefix: string, options?: SugGetOptions): Array<string>;
interface SuggestionWithPayload {
    suggestion: string;
    payload: string | null;
}
declare function transformReply$R(rawReply: Array<string | null> | null): Array<SuggestionWithPayload> | null;

type _redis_search_dist_commands_SUGGET_WITHPAYLOADS_SuggestionWithPayload = SuggestionWithPayload;
declare namespace _redis_search_dist_commands_SUGGET_WITHPAYLOADS {
  export { IS_READ_ONLY$l as IS_READ_ONLY, type _redis_search_dist_commands_SUGGET_WITHPAYLOADS_SuggestionWithPayload as SuggestionWithPayload, transformArguments$X as transformArguments, transformReply$R as transformReply };
}

declare function transformBooleanReply(reply: number): boolean;

declare function transformArguments$W(key: string, string: string): Array<string>;

declare namespace _redis_search_dist_commands_SUGDEL {
  export { transformArguments$W as transformArguments, transformBooleanReply as transformReply };
}

interface SugAddOptions {
    INCR?: true;
    PAYLOAD?: string;
}
declare function transformArguments$V(key: string, string: string, score: number, options?: SugAddOptions): Array<string>;
declare function transformReply$Q(): number;

declare namespace _redis_search_dist_commands_SUGADD {
  export { transformArguments$V as transformArguments, transformReply$Q as transformReply };
}

interface SpellCheckTerms {
    mode: 'INCLUDE' | 'EXCLUDE';
    dictionary: string;
}
interface SpellCheckOptions {
    DISTANCE?: number;
    TERMS?: SpellCheckTerms | Array<SpellCheckTerms>;
    DIALECT?: number;
}
declare function transformArguments$U(index: string, query: string, options?: SpellCheckOptions): Array<string>;
type SpellCheckRawReply = Array<[
    _: string,
    term: string,
    suggestions: Array<[score: string, suggestion: string]>
]>;
type SpellCheckReply = Array<{
    term: string;
    suggestions: Array<{
        score: number;
        suggestion: string;
    }>;
}>;
declare function transformReply$P(rawReply: SpellCheckRawReply): SpellCheckReply;

declare namespace _redis_search_dist_commands_SPELLCHECK {
  export { transformArguments$U as transformArguments, transformReply$P as transformReply };
}

declare enum AggregateSteps$2 {
    GROUPBY = "GROUPBY",
    SORTBY = "SORTBY",
    APPLY = "APPLY",
    LIMIT = "LIMIT",
    FILTER = "FILTER"
}
interface AggregateStep$1<T extends AggregateSteps$2> {
    type: T;
}
declare enum AggregateGroupByReducers$2 {
    COUNT = "COUNT",
    COUNT_DISTINCT = "COUNT_DISTINCT",
    COUNT_DISTINCTISH = "COUNT_DISTINCTISH",
    SUM = "SUM",
    MIN = "MIN",
    MAX = "MAX",
    AVG = "AVG",
    STDDEV = "STDDEV",
    QUANTILE = "QUANTILE",
    TOLIST = "TOLIST",
    TO_LIST = "TOLIST",
    FIRST_VALUE = "FIRST_VALUE",
    RANDOM_SAMPLE = "RANDOM_SAMPLE"
}
interface GroupByReducer$1<T extends AggregateGroupByReducers$2> {
    type: T;
    AS?: string;
}
type CountReducer$1 = GroupByReducer$1<AggregateGroupByReducers$2.COUNT>;
interface CountDistinctReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.COUNT_DISTINCT> {
    property: PropertyName;
}
interface CountDistinctishReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.COUNT_DISTINCTISH> {
    property: PropertyName;
}
interface SumReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.SUM> {
    property: PropertyName;
}
interface MinReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.MIN> {
    property: PropertyName;
}
interface MaxReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.MAX> {
    property: PropertyName;
}
interface AvgReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.AVG> {
    property: PropertyName;
}
interface StdDevReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.STDDEV> {
    property: PropertyName;
}
interface QuantileReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.QUANTILE> {
    property: PropertyName;
    quantile: number;
}
interface ToListReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.TOLIST> {
    property: PropertyName;
}
interface FirstValueReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.FIRST_VALUE> {
    property: PropertyName;
    BY?: PropertyName | {
        property: PropertyName;
        direction?: 'ASC' | 'DESC';
    };
}
interface RandomSampleReducer$1 extends GroupByReducer$1<AggregateGroupByReducers$2.RANDOM_SAMPLE> {
    property: PropertyName;
    sampleSize: number;
}
type GroupByReducers$1 = CountReducer$1 | CountDistinctReducer$1 | CountDistinctishReducer$1 | SumReducer$1 | MinReducer$1 | MaxReducer$1 | AvgReducer$1 | StdDevReducer$1 | QuantileReducer$1 | ToListReducer$1 | FirstValueReducer$1 | RandomSampleReducer$1;
interface GroupByStep$1 extends AggregateStep$1<AggregateSteps$2.GROUPBY> {
    properties?: PropertyName | Array<PropertyName>;
    REDUCE: GroupByReducers$1 | Array<GroupByReducers$1>;
}
interface SortStep$1 extends AggregateStep$1<AggregateSteps$2.SORTBY> {
    BY: SortByProperty | Array<SortByProperty>;
    MAX?: number;
}
interface ApplyStep$1 extends AggregateStep$1<AggregateSteps$2.APPLY> {
    expression: string;
    AS: string;
}
interface LimitStep$1 extends AggregateStep$1<AggregateSteps$2.LIMIT> {
    from: number;
    size: number;
}
interface FilterStep$1 extends AggregateStep$1<AggregateSteps$2.FILTER> {
    expression: string;
}
type LoadField$1 = PropertyName | {
    identifier: PropertyName;
    AS?: string;
};
interface AggregateOptions$1 {
    VERBATIM?: boolean;
    ADDSCORES?: boolean;
    LOAD?: LoadField$1 | Array<LoadField$1>;
    STEPS?: Array<GroupByStep$1 | SortStep$1 | ApplyStep$1 | LimitStep$1 | FilterStep$1>;
    PARAMS?: Params;
    DIALECT?: number;
    TIMEOUT?: number;
}
declare const FIRST_KEY_INDEX$x = 1;
declare const IS_READ_ONLY$k = true;
type AggregateRawReply$1 = [
    total: number,
    ...results: Array<Array<RedisCommandArgument$2>>
];
interface AggregateReply$1 {
    total: number;
    results: Array<Record<string, RedisCommandArgument$2>>;
}

type AggregateWithCursorRawReply$1 = [
    result: AggregateRawReply$1,
    cursor: number
];
interface AggregateWithCursorReply$1 extends AggregateReply$1 {
    cursor: number;
}
declare function transformReply$O(reply: AggregateWithCursorRawReply$1): AggregateWithCursorReply$1;

declare enum RedisSearchLanguages$1 {
    ARABIC = "Arabic",
    BASQUE = "Basque",
    CATALANA = "Catalan",
    DANISH = "Danish",
    DUTCH = "Dutch",
    ENGLISH = "English",
    FINNISH = "Finnish",
    FRENCH = "French",
    GERMAN = "German",
    GREEK = "Greek",
    HUNGARIAN = "Hungarian",
    INDONESAIN = "Indonesian",
    IRISH = "Irish",
    ITALIAN = "Italian",
    LITHUANIAN = "Lithuanian",
    NEPALI = "Nepali",
    NORWEIGAN = "Norwegian",
    PORTUGUESE = "Portuguese",
    ROMANIAN = "Romanian",
    RUSSIAN = "Russian",
    SPANISH = "Spanish",
    SWEDISH = "Swedish",
    TAMIL = "Tamil",
    TURKISH = "Turkish",
    CHINESE = "Chinese"
}
type PropertyName = `${'@' | '$.'}${string}`;
type SortByProperty = string | {
    BY: string;
    DIRECTION?: 'ASC' | 'DESC';
};
declare enum SchemaFieldTypes$1 {
    TEXT = "TEXT",
    NUMERIC = "NUMERIC",
    GEO = "GEO",
    TAG = "TAG",
    VECTOR = "VECTOR",
    GEOSHAPE = "GEOSHAPE"
}
type CreateSchemaField<T extends SchemaFieldTypes$1, E = Record<PropertyKey, unknown>> = T | ({
    type: T;
    AS?: string;
    INDEXMISSING?: boolean;
} & E);
type CommonFieldArguments = {
    SORTABLE?: boolean | 'UNF';
    NOINDEX?: boolean;
};
type CreateSchemaCommonField<T extends SchemaFieldTypes$1, E = Record<PropertyKey, unknown>> = CreateSchemaField<T, (CommonFieldArguments & E)>;
declare enum SchemaTextFieldPhonetics$1 {
    DM_EN = "dm:en",
    DM_FR = "dm:fr",
    FM_PT = "dm:pt",
    DM_ES = "dm:es"
}
type CreateSchemaTextField = CreateSchemaCommonField<SchemaFieldTypes$1.TEXT, {
    NOSTEM?: true;
    WEIGHT?: number;
    PHONETIC?: SchemaTextFieldPhonetics$1;
    WITHSUFFIXTRIE?: boolean;
    INDEXEMPTY?: boolean;
}>;
type CreateSchemaNumericField = CreateSchemaCommonField<SchemaFieldTypes$1.NUMERIC>;
type CreateSchemaGeoField = CreateSchemaCommonField<SchemaFieldTypes$1.GEO>;
type CreateSchemaTagField = CreateSchemaCommonField<SchemaFieldTypes$1.TAG, {
    SEPARATOR?: string;
    CASESENSITIVE?: true;
    WITHSUFFIXTRIE?: boolean;
    INDEXEMPTY?: boolean;
}>;
declare enum VectorAlgorithms$1 {
    FLAT = "FLAT",
    HNSW = "HNSW"
}
type CreateSchemaVectorField<T extends VectorAlgorithms$1, A extends Record<string, unknown>> = CreateSchemaField<SchemaFieldTypes$1.VECTOR, {
    ALGORITHM: T;
    TYPE: string;
    DIM: number;
    DISTANCE_METRIC: 'L2' | 'IP' | 'COSINE';
    INITIAL_CAP?: number;
} & A>;
type CreateSchemaFlatVectorField = CreateSchemaVectorField<VectorAlgorithms$1.FLAT, {
    BLOCK_SIZE?: number;
}>;
type CreateSchemaHNSWVectorField = CreateSchemaVectorField<VectorAlgorithms$1.HNSW, {
    M?: number;
    EF_CONSTRUCTION?: number;
    EF_RUNTIME?: number;
}>;
declare const SCHEMA_GEO_SHAPE_COORD_SYSTEM: {
    readonly SPHERICAL: "SPHERICAL";
    readonly FLAT: "FLAT";
};
type SchemaGeoShapeFieldCoordSystem = typeof SCHEMA_GEO_SHAPE_COORD_SYSTEM[keyof typeof SCHEMA_GEO_SHAPE_COORD_SYSTEM];
type CreateSchemaGeoShapeField = CreateSchemaCommonField<SchemaFieldTypes$1.GEOSHAPE, {
    COORD_SYSTEM?: SchemaGeoShapeFieldCoordSystem;
}>;
interface RediSearchSchema {
    [field: string]: CreateSchemaTextField | CreateSchemaNumericField | CreateSchemaGeoField | CreateSchemaTagField | CreateSchemaFlatVectorField | CreateSchemaHNSWVectorField | CreateSchemaGeoShapeField;
}
type Params = Record<string, RedisCommandArgument$2 | number>;
interface SearchDocumentValue {
    [key: string]: string | number | null | Array<SearchDocumentValue> | SearchDocumentValue;
}
interface SearchReply {
    total: number;
    documents: Array<{
        id: string;
        value: SearchDocumentValue;
    }>;
}
interface ProfileOptions {
    LIMITED?: true;
}
type ProfileRawReply<T> = [
    results: T,
    profile: [
        _: string,
        TotalProfileTime: string,
        _: string,
        ParsingTime: string,
        _: string,
        PipelineCreationTime: string,
        _: string,
        IteratorsProfile: Array<any>
    ]
];
interface ProfileReply {
    results: SearchReply | AggregateReply$1;
    profile: ProfileData;
}
interface ChildIterator {
    type?: string;
    counter?: number;
    term?: string;
    size?: number;
    time?: string;
    childIterators?: Array<ChildIterator>;
}
interface IteratorsProfile {
    type?: string;
    counter?: number;
    queryType?: string;
    time?: string;
    childIterators?: Array<ChildIterator>;
}
interface ProfileData {
    totalProfileTime: string;
    parsingTime: string;
    pipelineCreationTime: string;
    iteratorsProfile: IteratorsProfile;
}

interface SearchOptions$1 {
    VERBATIM?: true;
    NOSTOPWORDS?: true;
    WITHSORTKEYS?: true;
    INKEYS?: string | Array<string>;
    INFIELDS?: string | Array<string>;
    RETURN?: string | Array<string>;
    SUMMARIZE?: true | {
        FIELDS?: PropertyName | Array<PropertyName>;
        FRAGS?: number;
        LEN?: number;
        SEPARATOR?: string;
    };
    HIGHLIGHT?: true | {
        FIELDS?: PropertyName | Array<PropertyName>;
        TAGS?: {
            open: string;
            close: string;
        };
    };
    SLOP?: number;
    INORDER?: true;
    LANGUAGE?: RedisSearchLanguages$1;
    EXPANDER?: string;
    SCORER?: string;
    SORTBY?: SortByProperty;
    LIMIT?: {
        from: number | string;
        size: number | string;
    };
    PARAMS?: Params;
    DIALECT?: number;
    TIMEOUT?: number;
}
type SearchRawReply$1 = Array<any>;

declare const FIRST_KEY_INDEX$w = 1;
declare const IS_READ_ONLY$j = true;
declare function transformArguments$T(index: string, query: string, options?: SearchOptions$1): RedisCommandArguments$2;
interface SearchNoContentReply {
    total: number;
    documents: Array<string>;
}
declare function transformReply$N(reply: SearchRawReply$1): SearchNoContentReply;

type _redis_search_dist_commands_SEARCH_NOCONTENT_SearchNoContentReply = SearchNoContentReply;
declare namespace _redis_search_dist_commands_SEARCH_NOCONTENT {
  export { FIRST_KEY_INDEX$w as FIRST_KEY_INDEX, IS_READ_ONLY$j as IS_READ_ONLY, type _redis_search_dist_commands_SEARCH_NOCONTENT_SearchNoContentReply as SearchNoContentReply, transformArguments$T as transformArguments, transformReply$N as transformReply };
}

declare const FIRST_KEY_INDEX$v = 1;
declare const IS_READ_ONLY$i = true;
interface SearchOptions {
    VERBATIM?: true;
    NOSTOPWORDS?: true;
    WITHSORTKEYS?: true;
    INKEYS?: string | Array<string>;
    INFIELDS?: string | Array<string>;
    RETURN?: string | Array<string>;
    SUMMARIZE?: true | {
        FIELDS?: PropertyName | Array<PropertyName>;
        FRAGS?: number;
        LEN?: number;
        SEPARATOR?: string;
    };
    HIGHLIGHT?: true | {
        FIELDS?: PropertyName | Array<PropertyName>;
        TAGS?: {
            open: string;
            close: string;
        };
    };
    SLOP?: number;
    INORDER?: true;
    LANGUAGE?: RedisSearchLanguages$1;
    EXPANDER?: string;
    SCORER?: string;
    SORTBY?: SortByProperty;
    LIMIT?: {
        from: number | string;
        size: number | string;
    };
    PARAMS?: Params;
    DIALECT?: number;
    TIMEOUT?: number;
}
declare function transformArguments$S(index: string, query: string, options?: SearchOptions): RedisCommandArguments$2;
type SearchRawReply = Array<any>;
declare function transformReply$M(reply: SearchRawReply, withoutDocuments: boolean): SearchReply;

type _redis_search_dist_commands_SEARCH_SearchOptions = SearchOptions;
type _redis_search_dist_commands_SEARCH_SearchRawReply = SearchRawReply;
declare namespace _redis_search_dist_commands_SEARCH {
  export { FIRST_KEY_INDEX$v as FIRST_KEY_INDEX, IS_READ_ONLY$i as IS_READ_ONLY, type _redis_search_dist_commands_SEARCH_SearchOptions as SearchOptions, type _redis_search_dist_commands_SEARCH_SearchRawReply as SearchRawReply, transformArguments$S as transformArguments, transformReply$M as transformReply };
}

declare const IS_READ_ONLY$h = true;
declare function transformArguments$R(index: string, query: string, options?: ProfileOptions & AggregateOptions$1): Array<string>;
type ProfileAggeregateRawReply = ProfileRawReply<AggregateRawReply$1>;
declare function transformReply$L(reply: ProfileAggeregateRawReply): ProfileReply;

declare namespace _redis_search_dist_commands_PROFILE_AGGREGATE {
  export { IS_READ_ONLY$h as IS_READ_ONLY, transformArguments$R as transformArguments, transformReply$L as transformReply };
}

declare const IS_READ_ONLY$g = true;
declare function transformArguments$Q(index: string, query: string, options?: ProfileOptions & SearchOptions$1): RedisCommandArguments$2;
type ProfileSearchRawReply = ProfileRawReply<SearchRawReply$1>;
declare function transformReply$K(reply: ProfileSearchRawReply, withoutDocuments: boolean): ProfileReply;

declare namespace _redis_search_dist_commands_PROFILE_SEARCH {
  export { IS_READ_ONLY$g as IS_READ_ONLY, transformArguments$Q as transformArguments, transformReply$K as transformReply };
}

declare function transformArguments$P(index: string): Array<string>;
type InfoRawReply = [
    'index_name',
    RedisCommandArgument$2,
    'index_options',
    Array<RedisCommandArgument$2>,
    'index_definition',
    Array<RedisCommandArgument$2>,
    'attributes',
    Array<Array<RedisCommandArgument$2>>,
    'num_docs',
    RedisCommandArgument$2,
    'max_doc_id',
    RedisCommandArgument$2,
    'num_terms',
    RedisCommandArgument$2,
    'num_records',
    RedisCommandArgument$2,
    'inverted_sz_mb',
    RedisCommandArgument$2,
    'vector_index_sz_mb',
    RedisCommandArgument$2,
    'total_inverted_index_blocks',
    RedisCommandArgument$2,
    'offset_vectors_sz_mb',
    RedisCommandArgument$2,
    'doc_table_size_mb',
    RedisCommandArgument$2,
    'sortable_values_size_mb',
    RedisCommandArgument$2,
    'key_table_size_mb',
    RedisCommandArgument$2,
    'records_per_doc_avg',
    RedisCommandArgument$2,
    'bytes_per_record_avg',
    RedisCommandArgument$2,
    'offsets_per_term_avg',
    RedisCommandArgument$2,
    'offset_bits_per_record_avg',
    RedisCommandArgument$2,
    'hash_indexing_failures',
    RedisCommandArgument$2,
    'indexing',
    RedisCommandArgument$2,
    'percent_indexed',
    RedisCommandArgument$2,
    'gc_stats',
    [
        'bytes_collected',
        RedisCommandArgument$2,
        'total_ms_run',
        RedisCommandArgument$2,
        'total_cycles',
        RedisCommandArgument$2,
        'average_cycle_time_ms',
        RedisCommandArgument$2,
        'last_run_time_ms',
        RedisCommandArgument$2,
        'gc_numeric_trees_missed',
        RedisCommandArgument$2,
        'gc_blocks_denied',
        RedisCommandArgument$2
    ],
    'cursor_stats',
    [
        'global_idle',
        number,
        'global_total',
        number,
        'index_capacity',
        number,
        'index_total',
        number
    ],
    'stopwords_list'?,
    Array<RedisCommandArgument$2>?
];
interface InfoReply {
    indexName: RedisCommandArgument$2;
    indexOptions: Array<RedisCommandArgument$2>;
    indexDefinition: Record<string, RedisCommandArgument$2>;
    attributes: Array<Record<string, RedisCommandArgument$2>>;
    numDocs: RedisCommandArgument$2;
    maxDocId: RedisCommandArgument$2;
    numTerms: RedisCommandArgument$2;
    numRecords: RedisCommandArgument$2;
    invertedSzMb: RedisCommandArgument$2;
    vectorIndexSzMb: RedisCommandArgument$2;
    totalInvertedIndexBlocks: RedisCommandArgument$2;
    offsetVectorsSzMb: RedisCommandArgument$2;
    docTableSizeMb: RedisCommandArgument$2;
    sortableValuesSizeMb: RedisCommandArgument$2;
    keyTableSizeMb: RedisCommandArgument$2;
    recordsPerDocAvg: RedisCommandArgument$2;
    bytesPerRecordAvg: RedisCommandArgument$2;
    offsetsPerTermAvg: RedisCommandArgument$2;
    offsetBitsPerRecordAvg: RedisCommandArgument$2;
    hashIndexingFailures: RedisCommandArgument$2;
    indexing: RedisCommandArgument$2;
    percentIndexed: RedisCommandArgument$2;
    gcStats: {
        bytesCollected: RedisCommandArgument$2;
        totalMsRun: RedisCommandArgument$2;
        totalCycles: RedisCommandArgument$2;
        averageCycleTimeMs: RedisCommandArgument$2;
        lastRunTimeMs: RedisCommandArgument$2;
        gcNumericTreesMissed: RedisCommandArgument$2;
        gcBlocksDenied: RedisCommandArgument$2;
    };
    cursorStats: {
        globalIdle: number;
        globalTotal: number;
        indexCapacity: number;
        idnexTotal: number;
    };
    stopWords: Array<RedisCommandArgument$2> | undefined;
}
declare function transformReply$J(rawReply: InfoRawReply): InfoReply;

declare namespace _redis_search_dist_commands_INFO {
  export { transformArguments$P as transformArguments, transformReply$J as transformReply };
}

declare const IS_READ_ONLY$f = true;
declare function transformArguments$O(index: string, query: string): Array<string>;
declare function transformReply$I(): Array<string>;

declare namespace _redis_search_dist_commands_EXPLAINCLI {
  export { IS_READ_ONLY$f as IS_READ_ONLY, transformArguments$O as transformArguments, transformReply$I as transformReply };
}

declare const IS_READ_ONLY$e = true;
interface ExplainOptions {
    PARAMS?: Params;
    DIALECT?: number;
}
declare function transformArguments$N(index: string, query: string, options?: ExplainOptions): Array<string>;
declare function transformReply$H(): string;

declare namespace _redis_search_dist_commands_EXPLAIN {
  export { IS_READ_ONLY$e as IS_READ_ONLY, transformArguments$N as transformArguments, transformReply$H as transformReply };
}

interface DropIndexOptions {
    DD?: true;
}
declare function transformArguments$M(index: string, options?: DropIndexOptions): Array<string>;
declare function transformReply$G(): 'OK';

declare namespace _redis_search_dist_commands_DROPINDEX {
  export { transformArguments$M as transformArguments, transformReply$G as transformReply };
}

declare function transformArguments$L(dictionary: string): Array<string>;
declare function transformReply$F(): Array<string>;

declare namespace _redis_search_dist_commands_DICTDUMP {
  export { transformArguments$L as transformArguments, transformReply$F as transformReply };
}

declare function transformArguments$K(dictionary: string, term: string | Array<string>): RedisCommandArguments$2;
declare function transformReply$E(): number;

declare namespace _redis_search_dist_commands_DICTDEL {
  export { transformArguments$K as transformArguments, transformReply$E as transformReply };
}

declare function transformArguments$J(dictionary: string, term: string | Array<string>): RedisCommandArguments$2;
declare function transformReply$D(): number;

declare namespace _redis_search_dist_commands_DICTADD {
  export { transformArguments$J as transformArguments, transformReply$D as transformReply };
}

declare const FIRST_KEY_INDEX$u = 1;
declare const IS_READ_ONLY$d = true;
interface CursorReadOptions {
    COUNT?: number;
}
declare function transformArguments$I(index: RedisCommandArgument$2, cursor: number, options?: CursorReadOptions): RedisCommandArguments$2;

declare namespace _redis_search_dist_commands_CURSOR_READ {
  export { FIRST_KEY_INDEX$u as FIRST_KEY_INDEX, IS_READ_ONLY$d as IS_READ_ONLY, transformArguments$I as transformArguments, transformReply$O as transformReply };
}

declare const FIRST_KEY_INDEX$t = 1;
declare function transformArguments$H(index: RedisCommandArgument$2, cursorId: number): RedisCommandArgument$2[];
declare function transformReply$C(): 'OK';

declare namespace _redis_search_dist_commands_CURSOR_DEL {
  export { FIRST_KEY_INDEX$t as FIRST_KEY_INDEX, transformArguments$H as transformArguments, transformReply$C as transformReply };
}

interface CreateOptions {
    ON?: 'HASH' | 'JSON';
    PREFIX?: string | Array<string>;
    FILTER?: string;
    LANGUAGE?: RedisSearchLanguages$1;
    LANGUAGE_FIELD?: PropertyName;
    SCORE?: number;
    SCORE_FIELD?: PropertyName;
    MAXTEXTFIELDS?: true;
    TEMPORARY?: number;
    NOOFFSETS?: true;
    NOHL?: true;
    NOFIELDS?: true;
    NOFREQS?: true;
    SKIPINITIALSCAN?: true;
    STOPWORDS?: string | Array<string>;
}
declare function transformArguments$G(index: string, schema: RediSearchSchema, options?: CreateOptions): Array<string>;
declare function transformReply$B(): 'OK';

declare namespace _redis_search_dist_commands_CREATE {
  export { transformArguments$G as transformArguments, transformReply$B as transformReply };
}

declare function transformArguments$F(option: string, value: string): Array<string>;
declare function transformReply$A(): 'OK';

declare namespace _redis_search_dist_commands_CONFIG_SET {
  export { transformArguments$F as transformArguments, transformReply$A as transformReply };
}

declare function transformArguments$E(option: string): string[];
interface ConfigGetReply {
    [option: string]: string | null;
}
declare function transformReply$z(rawReply: Array<[string, string | null]>): ConfigGetReply;

declare namespace _redis_search_dist_commands_CONFIG_GET {
  export { transformArguments$E as transformArguments, transformReply$z as transformReply };
}

declare function transformArguments$D(name: string, index: string): Array<string>;
declare function transformReply$y(): 'OK';

declare namespace _redis_search_dist_commands_ALIASUPDATE {
  export { transformArguments$D as transformArguments, transformReply$y as transformReply };
}

declare function transformArguments$C(name: string, index: string): Array<string>;
declare function transformReply$x(): 'OK';

declare namespace _redis_search_dist_commands_ALIASDEL {
  export { transformArguments$C as transformArguments, transformReply$x as transformReply };
}

declare function transformArguments$B(name: string, index: string): Array<string>;
declare function transformReply$w(): 'OK';

declare namespace _redis_search_dist_commands_ALIASADD {
  export { transformArguments$B as transformArguments, transformReply$w as transformReply };
}

declare enum AggregateSteps$1 {
    GROUPBY = "GROUPBY",
    SORTBY = "SORTBY",
    APPLY = "APPLY",
    LIMIT = "LIMIT",
    FILTER = "FILTER"
}
interface AggregateStep<T extends AggregateSteps$1> {
    type: T;
}
declare enum AggregateGroupByReducers$1 {
    COUNT = "COUNT",
    COUNT_DISTINCT = "COUNT_DISTINCT",
    COUNT_DISTINCTISH = "COUNT_DISTINCTISH",
    SUM = "SUM",
    MIN = "MIN",
    MAX = "MAX",
    AVG = "AVG",
    STDDEV = "STDDEV",
    QUANTILE = "QUANTILE",
    TOLIST = "TOLIST",
    TO_LIST = "TOLIST",
    FIRST_VALUE = "FIRST_VALUE",
    RANDOM_SAMPLE = "RANDOM_SAMPLE"
}
interface GroupByReducer<T extends AggregateGroupByReducers$1> {
    type: T;
    AS?: string;
}
type CountReducer = GroupByReducer<AggregateGroupByReducers$1.COUNT>;
interface CountDistinctReducer extends GroupByReducer<AggregateGroupByReducers$1.COUNT_DISTINCT> {
    property: PropertyName;
}
interface CountDistinctishReducer extends GroupByReducer<AggregateGroupByReducers$1.COUNT_DISTINCTISH> {
    property: PropertyName;
}
interface SumReducer extends GroupByReducer<AggregateGroupByReducers$1.SUM> {
    property: PropertyName;
}
interface MinReducer extends GroupByReducer<AggregateGroupByReducers$1.MIN> {
    property: PropertyName;
}
interface MaxReducer extends GroupByReducer<AggregateGroupByReducers$1.MAX> {
    property: PropertyName;
}
interface AvgReducer extends GroupByReducer<AggregateGroupByReducers$1.AVG> {
    property: PropertyName;
}
interface StdDevReducer extends GroupByReducer<AggregateGroupByReducers$1.STDDEV> {
    property: PropertyName;
}
interface QuantileReducer extends GroupByReducer<AggregateGroupByReducers$1.QUANTILE> {
    property: PropertyName;
    quantile: number;
}
interface ToListReducer extends GroupByReducer<AggregateGroupByReducers$1.TOLIST> {
    property: PropertyName;
}
interface FirstValueReducer extends GroupByReducer<AggregateGroupByReducers$1.FIRST_VALUE> {
    property: PropertyName;
    BY?: PropertyName | {
        property: PropertyName;
        direction?: 'ASC' | 'DESC';
    };
}
interface RandomSampleReducer extends GroupByReducer<AggregateGroupByReducers$1.RANDOM_SAMPLE> {
    property: PropertyName;
    sampleSize: number;
}
type GroupByReducers = CountReducer | CountDistinctReducer | CountDistinctishReducer | SumReducer | MinReducer | MaxReducer | AvgReducer | StdDevReducer | QuantileReducer | ToListReducer | FirstValueReducer | RandomSampleReducer;
interface GroupByStep extends AggregateStep<AggregateSteps$1.GROUPBY> {
    properties?: PropertyName | Array<PropertyName>;
    REDUCE: GroupByReducers | Array<GroupByReducers>;
}
interface SortStep extends AggregateStep<AggregateSteps$1.SORTBY> {
    BY: SortByProperty | Array<SortByProperty>;
    MAX?: number;
}
interface ApplyStep extends AggregateStep<AggregateSteps$1.APPLY> {
    expression: string;
    AS: string;
}
interface LimitStep extends AggregateStep<AggregateSteps$1.LIMIT> {
    from: number;
    size: number;
}
interface FilterStep extends AggregateStep<AggregateSteps$1.FILTER> {
    expression: string;
}
type LoadField = PropertyName | {
    identifier: PropertyName;
    AS?: string;
};
interface AggregateOptions {
    VERBATIM?: boolean;
    ADDSCORES?: boolean;
    LOAD?: LoadField | Array<LoadField>;
    STEPS?: Array<GroupByStep | SortStep | ApplyStep | LimitStep | FilterStep>;
    PARAMS?: Params;
    DIALECT?: number;
    TIMEOUT?: number;
}
declare const FIRST_KEY_INDEX$s = 1;
declare const IS_READ_ONLY$c = true;
declare function transformArguments$A(index: string, query: string, options?: AggregateOptions): RedisCommandArguments$2;
declare function pushAggregatehOptions(args: RedisCommandArguments$2, options?: AggregateOptions): RedisCommandArguments$2;
type AggregateRawReply = [
    total: number,
    ...results: Array<Array<RedisCommandArgument$2>>
];
interface AggregateReply {
    total: number;
    results: Array<Record<string, RedisCommandArgument$2>>;
}
declare function transformReply$v(rawReply: AggregateRawReply): AggregateReply;

type _redis_search_dist_commands_AGGREGATE_AggregateOptions = AggregateOptions;
type _redis_search_dist_commands_AGGREGATE_AggregateRawReply = AggregateRawReply;
type _redis_search_dist_commands_AGGREGATE_AggregateReply = AggregateReply;
declare const _redis_search_dist_commands_AGGREGATE_pushAggregatehOptions: typeof pushAggregatehOptions;
declare namespace _redis_search_dist_commands_AGGREGATE {
  export { AggregateGroupByReducers$1 as AggregateGroupByReducers, type _redis_search_dist_commands_AGGREGATE_AggregateOptions as AggregateOptions, type _redis_search_dist_commands_AGGREGATE_AggregateRawReply as AggregateRawReply, type _redis_search_dist_commands_AGGREGATE_AggregateReply as AggregateReply, AggregateSteps$1 as AggregateSteps, FIRST_KEY_INDEX$s as FIRST_KEY_INDEX, IS_READ_ONLY$c as IS_READ_ONLY, _redis_search_dist_commands_AGGREGATE_pushAggregatehOptions as pushAggregatehOptions, transformArguments$A as transformArguments, transformReply$v as transformReply };
}

interface AggregateWithCursorOptions extends AggregateOptions$1 {
    COUNT?: number;
}
declare function transformArguments$z(index: string, query: string, options?: AggregateWithCursorOptions): RedisCommandArguments$2;
type AggregateWithCursorRawReply = [
    result: AggregateRawReply$1,
    cursor: number
];
interface AggregateWithCursorReply extends AggregateReply$1 {
    cursor: number;
}
declare function transformReply$u(reply: AggregateWithCursorRawReply): AggregateWithCursorReply;

declare namespace _redis_search_dist_commands_AGGREGATE_WITHCURSOR {
  export { FIRST_KEY_INDEX$x as FIRST_KEY_INDEX, IS_READ_ONLY$k as IS_READ_ONLY, transformArguments$z as transformArguments, transformReply$u as transformReply };
}

declare function transformArguments$y(index: string, schema: RediSearchSchema): Array<string>;
declare function transformReply$t(): 'OK';

declare namespace _redis_search_dist_commands_ALTER {
  export { transformArguments$y as transformArguments, transformReply$t as transformReply };
}

declare function transformArguments$x(): Array<string>;
declare function transformReply$s(): Array<string>;

declare namespace _redis_search_dist_commands__LIST {
  export { transformArguments$x as transformArguments, transformReply$s as transformReply };
}

declare const FIRST_KEY_INDEX$r = 1;
declare function transformArguments$w(key: string, path?: string): Array<string>;
declare function transformReply$r(): string | null | Array<string | null>;

declare namespace _redis_json_dist_commands_TYPE {
  export { FIRST_KEY_INDEX$r as FIRST_KEY_INDEX, transformArguments$w as transformArguments, transformReply$r as transformReply };
}

declare const FIRST_KEY_INDEX$q = 1;
declare const IS_READ_ONLY$b = true;
declare function transformArguments$v(key: string, path?: string): Array<string>;
declare function transformReply$q(): number;

declare namespace _redis_json_dist_commands_STRLEN {
  export { FIRST_KEY_INDEX$q as FIRST_KEY_INDEX, IS_READ_ONLY$b as IS_READ_ONLY, transformArguments$v as transformArguments, transformReply$q as transformReply };
}

declare const FIRST_KEY_INDEX$p = 1;
type AppendArguments = [key: string, append: string];
type AppendWithPathArguments = [key: string, path: string, append: string];
declare function transformArguments$u(...[key, pathOrAppend, append]: AppendArguments | AppendWithPathArguments): Array<string>;
declare function transformReply$p(): number | Array<number>;

declare namespace _redis_json_dist_commands_STRAPPEND {
  export { FIRST_KEY_INDEX$p as FIRST_KEY_INDEX, transformArguments$u as transformArguments, transformReply$p as transformReply };
}

type RedisCommandArgument$1 = string | Buffer;
type RedisCommandArguments$1 = Array<RedisCommandArgument$1> & {
    preserve?: unknown;
};

interface RedisJSONArray extends Array<RedisJSON> {
}
interface RedisJSONObject {
    [key: string]: RedisJSON;
    [key: number]: RedisJSON;
}
type RedisJSON = null | boolean | number | string | Date | RedisJSONArray | RedisJSONObject;
declare function transformRedisJsonNullReply(json: string | null): RedisJSON | null;
declare function transformNumbersReply(reply: string): number | Array<number>;

declare const FIRST_KEY_INDEX$o = 1;
interface NX {
    NX: true;
}
interface XX {
    XX: true;
}
declare function transformArguments$t(key: string, path: string, json: RedisJSON, options?: NX | XX): Array<string>;
declare function transformReply$o(): 'OK' | null;

declare namespace _redis_json_dist_commands_SET {
  export { FIRST_KEY_INDEX$o as FIRST_KEY_INDEX, transformArguments$t as transformArguments, transformReply$o as transformReply };
}

declare const FIRST_KEY_INDEX$n = 1;
declare function transformArguments$s(key: string, path?: string): Array<string>;
type RESPReply = Array<string | number | RESPReply>;
declare function transformReply$n(): RESPReply;

declare namespace _redis_json_dist_commands_RESP {
  export { FIRST_KEY_INDEX$n as FIRST_KEY_INDEX, transformArguments$s as transformArguments, transformReply$n as transformReply };
}

declare const FIRST_KEY_INDEX$m = 1;
declare function transformArguments$r(key: string, path?: string): Array<string>;
declare function transformReply$m(): number | null | Array<number | null>;

declare namespace _redis_json_dist_commands_OBJLEN {
  export { FIRST_KEY_INDEX$m as FIRST_KEY_INDEX, transformArguments$r as transformArguments, transformReply$m as transformReply };
}

declare const FIRST_KEY_INDEX$l = 1;
declare function transformArguments$q(key: string, path?: string): Array<string>;
declare function transformReply$l(): Array<string> | null | Array<Array<string> | null>;

declare namespace _redis_json_dist_commands_OBJKEYS {
  export { FIRST_KEY_INDEX$l as FIRST_KEY_INDEX, transformArguments$q as transformArguments, transformReply$l as transformReply };
}

declare const FIRST_KEY_INDEX$k = 1;
declare function transformArguments$p(key: string, path: string, by: number): Array<string>;

declare namespace _redis_json_dist_commands_NUMMULTBY {
  export { FIRST_KEY_INDEX$k as FIRST_KEY_INDEX, transformArguments$p as transformArguments, transformNumbersReply as transformReply };
}

declare const FIRST_KEY_INDEX$j = 1;
declare function transformArguments$o(key: string, path: string, by: number): Array<string>;

declare namespace _redis_json_dist_commands_NUMINCRBY {
  export { FIRST_KEY_INDEX$j as FIRST_KEY_INDEX, transformArguments$o as transformArguments, transformNumbersReply as transformReply };
}

declare const FIRST_KEY_INDEX$i = 1;
interface JsonMSetItem {
    key: RedisCommandArgument$1;
    path: RedisCommandArgument$1;
    value: RedisJSON;
}
declare function transformArguments$n(items: Array<JsonMSetItem>): Array<string>;
declare function transformReply$k(): 'OK';

declare namespace _redis_json_dist_commands_MSET {
  export { FIRST_KEY_INDEX$i as FIRST_KEY_INDEX, transformArguments$n as transformArguments, transformReply$k as transformReply };
}

declare const FIRST_KEY_INDEX$h = 1;
declare const IS_READ_ONLY$a = true;
declare function transformArguments$m(keys: Array<string>, path: string): Array<string>;
declare function transformReply$j(reply: Array<string | null>): Array<RedisJSON | null>;

declare namespace _redis_json_dist_commands_MGET {
  export { FIRST_KEY_INDEX$h as FIRST_KEY_INDEX, IS_READ_ONLY$a as IS_READ_ONLY, transformArguments$m as transformArguments, transformReply$j as transformReply };
}

declare const FIRST_KEY_INDEX$g = 1;
declare function transformArguments$l(key: string, path: string, json: RedisJSON): Array<string>;
declare function transformReply$i(): 'OK';

declare namespace _redis_json_dist_commands_MERGE {
  export { FIRST_KEY_INDEX$g as FIRST_KEY_INDEX, transformArguments$l as transformArguments, transformReply$i as transformReply };
}

declare const FIRST_KEY_INDEX$f = 1;
declare const IS_READ_ONLY$9 = true;
interface GetOptions {
    path?: string | Array<string>;
    INDENT?: string;
    NEWLINE?: string;
    SPACE?: string;
    NOESCAPE?: true;
}
declare function transformArguments$k(key: string, options?: GetOptions): RedisCommandArguments$1;

declare namespace _redis_json_dist_commands_GET {
  export { FIRST_KEY_INDEX$f as FIRST_KEY_INDEX, IS_READ_ONLY$9 as IS_READ_ONLY, transformArguments$k as transformArguments, transformRedisJsonNullReply as transformReply };
}

declare const FIRST_KEY_INDEX$e = 1;
declare function transformArguments$j(key: string, path?: string): Array<string>;
declare function transformReply$h(): number;

declare namespace _redis_json_dist_commands_FORGET {
  export { FIRST_KEY_INDEX$e as FIRST_KEY_INDEX, transformArguments$j as transformArguments, transformReply$h as transformReply };
}

declare const FIRST_KEY_INDEX$d = 1;
declare function transformArguments$i(key: string, path?: string): Array<string>;
declare function transformReply$g(): number;

declare namespace _redis_json_dist_commands_DEL {
  export { FIRST_KEY_INDEX$d as FIRST_KEY_INDEX, transformArguments$i as transformArguments, transformReply$g as transformReply };
}

declare const FIRST_KEY_INDEX$c = 2;
declare function transformArguments$h(key: string, path?: string): Array<string>;
declare function transformReply$f(): number;

declare namespace _redis_json_dist_commands_DEBUG_MEMORY {
  export { FIRST_KEY_INDEX$c as FIRST_KEY_INDEX, transformArguments$h as transformArguments, transformReply$f as transformReply };
}

declare const FIRST_KEY_INDEX$b = 1;
declare function transformArguments$g(key: string, path: string, start: number, stop: number): Array<string>;
declare function transformReply$e(): number | Array<number>;

declare namespace _redis_json_dist_commands_ARRTRIM {
  export { FIRST_KEY_INDEX$b as FIRST_KEY_INDEX, transformArguments$g as transformArguments, transformReply$e as transformReply };
}

declare const FIRST_KEY_INDEX$a = 1;
declare function transformArguments$f(key: string, path?: string, index?: number): Array<string>;
declare function transformReply$d(reply: null | string | Array<null | string>): null | RedisJSON | Array<RedisJSON>;

declare namespace _redis_json_dist_commands_ARRPOP {
  export { FIRST_KEY_INDEX$a as FIRST_KEY_INDEX, transformArguments$f as transformArguments, transformReply$d as transformReply };
}

declare const FIRST_KEY_INDEX$9 = 1;
declare const IS_READ_ONLY$8 = true;
declare function transformArguments$e(key: string, path?: string): Array<string>;
declare function transformReply$c(): number | Array<number>;

declare namespace _redis_json_dist_commands_ARRLEN {
  export { FIRST_KEY_INDEX$9 as FIRST_KEY_INDEX, IS_READ_ONLY$8 as IS_READ_ONLY, transformArguments$e as transformArguments, transformReply$c as transformReply };
}

declare const FIRST_KEY_INDEX$8 = 1;
declare function transformArguments$d(key: string, path: string, index: number, ...jsons: Array<RedisJSON>): Array<string>;
declare function transformReply$b(): number | Array<number>;

declare namespace _redis_json_dist_commands_ARRINSERT {
  export { FIRST_KEY_INDEX$8 as FIRST_KEY_INDEX, transformArguments$d as transformArguments, transformReply$b as transformReply };
}

declare const FIRST_KEY_INDEX$7 = 1;
declare const IS_READ_ONLY$7 = true;
declare function transformArguments$c(key: string, path: string, json: RedisJSON, start?: number, stop?: number): Array<string>;
declare function transformReply$a(): number | Array<number>;

declare namespace _redis_json_dist_commands_ARRINDEX {
  export { FIRST_KEY_INDEX$7 as FIRST_KEY_INDEX, IS_READ_ONLY$7 as IS_READ_ONLY, transformArguments$c as transformArguments, transformReply$a as transformReply };
}

declare const FIRST_KEY_INDEX$6 = 1;
declare function transformArguments$b(key: string, path: string, ...jsons: Array<RedisJSON>): Array<string>;
declare function transformReply$9(): number | Array<number>;

declare namespace _redis_json_dist_commands_ARRAPPEND {
  export { FIRST_KEY_INDEX$6 as FIRST_KEY_INDEX, transformArguments$b as transformArguments, transformReply$9 as transformReply };
}

declare const IS_READ_ONLY$6 = true;
declare const FIRST_KEY_INDEX$5 = 1;
declare function transformArguments$a(key: string): string[];
type SlowLogRawReply = Array<[
    timestamp: string,
    command: string,
    query: string,
    took: string
]>;
type SlowLogReply = Array<{
    timestamp: Date;
    command: string;
    query: string;
    took: number;
}>;
declare function transformReply$8(logs: SlowLogRawReply): SlowLogReply;

declare namespace _redis_graph_dist_commands_SLOWLOG {
  export { FIRST_KEY_INDEX$5 as FIRST_KEY_INDEX, IS_READ_ONLY$6 as IS_READ_ONLY, transformArguments$a as transformArguments, transformReply$8 as transformReply };
}

type RedisCommandArgument = string | Buffer;
type RedisCommandArguments = Array<RedisCommandArgument> & {
    preserve?: unknown;
};
interface RedisCommand {
    FIRST_KEY_INDEX?: number | ((...args: Array<any>) => RedisCommandArgument | undefined);
    IS_READ_ONLY?: boolean;
    TRANSFORM_LEGACY_REPLY?: boolean;
    transformArguments(this: void, ...args: Array<any>): RedisCommandArguments;
    transformReply?(this: void, reply: any, preserved?: any): any;
}
interface RedisFunction extends RedisCommand {
    NUMBER_OF_KEYS?: number;
}
interface RedisFunctionLibrary {
    [fn: string]: RedisFunction;
}
interface RedisFunctions {
    [library: string]: RedisFunctionLibrary;
}
type RedisScript = RedisScriptConfig & SHA1;
interface RedisScripts {
    [script: string]: RedisScript;
}

declare const FIRST_KEY_INDEX$4 = 1;
declare function transformArguments$9(graph: RedisCommandArgument, query: RedisCommandArgument, options?: QueryOptionsBackwardCompatible, compact?: boolean): RedisCommandArguments;
type Headers$1 = Array<string>;
type Data$1 = Array<string | number | null | Data$1>;
type Metadata$1 = Array<string>;
type QueryRawReply$1 = [
    headers: Headers$1,
    data: Data$1,
    metadata: Metadata$1
] | [
    metadata: Metadata$1
];
type QueryReply$1 = {
    headers: undefined;
    data: undefined;
    metadata: Metadata$1;
} | {
    headers: Headers$1;
    data: Data$1;
    metadata: Metadata$1;
};
declare function transformReply$7(reply: QueryRawReply$1): QueryReply$1;

declare namespace __commands_QUERY {
  export { FIRST_KEY_INDEX$4 as FIRST_KEY_INDEX, type QueryReply$1 as QueryReply, transformArguments$9 as transformArguments, transformReply$7 as transformReply };
}

declare const IS_READ_ONLY$5 = true;
declare function transformArguments$8(graph: RedisCommandArgument, query: RedisCommandArgument, options?: QueryOptionsBackwardCompatible, compact?: boolean): RedisCommandArguments;

declare namespace __commands_RO_QUERY {
  export { FIRST_KEY_INDEX$4 as FIRST_KEY_INDEX, IS_READ_ONLY$5 as IS_READ_ONLY, transformArguments$8 as transformArguments, transformReply$7 as transformReply };
}

type QueryParam = null | string | number | boolean | QueryParams | Array<QueryParam>;
type QueryParams = {
    [key: string]: QueryParam;
};
interface QueryOptions {
    params?: QueryParams;
    TIMEOUT?: number;
}
type QueryOptionsBackwardCompatible = QueryOptions | number;

declare const IS_READ_ONLY$4 = true;
declare function transformArguments$7(graph: RedisCommandArgument, query: RedisCommandArgument, options?: QueryOptionsBackwardCompatible, compact?: boolean): RedisCommandArguments;

declare namespace _redis_graph_dist_commands_RO_QUERY {
  export { FIRST_KEY_INDEX$4 as FIRST_KEY_INDEX, IS_READ_ONLY$4 as IS_READ_ONLY, transformArguments$7 as transformArguments, transformReply$7 as transformReply };
}

declare const FIRST_KEY_INDEX$3 = 1;
declare function transformArguments$6(graph: RedisCommandArgument, query: RedisCommandArgument, options?: QueryOptionsBackwardCompatible, compact?: boolean): RedisCommandArguments;
type Headers = Array<string>;
type Data = Array<string | number | null | Data>;
type Metadata = Array<string>;
type QueryRawReply = [
    headers: Headers,
    data: Data,
    metadata: Metadata
] | [
    metadata: Metadata
];
type QueryReply = {
    headers: undefined;
    data: undefined;
    metadata: Metadata;
} | {
    headers: Headers;
    data: Data;
    metadata: Metadata;
};
declare function transformReply$6(reply: QueryRawReply): QueryReply;

type _redis_graph_dist_commands_QUERY_QueryReply = QueryReply;
declare namespace _redis_graph_dist_commands_QUERY {
  export { FIRST_KEY_INDEX$3 as FIRST_KEY_INDEX, type _redis_graph_dist_commands_QUERY_QueryReply as QueryReply, transformArguments$6 as transformArguments, transformReply$6 as transformReply };
}

declare const FIRST_KEY_INDEX$2 = 1;
declare const IS_READ_ONLY$3 = true;
declare function transformArguments$5(key: string, query: string): Array<string>;
declare function transformReply$5(): Array<string>;

declare namespace _redis_graph_dist_commands_PROFILE {
  export { FIRST_KEY_INDEX$2 as FIRST_KEY_INDEX, IS_READ_ONLY$3 as IS_READ_ONLY, transformArguments$5 as transformArguments, transformReply$5 as transformReply };
}

declare const IS_READ_ONLY$2 = true;
declare function transformArguments$4(): Array<string>;
declare function transformReply$4(): Array<string>;

declare namespace _redis_graph_dist_commands_LIST {
  export { IS_READ_ONLY$2 as IS_READ_ONLY, transformArguments$4 as transformArguments, transformReply$4 as transformReply };
}

declare const FIRST_KEY_INDEX$1 = 1;
declare const IS_READ_ONLY$1 = true;
declare function transformArguments$3(key: string, query: string): Array<string>;
declare function transformReply$3(): Array<string>;

declare namespace _redis_graph_dist_commands_EXPLAIN {
  export { FIRST_KEY_INDEX$1 as FIRST_KEY_INDEX, IS_READ_ONLY$1 as IS_READ_ONLY, transformArguments$3 as transformArguments, transformReply$3 as transformReply };
}

declare const FIRST_KEY_INDEX = 1;
declare function transformArguments$2(key: string): Array<string>;
declare function transformReply$2(): string;

declare const _redis_graph_dist_commands_DELETE_FIRST_KEY_INDEX: typeof FIRST_KEY_INDEX;
declare namespace _redis_graph_dist_commands_DELETE {
  export { _redis_graph_dist_commands_DELETE_FIRST_KEY_INDEX as FIRST_KEY_INDEX, transformArguments$2 as transformArguments, transformReply$2 as transformReply };
}

declare function transformArguments$1(configKey: string, value: number): Array<string>;
declare function transformReply$1(): 'OK';

declare namespace _redis_graph_dist_commands_CONFIG_SET {
  export { transformArguments$1 as transformArguments, transformReply$1 as transformReply };
}

declare const IS_READ_ONLY = true;
declare function transformArguments(configKey: string): Array<string>;
type ConfigItem = [
    configKey: string,
    value: number
];
declare function transformReply(): ConfigItem | Array<ConfigItem>;

declare const _redis_graph_dist_commands_CONFIG_GET_IS_READ_ONLY: typeof IS_READ_ONLY;
declare const _redis_graph_dist_commands_CONFIG_GET_transformArguments: typeof transformArguments;
declare const _redis_graph_dist_commands_CONFIG_GET_transformReply: typeof transformReply;
declare namespace _redis_graph_dist_commands_CONFIG_GET {
  export { _redis_graph_dist_commands_CONFIG_GET_IS_READ_ONLY as IS_READ_ONLY, _redis_graph_dist_commands_CONFIG_GET_transformArguments as transformArguments, _redis_graph_dist_commands_CONFIG_GET_transformReply as transformReply };
}

interface NodeAddress {
    host: string;
    port: number;
}
type NodeAddressMap = {
    [address: string]: NodeAddress;
} | ((address: string) => NodeAddress | undefined);
type ValueOrPromise<T> = T | Promise<T>;
type ClientOrPromise<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = ValueOrPromise<RedisClientType$2<M, F, S>>;
interface Node<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> {
    address: string;
    client?: ClientOrPromise<M, F, S>;
}
interface ShardNode<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> extends Node<M, F, S> {
    id: string;
    host: string;
    port: number;
    readonly: boolean;
}
interface MasterNode<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> extends ShardNode<M, F, S> {
    pubSubClient?: ClientOrPromise<M, F, S>;
}
interface Shard<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> {
    master: MasterNode<M, F, S>;
    replicas?: Array<ShardNode<M, F, S>>;
    nodesIterator?: IterableIterator<ShardNode<M, F, S>>;
}

declare const _default: {
    APPEND: typeof APPEND;
    append: typeof APPEND;
    BITCOUNT: typeof BITCOUNT;
    bitCount: typeof BITCOUNT;
    BITFIELD_RO: typeof BITFIELD_RO;
    bitFieldRo: typeof BITFIELD_RO;
    BITFIELD: typeof BITFIELD;
    bitField: typeof BITFIELD;
    BITOP: typeof BITOP;
    bitOp: typeof BITOP;
    BITPOS: typeof BITPOS;
    bitPos: typeof BITPOS;
    BLMOVE: typeof BLMOVE;
    blMove: typeof BLMOVE;
    BLMPOP: typeof BLMPOP;
    blmPop: typeof BLMPOP;
    BLPOP: typeof BLPOP;
    blPop: typeof BLPOP;
    BRPOP: typeof BRPOP;
    brPop: typeof BRPOP;
    BRPOPLPUSH: typeof BRPOPLPUSH;
    brPopLPush: typeof BRPOPLPUSH;
    BZMPOP: typeof BZMPOP;
    bzmPop: typeof BZMPOP;
    BZPOPMAX: typeof BZPOPMAX;
    bzPopMax: typeof BZPOPMAX;
    BZPOPMIN: typeof BZPOPMIN;
    bzPopMin: typeof BZPOPMIN;
    COPY: typeof COPY;
    copy: typeof COPY;
    DECR: typeof DECR;
    decr: typeof DECR;
    DECRBY: typeof DECRBY;
    decrBy: typeof DECRBY;
    DEL: typeof DEL;
    del: typeof DEL;
    DUMP: typeof DUMP;
    dump: typeof DUMP;
    EVAL_RO: typeof EVAL_RO;
    evalRo: typeof EVAL_RO;
    EVAL: typeof EVAL;
    eval: typeof EVAL;
    EVALSHA: typeof EVALSHA;
    evalSha: typeof EVALSHA;
    EVALSHA_RO: typeof EVALSHA_RO;
    evalShaRo: typeof EVALSHA_RO;
    EXISTS: typeof EXISTS;
    exists: typeof EXISTS;
    EXPIRE: typeof EXPIRE;
    expire: typeof EXPIRE;
    EXPIREAT: typeof EXPIREAT;
    expireAt: typeof EXPIREAT;
    EXPIRETIME: typeof EXPIRETIME;
    expireTime: typeof EXPIRETIME;
    FCALL_RO: typeof FCALL_RO;
    fCallRo: typeof FCALL_RO;
    FCALL: typeof FCALL;
    fCall: typeof FCALL;
    GEOADD: typeof GEOADD;
    geoAdd: typeof GEOADD;
    GEODIST: typeof GEODIST;
    geoDist: typeof GEODIST;
    GEOHASH: typeof GEOHASH;
    geoHash: typeof GEOHASH;
    GEOPOS: typeof GEOPOS;
    geoPos: typeof GEOPOS;
    GEORADIUS_RO_WITH: typeof GEORADIUS_RO_WITH;
    geoRadiusRoWith: typeof GEORADIUS_RO_WITH;
    GEORADIUS_RO: typeof GEORADIUS_RO;
    geoRadiusRo: typeof GEORADIUS_RO;
    GEORADIUS_WITH: typeof GEORADIUS_WITH;
    geoRadiusWith: typeof GEORADIUS_WITH;
    GEORADIUS: typeof GEORADIUS;
    geoRadius: typeof GEORADIUS;
    GEORADIUSBYMEMBER_RO_WITH: typeof GEORADIUSBYMEMBER_RO_WITH;
    geoRadiusByMemberRoWith: typeof GEORADIUSBYMEMBER_RO_WITH;
    GEORADIUSBYMEMBER_RO: typeof GEORADIUSBYMEMBER_RO;
    geoRadiusByMemberRo: typeof GEORADIUSBYMEMBER_RO;
    GEORADIUSBYMEMBER_WITH: typeof GEORADIUSBYMEMBER_WITH;
    geoRadiusByMemberWith: typeof GEORADIUSBYMEMBER_WITH;
    GEORADIUSBYMEMBER: typeof GEORADIUSBYMEMBER;
    geoRadiusByMember: typeof GEORADIUSBYMEMBER;
    GEORADIUSBYMEMBERSTORE: typeof GEORADIUSBYMEMBERSTORE;
    geoRadiusByMemberStore: typeof GEORADIUSBYMEMBERSTORE;
    GEORADIUSSTORE: typeof GEORADIUSSTORE;
    geoRadiusStore: typeof GEORADIUSSTORE;
    GEOSEARCH_WITH: typeof GEOSEARCH_WITH;
    geoSearchWith: typeof GEOSEARCH_WITH;
    GEOSEARCH: typeof GEOSEARCH;
    geoSearch: typeof GEOSEARCH;
    GEOSEARCHSTORE: typeof GEOSEARCHSTORE;
    geoSearchStore: typeof GEOSEARCHSTORE;
    GET: typeof GET;
    get: typeof GET;
    GETBIT: typeof GETBIT;
    getBit: typeof GETBIT;
    GETDEL: typeof GETDEL;
    getDel: typeof GETDEL;
    GETEX: typeof GETEX;
    getEx: typeof GETEX;
    GETRANGE: typeof GETRANGE;
    getRange: typeof GETRANGE;
    GETSET: typeof GETSET;
    getSet: typeof GETSET;
    HDEL: typeof HDEL;
    hDel: typeof HDEL;
    HEXISTS: typeof HEXISTS;
    hExists: typeof HEXISTS;
    HEXPIRE: typeof HEXPIRE;
    hExpire: typeof HEXPIRE;
    HEXPIREAT: typeof HEXPIREAT;
    hExpireAt: typeof HEXPIREAT;
    HEXPIRETIME: typeof HEXPIRETIME;
    hExpireTime: typeof HEXPIRETIME;
    HGET: typeof HGET;
    hGet: typeof HGET;
    HGETALL: typeof HGETALL;
    hGetAll: typeof HGETALL;
    HINCRBY: typeof HINCRBY;
    hIncrBy: typeof HINCRBY;
    HINCRBYFLOAT: typeof HINCRBYFLOAT;
    hIncrByFloat: typeof HINCRBYFLOAT;
    HKEYS: typeof HKEYS;
    hKeys: typeof HKEYS;
    HLEN: typeof HLEN;
    hLen: typeof HLEN;
    HMGET: typeof HMGET;
    hmGet: typeof HMGET;
    HPERSIST: typeof HPERSIST;
    hPersist: typeof HPERSIST;
    HPEXPIRE: typeof HPEXPIRE;
    hpExpire: typeof HPEXPIRE;
    HPEXPIREAT: typeof HPEXPIREAT;
    hpExpireAt: typeof HPEXPIREAT;
    HPEXPIRETIME: typeof HPEXPIRETIME;
    hpExpireTime: typeof HPEXPIRETIME;
    HPTTL: typeof HPTTL;
    hpTTL: typeof HPTTL;
    HRANDFIELD_COUNT_WITHVALUES: typeof HRANDFIELD_COUNT_WITHVALUES;
    hRandFieldCountWithValues: typeof HRANDFIELD_COUNT_WITHVALUES;
    HRANDFIELD_COUNT: typeof HRANDFIELD_COUNT;
    hRandFieldCount: typeof HRANDFIELD_COUNT;
    HRANDFIELD: typeof HRANDFIELD;
    hRandField: typeof HRANDFIELD;
    HSCAN: typeof HSCAN;
    hScan: typeof HSCAN;
    HSCAN_NOVALUES: typeof HSCAN_NOVALUES;
    hScanNoValues: typeof HSCAN_NOVALUES;
    HSET: typeof HSET;
    hSet: typeof HSET;
    HSETNX: typeof HSETNX;
    hSetNX: typeof HSETNX;
    HSTRLEN: typeof HSTRLEN;
    hStrLen: typeof HSTRLEN;
    HTTL: typeof HTTL;
    hTTL: typeof HTTL;
    HVALS: typeof HVALS;
    hVals: typeof HVALS;
    INCR: typeof INCR;
    incr: typeof INCR;
    INCRBY: typeof INCRBY;
    incrBy: typeof INCRBY;
    INCRBYFLOAT: typeof INCRBYFLOAT;
    incrByFloat: typeof INCRBYFLOAT;
    LCS_IDX_WITHMATCHLEN: typeof LCS_IDX_WITHMATCHLEN;
    lcsIdxWithMatchLen: typeof LCS_IDX_WITHMATCHLEN;
    LCS_IDX: typeof LCS_IDX;
    lcsIdx: typeof LCS_IDX;
    LCS_LEN: typeof LCS_LEN;
    lcsLen: typeof LCS_LEN;
    LCS: typeof LCS;
    lcs: typeof LCS;
    LINDEX: typeof LINDEX;
    lIndex: typeof LINDEX;
    LINSERT: typeof LINSERT;
    lInsert: typeof LINSERT;
    LLEN: typeof LLEN;
    lLen: typeof LLEN;
    LMOVE: typeof LMOVE;
    lMove: typeof LMOVE;
    LMPOP: typeof LMPOP;
    lmPop: typeof LMPOP;
    LPOP_COUNT: typeof LPOP_COUNT;
    lPopCount: typeof LPOP_COUNT;
    LPOP: typeof LPOP;
    lPop: typeof LPOP;
    LPOS_COUNT: typeof LPOS_COUNT;
    lPosCount: typeof LPOS_COUNT;
    LPOS: typeof LPOS;
    lPos: typeof LPOS;
    LPUSH: typeof LPUSH;
    lPush: typeof LPUSH;
    LPUSHX: typeof LPUSHX;
    lPushX: typeof LPUSHX;
    LRANGE: typeof LRANGE;
    lRange: typeof LRANGE;
    LREM: typeof LREM;
    lRem: typeof LREM;
    LSET: typeof LSET;
    lSet: typeof LSET;
    LTRIM: typeof LTRIM;
    lTrim: typeof LTRIM;
    MGET: typeof MGET;
    mGet: typeof MGET;
    MIGRATE: typeof MIGRATE;
    migrate: typeof MIGRATE;
    MSET: typeof MSET;
    mSet: typeof MSET;
    MSETNX: typeof MSETNX;
    mSetNX: typeof MSETNX;
    OBJECT_ENCODING: typeof OBJECT_ENCODING;
    objectEncoding: typeof OBJECT_ENCODING;
    OBJECT_FREQ: typeof OBJECT_FREQ;
    objectFreq: typeof OBJECT_FREQ;
    OBJECT_IDLETIME: typeof OBJECT_IDLETIME;
    objectIdleTime: typeof OBJECT_IDLETIME;
    OBJECT_REFCOUNT: typeof OBJECT_REFCOUNT;
    objectRefCount: typeof OBJECT_REFCOUNT;
    PERSIST: typeof PERSIST;
    persist: typeof PERSIST;
    PEXPIRE: typeof PEXPIRE;
    pExpire: typeof PEXPIRE;
    PEXPIREAT: typeof PEXPIREAT;
    pExpireAt: typeof PEXPIREAT;
    PEXPIRETIME: typeof PEXPIRETIME;
    pExpireTime: typeof PEXPIRETIME;
    PFADD: typeof PFADD;
    pfAdd: typeof PFADD;
    PFCOUNT: typeof PFCOUNT;
    pfCount: typeof PFCOUNT;
    PFMERGE: typeof PFMERGE;
    pfMerge: typeof PFMERGE;
    PSETEX: typeof PSETEX;
    pSetEx: typeof PSETEX;
    PTTL: typeof PTTL;
    pTTL: typeof PTTL;
    PUBLISH: typeof PUBLISH;
    publish: typeof PUBLISH;
    RENAME: typeof RENAME;
    rename: typeof RENAME;
    RENAMENX: typeof RENAMENX;
    renameNX: typeof RENAMENX;
    RESTORE: typeof RESTORE;
    restore: typeof RESTORE;
    RPOP_COUNT: typeof RPOP_COUNT;
    rPopCount: typeof RPOP_COUNT;
    RPOP: typeof RPOP;
    rPop: typeof RPOP;
    RPOPLPUSH: typeof RPOPLPUSH;
    rPopLPush: typeof RPOPLPUSH;
    RPUSH: typeof RPUSH;
    rPush: typeof RPUSH;
    RPUSHX: typeof RPUSHX;
    rPushX: typeof RPUSHX;
    SADD: typeof SADD;
    sAdd: typeof SADD;
    SCARD: typeof SCARD;
    sCard: typeof SCARD;
    SDIFF: typeof SDIFF;
    sDiff: typeof SDIFF;
    SDIFFSTORE: typeof SDIFFSTORE;
    sDiffStore: typeof SDIFFSTORE;
    SINTER: typeof SINTER;
    sInter: typeof SINTER;
    SINTERCARD: typeof SINTERCARD;
    sInterCard: typeof SINTERCARD;
    SINTERSTORE: typeof SINTERSTORE;
    sInterStore: typeof SINTERSTORE;
    SET: typeof SET;
    set: typeof SET;
    SETBIT: typeof SETBIT;
    setBit: typeof SETBIT;
    SETEX: typeof SETEX;
    setEx: typeof SETEX;
    SETNX: typeof SETNX;
    setNX: typeof SETNX;
    SETRANGE: typeof SETRANGE;
    setRange: typeof SETRANGE;
    SISMEMBER: typeof SISMEMBER;
    sIsMember: typeof SISMEMBER;
    SMEMBERS: typeof SMEMBERS;
    sMembers: typeof SMEMBERS;
    SMISMEMBER: typeof SMISMEMBER;
    smIsMember: typeof SMISMEMBER;
    SMOVE: typeof SMOVE;
    sMove: typeof SMOVE;
    SORT_RO: typeof SORT_RO;
    sortRo: typeof SORT_RO;
    SORT_STORE: typeof SORT_STORE;
    sortStore: typeof SORT_STORE;
    SORT: typeof SORT;
    sort: typeof SORT;
    SPOP: typeof SPOP;
    sPop: typeof SPOP;
    SPUBLISH: typeof SPUBLISH;
    sPublish: typeof SPUBLISH;
    SRANDMEMBER_COUNT: typeof SRANDMEMBER_COUNT;
    sRandMemberCount: typeof SRANDMEMBER_COUNT;
    SRANDMEMBER: typeof SRANDMEMBER;
    sRandMember: typeof SRANDMEMBER;
    SREM: typeof SREM;
    sRem: typeof SREM;
    SSCAN: typeof SSCAN;
    sScan: typeof SSCAN;
    STRLEN: typeof STRLEN;
    strLen: typeof STRLEN;
    SUNION: typeof SUNION;
    sUnion: typeof SUNION;
    SUNIONSTORE: typeof SUNIONSTORE;
    sUnionStore: typeof SUNIONSTORE;
    TOUCH: typeof TOUCH;
    touch: typeof TOUCH;
    TTL: typeof TTL;
    ttl: typeof TTL;
    TYPE: typeof TYPE;
    type: typeof TYPE;
    UNLINK: typeof UNLINK;
    unlink: typeof UNLINK;
    WATCH: typeof WATCH;
    watch: typeof WATCH;
    XACK: typeof XACK;
    xAck: typeof XACK;
    XADD: typeof XADD;
    xAdd: typeof XADD;
    XAUTOCLAIM_JUSTID: typeof XAUTOCLAIM_JUSTID;
    xAutoClaimJustId: typeof XAUTOCLAIM_JUSTID;
    XAUTOCLAIM: typeof XAUTOCLAIM;
    xAutoClaim: typeof XAUTOCLAIM;
    XCLAIM: typeof XCLAIM;
    xClaim: typeof XCLAIM;
    XCLAIM_JUSTID: typeof XCLAIM_JUSTID;
    xClaimJustId: typeof XCLAIM_JUSTID;
    XDEL: typeof XDEL;
    xDel: typeof XDEL;
    XGROUP_CREATE: typeof XGROUP_CREATE;
    xGroupCreate: typeof XGROUP_CREATE;
    XGROUP_CREATECONSUMER: typeof XGROUP_CREATECONSUMER;
    xGroupCreateConsumer: typeof XGROUP_CREATECONSUMER;
    XGROUP_DELCONSUMER: typeof XGROUP_DELCONSUMER;
    xGroupDelConsumer: typeof XGROUP_DELCONSUMER;
    XGROUP_DESTROY: typeof XGROUP_DESTROY;
    xGroupDestroy: typeof XGROUP_DESTROY;
    XGROUP_SETID: typeof XGROUP_SETID;
    xGroupSetId: typeof XGROUP_SETID;
    XINFO_CONSUMERS: typeof XINFO_CONSUMERS;
    xInfoConsumers: typeof XINFO_CONSUMERS;
    XINFO_GROUPS: typeof XINFO_GROUPS;
    xInfoGroups: typeof XINFO_GROUPS;
    XINFO_STREAM: typeof XINFO_STREAM;
    xInfoStream: typeof XINFO_STREAM;
    XLEN: typeof XLEN;
    xLen: typeof XLEN;
    XPENDING_RANGE: typeof XPENDING_RANGE;
    xPendingRange: typeof XPENDING_RANGE;
    XPENDING: typeof XPENDING;
    xPending: typeof XPENDING;
    XRANGE: typeof XRANGE;
    xRange: typeof XRANGE;
    XREAD: typeof XREAD;
    xRead: typeof XREAD;
    XREADGROUP: typeof XREADGROUP;
    xReadGroup: typeof XREADGROUP;
    XREVRANGE: typeof XREVRANGE;
    xRevRange: typeof XREVRANGE;
    XSETID: typeof XSETID;
    xSetId: typeof XSETID;
    XTRIM: typeof XTRIM;
    xTrim: typeof XTRIM;
    ZADD: typeof ZADD;
    zAdd: typeof ZADD;
    ZCARD: typeof ZCARD;
    zCard: typeof ZCARD;
    ZCOUNT: typeof ZCOUNT;
    zCount: typeof ZCOUNT;
    ZDIFF_WITHSCORES: typeof ZDIFF_WITHSCORES;
    zDiffWithScores: typeof ZDIFF_WITHSCORES;
    ZDIFF: typeof ZDIFF;
    zDiff: typeof ZDIFF;
    ZDIFFSTORE: typeof ZDIFFSTORE;
    zDiffStore: typeof ZDIFFSTORE;
    ZINCRBY: typeof ZINCRBY;
    zIncrBy: typeof ZINCRBY;
    ZINTER_WITHSCORES: typeof ZINTER_WITHSCORES;
    zInterWithScores: typeof ZINTER_WITHSCORES;
    ZINTER: typeof ZINTER;
    zInter: typeof ZINTER;
    ZINTERCARD: typeof ZINTERCARD;
    zInterCard: typeof ZINTERCARD;
    ZINTERSTORE: typeof ZINTERSTORE;
    zInterStore: typeof ZINTERSTORE;
    ZLEXCOUNT: typeof ZLEXCOUNT;
    zLexCount: typeof ZLEXCOUNT;
    ZMPOP: typeof ZMPOP;
    zmPop: typeof ZMPOP;
    ZMSCORE: typeof ZMSCORE;
    zmScore: typeof ZMSCORE;
    ZPOPMAX_COUNT: typeof ZPOPMAX_COUNT;
    zPopMaxCount: typeof ZPOPMAX_COUNT;
    ZPOPMAX: typeof ZPOPMAX;
    zPopMax: typeof ZPOPMAX;
    ZPOPMIN_COUNT: typeof ZPOPMIN_COUNT;
    zPopMinCount: typeof ZPOPMIN_COUNT;
    ZPOPMIN: typeof ZPOPMIN;
    zPopMin: typeof ZPOPMIN;
    ZRANDMEMBER_COUNT_WITHSCORES: typeof ZRANDMEMBER_COUNT_WITHSCORES;
    zRandMemberCountWithScores: typeof ZRANDMEMBER_COUNT_WITHSCORES;
    ZRANDMEMBER_COUNT: typeof ZRANDMEMBER_COUNT;
    zRandMemberCount: typeof ZRANDMEMBER_COUNT;
    ZRANDMEMBER: typeof ZRANDMEMBER;
    zRandMember: typeof ZRANDMEMBER;
    ZRANGE_WITHSCORES: typeof ZRANGE_WITHSCORES;
    zRangeWithScores: typeof ZRANGE_WITHSCORES;
    ZRANGE: typeof ZRANGE;
    zRange: typeof ZRANGE;
    ZRANGEBYLEX: typeof ZRANGEBYLEX;
    zRangeByLex: typeof ZRANGEBYLEX;
    ZRANGEBYSCORE_WITHSCORES: typeof ZRANGEBYSCORE_WITHSCORES;
    zRangeByScoreWithScores: typeof ZRANGEBYSCORE_WITHSCORES;
    ZRANGEBYSCORE: typeof ZRANGEBYSCORE;
    zRangeByScore: typeof ZRANGEBYSCORE;
    ZRANGESTORE: typeof ZRANGESTORE;
    zRangeStore: typeof ZRANGESTORE;
    ZRANK: typeof ZRANK;
    zRank: typeof ZRANK;
    ZREM: typeof ZREM;
    zRem: typeof ZREM;
    ZREMRANGEBYLEX: typeof ZREMRANGEBYLEX;
    zRemRangeByLex: typeof ZREMRANGEBYLEX;
    ZREMRANGEBYRANK: typeof ZREMRANGEBYRANK;
    zRemRangeByRank: typeof ZREMRANGEBYRANK;
    ZREMRANGEBYSCORE: typeof ZREMRANGEBYSCORE;
    zRemRangeByScore: typeof ZREMRANGEBYSCORE;
    ZREVRANK: typeof ZREVRANK;
    zRevRank: typeof ZREVRANK;
    ZSCAN: typeof ZSCAN;
    zScan: typeof ZSCAN;
    ZSCORE: typeof ZSCORE;
    zScore: typeof ZSCORE;
    ZUNION_WITHSCORES: typeof ZUNION_WITHSCORES;
    zUnionWithScores: typeof ZUNION_WITHSCORES;
    ZUNION: typeof ZUNION;
    zUnion: typeof ZUNION;
    ZUNIONSTORE: typeof ZUNIONSTORE;
    zUnionStore: typeof ZUNIONSTORE;
};

type RedisClusterMultiCommandSignature<C extends RedisCommand$1, M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = (...args: Parameters<C['transformArguments']>) => RedisClusterMultiCommandType<M, F, S>;
type WithCommands$2<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof typeof _default]: RedisClusterMultiCommandSignature<(typeof _default)[P], M, F, S>;
};
type WithModules$1<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof M as ExcludeMappedString<P>]: {
        [C in keyof M[P] as ExcludeMappedString<C>]: RedisClusterMultiCommandSignature<M[P][C], M, F, S>;
    };
};
type WithFunctions$1<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof F as ExcludeMappedString<P>]: {
        [FF in keyof F[P] as ExcludeMappedString<FF>]: RedisClusterMultiCommandSignature<F[P][FF], M, F, S>;
    };
};
type WithScripts$1<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = {
    [P in keyof S as ExcludeMappedString<P>]: RedisClusterMultiCommandSignature<S[P], M, F, S>;
};
type RedisClusterMultiCommandType<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = RedisClusterMultiCommand & WithCommands$2<M, F, S> & WithModules$1<M, F, S> & WithFunctions$1<M, F, S> & WithScripts$1<M, F, S>;
type InstantiableRedisClusterMultiCommandType<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = new (...args: ConstructorParameters<typeof RedisClusterMultiCommand>) => RedisClusterMultiCommandType<M, F, S>;
type RedisClusterMultiExecutor = (queue: Array<RedisMultiQueuedCommand>, firstKey?: RedisCommandArgument$5, chainId?: symbol) => Promise<Array<RedisCommandRawReply>>;
declare class RedisClusterMultiCommand {
    #private;
    static extend<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(extensions?: RedisExtensions<M, F, S>): InstantiableRedisClusterMultiCommandType<M, F, S>;
    constructor(executor: RedisClusterMultiExecutor, firstKey?: RedisCommandArgument$5);
    commandsExecutor(command: RedisCommand$1, args: Array<unknown>): this;
    addCommand(firstKey: RedisCommandArgument$5 | undefined, args: RedisCommandArguments$5, transformReply?: RedisCommand$1['transformReply']): this;
    functionsExecutor(fn: RedisFunction$1, args: Array<unknown>, name: string): this;
    scriptsExecutor(script: RedisScript$1, args: Array<unknown>): this;
    exec(execAsPipeline?: boolean): Promise<Array<RedisCommandRawReply>>;
    EXEC: (execAsPipeline?: boolean) => Promise<Array<RedisCommandRawReply>>;
    execAsPipeline(): Promise<Array<RedisCommandRawReply>>;
}

type RedisClusterClientOptions = Omit<RedisClientOptions$1, 'modules' | 'functions' | 'scripts' | 'database'>;
interface RedisClusterOptions<M extends RedisModules = Record<string, never>, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> extends RedisExtensions<M, F, S> {
    /**
     * Should contain details for some of the cluster nodes that the client will use to discover
     * the "cluster topology". We recommend including details for at least 3 nodes here.
     */
    rootNodes: Array<RedisClusterClientOptions>;
    /**
     * Default values used for every client in the cluster. Use this to specify global values,
     * for example: ACL credentials, timeouts, TLS configuration etc.
     */
    defaults?: Partial<RedisClusterClientOptions>;
    /**
     * When `true`, `.connect()` will only discover the cluster topology, without actually connecting to all the nodes.
     * Useful for short-term or PubSub-only connections.
     */
    minimizeConnections?: boolean;
    /**
     * When `true`, distribute load by executing readonly commands (such as `GET`, `GEOSEARCH`, etc.) across all cluster nodes. When `false`, only use master nodes.
     */
    useReplicas?: boolean;
    /**
     * The maximum number of times a command will be redirected due to `MOVED` or `ASK` errors.
     */
    maxCommandRedirections?: number;
    /**
     * Mapping between the addresses in the cluster (see `CLUSTER SHARDS`) and the addresses the client should connect to
     * Useful when the cluster is running on another network
     *
     */
    nodeAddressMap?: NodeAddressMap;
}
type WithCommands$1 = {
    [P in keyof typeof _default]: RedisCommandSignature<(typeof _default)[P]>;
};
type RedisClusterType$1<M extends RedisModules = Record<string, never>, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisCluster<M, F, S> & WithCommands$1 & WithModules$2<M> & WithFunctions$2<F> & WithScripts$2<S>;
declare class RedisCluster<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> extends EventEmitter {
    #private;
    static extractFirstKey(command: RedisCommand$1, originalArgs: Array<unknown>, redisArgs: RedisCommandArguments$5): RedisCommandArgument$5 | undefined;
    static create<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(options?: RedisClusterOptions<M, F, S>): RedisClusterType$1<M, F, S>;
    get slots(): Shard<M, F, S>[];
    get shards(): Shard<M, F, S>[];
    get masters(): ShardNode<M, F, S>[];
    get replicas(): ShardNode<M, F, S>[];
    get nodeByAddress(): Map<string, ShardNode<M, F, S> | MasterNode<M, F, S>>;
    get pubSubNode(): Required<Node<M, F, S>> | undefined;
    get isOpen(): boolean;
    constructor(options: RedisClusterOptions<M, F, S>);
    duplicate(overrides?: Partial<RedisClusterOptions<M, F, S>>): RedisClusterType$1<M, F, S>;
    connect(): Promise<void>;
    commandsExecutor<C extends RedisCommand$1>(command: C, args: Array<unknown>): Promise<RedisCommandReply<C>>;
    sendCommand<T = RedisCommandRawReply>(firstKey: RedisCommandArgument$5 | undefined, isReadonly: boolean | undefined, args: RedisCommandArguments$5, options?: ClientCommandOptions$1): Promise<T>;
    functionsExecutor<F extends RedisFunction$1>(fn: F, args: Array<unknown>, name: string): Promise<RedisCommandReply<F>>;
    executeFunction(name: string, fn: RedisFunction$1, originalArgs: Array<unknown>, redisArgs: RedisCommandArguments$5, options?: ClientCommandOptions$1): Promise<RedisCommandRawReply>;
    scriptsExecutor<S extends RedisScript$1>(script: S, args: Array<unknown>): Promise<RedisCommandReply<S>>;
    executeScript(script: RedisScript$1, originalArgs: Array<unknown>, redisArgs: RedisCommandArguments$5, options?: ClientCommandOptions$1): Promise<RedisCommandRawReply>;
    MULTI(routing?: RedisCommandArgument$5): RedisClusterMultiCommandType<M, F, S>;
    multi: (routing?: RedisCommandArgument$5) => RedisClusterMultiCommandType<M, F, S>;
    SUBSCRIBE<T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    subscribe: <T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    UNSUBSCRIBE<T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<boolean>, bufferMode?: T): Promise<void>;
    unsubscribe: <T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<boolean>, bufferMode?: T | undefined) => Promise<void>;
    PSUBSCRIBE<T extends boolean = false>(patterns: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    pSubscribe: <T extends boolean = false>(patterns: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    PUNSUBSCRIBE<T extends boolean = false>(patterns?: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    pUnsubscribe: <T extends boolean = false>(patterns?: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    SSUBSCRIBE<T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    sSubscribe: <T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    SUNSUBSCRIBE<T extends boolean = false>(channels: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    sUnsubscribe: <T extends boolean = false>(channels: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    quit(): Promise<void>;
    disconnect(): Promise<void>;
    nodeClient(node: ShardNode<M, F, S>): RedisClientType$2<M, F, S> | Promise<RedisClientType$2<M, F, S>>;
    getRandomNode(): ShardNode<M, F, S>;
    getSlotRandomNode(slot: number): ShardNode<M, F, S>;
    /**
     * @deprecated use `.masters` instead
     */
    getMasters(): ShardNode<M, F, S>[];
    /**
     * @deprecated use `.slots[<SLOT>]` instead
     */
    getSlotMaster(slot: number): MasterNode<M, F, S>;
}

declare const commandOptions$1: typeof RedisClient$1.commandOptions;

interface RedisClientOptions<M extends RedisModules = RedisModules, F extends RedisFunctions$1 = RedisFunctions$1, S extends RedisScripts$1 = RedisScripts$1> extends RedisExtensions<M, F, S> {
    /**
     * `redis[s]://[[username][:password]@][host][:port][/db-number]`
     * See [`redis`](https://www.iana.org/assignments/uri-schemes/prov/redis) and [`rediss`](https://www.iana.org/assignments/uri-schemes/prov/rediss) IANA registration for more details
     */
    url?: string;
    /**
     * Socket connection properties
     */
    socket?: RedisSocketOptions;
    /**
     * ACL username ([see ACL guide](https://redis.io/topics/acl))
     */
    username?: string;
    /**
     * ACL password or the old "--requirepass" password
     */
    password?: string;
    /**
     * Client name ([see `CLIENT SETNAME`](https://redis.io/commands/client-setname))
     */
    name?: string;
    /**
     * Redis database number (see [`SELECT`](https://redis.io/commands/select) command)
     */
    database?: number;
    /**
     * Maximum length of the client's internal command queue
     */
    commandsQueueMaxLength?: number;
    /**
     * When `true`, commands are rejected when the client is reconnecting.
     * When `false`, commands are queued for execution after reconnection.
     */
    disableOfflineQueue?: boolean;
    /**
     * Connect in [`READONLY`](https://redis.io/commands/readonly) mode
     */
    readonly?: boolean;
    legacyMode?: boolean;
    isolationPoolOptions?: Options;
    /**
     * Send `PING` command at interval (in ms).
     * Useful with Redis deployments that do not use TCP Keep-Alive.
     */
    pingInterval?: number;
    /**
     * If set to true, disables sending client identifier (user-agent like message) to the redis server
     */
    disableClientInfo?: boolean;
    /**
     * Tag to append to library name that is sent to the Redis server
     */
    clientInfoTag?: string;
}
type WithCommands = {
    [P in keyof typeof _default$1]: RedisCommandSignature<(typeof _default$1)[P]>;
};
type WithModules<M extends RedisModules> = {
    [P in keyof M as ExcludeMappedString<P>]: {
        [C in keyof M[P] as ExcludeMappedString<C>]: RedisCommandSignature<M[P][C]>;
    };
};
type WithFunctions<F extends RedisFunctions$1> = {
    [P in keyof F as ExcludeMappedString<P>]: {
        [FF in keyof F[P] as ExcludeMappedString<FF>]: RedisCommandSignature<F[P][FF]>;
    };
};
type WithScripts<S extends RedisScripts$1> = {
    [P in keyof S as ExcludeMappedString<P>]: RedisCommandSignature<S[P]>;
};
type RedisClientType$1<M extends RedisModules = Record<string, never>, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisClient<M, F, S> & WithCommands & WithModules<M> & WithFunctions<F> & WithScripts<S>;
type InstantiableRedisClient<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> = new (options?: RedisClientOptions<M, F, S>) => RedisClientType$1<M, F, S>;
interface ClientCommandOptions extends QueueCommandOptions {
    isolated?: boolean;
}
declare class RedisClient<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1> extends EventEmitter {
    #private;
    static commandOptions<T extends ClientCommandOptions>(options: T): CommandOptions<T>;
    commandOptions: typeof RedisClient.commandOptions;
    static extend<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(extensions?: RedisExtensions<M, F, S>): InstantiableRedisClient<M, F, S>;
    static create<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(options?: RedisClientOptions<M, F, S>): RedisClientType$1<M, F, S>;
    static parseURL(url: string): RedisClientOptions;
    get options(): RedisClientOptions<M, F, S> | undefined;
    get isOpen(): boolean;
    get isReady(): boolean;
    get isPubSubActive(): boolean;
    get v4(): Record<string, any>;
    constructor(options?: RedisClientOptions<M, F, S>);
    duplicate(overrides?: Partial<RedisClientOptions<M, F, S>>): RedisClientType$1<M, F, S>;
    connect(): Promise<RedisClientType$1<M, F, S>>;
    commandsExecutor<C extends RedisCommand$1>(command: C, args: Array<unknown>): Promise<RedisCommandReply<C>>;
    sendCommand<T = RedisCommandRawReply>(args: RedisCommandArguments$5, options?: ClientCommandOptions): Promise<T>;
    functionsExecuter<F extends RedisFunction$1>(fn: F, args: Array<unknown>, name: string): Promise<RedisCommandReply<F>>;
    executeFunction(name: string, fn: RedisFunction$1, args: RedisCommandArguments$5, options?: ClientCommandOptions): Promise<RedisCommandRawReply>;
    scriptsExecuter<S extends RedisScript$1>(script: S, args: Array<unknown>): Promise<RedisCommandReply<S>>;
    executeScript(script: RedisScript$1, args: RedisCommandArguments$5, options?: ClientCommandOptions): Promise<RedisCommandRawReply>;
    SELECT(db: number): Promise<void>;
    SELECT(options: CommandOptions<ClientCommandOptions>, db: number): Promise<void>;
    select: {
        (db: number): Promise<void>;
        (options: CommandOptions<ClientCommandOptions>, db: number): Promise<void>;
    };
    SUBSCRIBE<T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    subscribe: <T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    UNSUBSCRIBE<T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    unsubscribe: <T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    PSUBSCRIBE<T extends boolean = false>(patterns: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    pSubscribe: <T extends boolean = false>(patterns: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    PUNSUBSCRIBE<T extends boolean = false>(patterns?: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    pUnsubscribe: <T extends boolean = false>(patterns?: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    SSUBSCRIBE<T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T): Promise<void>;
    sSubscribe: <T extends boolean = false>(channels: string | Array<string>, listener: PubSubListener<T>, bufferMode?: T | undefined) => Promise<void>;
    SUNSUBSCRIBE<T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T>, bufferMode?: T): Promise<void>;
    sUnsubscribe: <T extends boolean = false>(channels?: string | Array<string>, listener?: PubSubListener<T> | undefined, bufferMode?: T | undefined) => Promise<void>;
    getPubSubListeners(type: PubSubType): PubSubTypeListeners;
    extendPubSubChannelListeners(type: PubSubType, channel: string, listeners: ChannelListeners): Promise<void>;
    extendPubSubListeners(type: PubSubType, listeners: PubSubTypeListeners): Promise<void>;
    QUIT(): Promise<string>;
    quit: () => Promise<string>;
    executeIsolated<T>(fn: (client: RedisClientType$1<M, F, S>) => T | Promise<T>): Promise<T>;
    MULTI(): RedisClientMultiCommandType<M, F, S>;
    multi: () => RedisClientMultiCommandType<M, F, S>;
    multiExecutor(commands: Array<RedisMultiQueuedCommand>, selectedDB?: number, chainId?: symbol): Promise<Array<RedisCommandRawReply>>;
    scanIterator(options?: ScanCommandOptions): AsyncIterable<string>;
    hScanIterator(key: string, options?: ScanOptions): AsyncIterable<ConvertArgumentType<HScanTuple, string>>;
    hScanNoValuesIterator(key: string, options?: ScanOptions): AsyncIterable<ConvertArgumentType<RedisCommandArgument$5, string>>;
    sScanIterator(key: string, options?: ScanOptions): AsyncIterable<string>;
    zScanIterator(key: string, options?: ScanOptions): AsyncIterable<ConvertArgumentType<ZMember, string>>;
    disconnect(): Promise<void>;
    ref(): void;
    unref(): void;
}

type GraphReply<T> = Omit<QueryReply$1, 'headers' | 'data'> & {
    data?: Array<T>;
};
type GraphClientType = RedisClientType$1<{
    graph: {
        query: typeof __commands_QUERY;
        roQuery: typeof __commands_RO_QUERY;
    };
}, RedisFunctions, RedisScripts>;
declare class Graph$1 {
    #private;
    constructor(client: GraphClientType, name: string);
    query<T>(query: RedisCommandArgument, options?: QueryOptions): Promise<GraphReply<T>>;
    roQuery<T>(query: RedisCommandArgument, options?: QueryOptions): Promise<GraphReply<T>>;
}

declare const modules: {
    graph: {
        CONFIG_GET: typeof _redis_graph_dist_commands_CONFIG_GET;
        configGet: typeof _redis_graph_dist_commands_CONFIG_GET;
        CONFIG_SET: typeof _redis_graph_dist_commands_CONFIG_SET;
        configSet: typeof _redis_graph_dist_commands_CONFIG_SET;
        DELETE: typeof _redis_graph_dist_commands_DELETE;
        delete: typeof _redis_graph_dist_commands_DELETE;
        EXPLAIN: typeof _redis_graph_dist_commands_EXPLAIN;
        explain: typeof _redis_graph_dist_commands_EXPLAIN;
        LIST: typeof _redis_graph_dist_commands_LIST;
        list: typeof _redis_graph_dist_commands_LIST;
        PROFILE: typeof _redis_graph_dist_commands_PROFILE;
        profile: typeof _redis_graph_dist_commands_PROFILE;
        QUERY: typeof _redis_graph_dist_commands_QUERY;
        query: typeof _redis_graph_dist_commands_QUERY;
        RO_QUERY: typeof _redis_graph_dist_commands_RO_QUERY;
        roQuery: typeof _redis_graph_dist_commands_RO_QUERY;
        SLOWLOG: typeof _redis_graph_dist_commands_SLOWLOG;
        slowLog: typeof _redis_graph_dist_commands_SLOWLOG;
    };
    json: {
        ARRAPPEND: typeof _redis_json_dist_commands_ARRAPPEND;
        arrAppend: typeof _redis_json_dist_commands_ARRAPPEND;
        ARRINDEX: typeof _redis_json_dist_commands_ARRINDEX;
        arrIndex: typeof _redis_json_dist_commands_ARRINDEX;
        ARRINSERT: typeof _redis_json_dist_commands_ARRINSERT;
        arrInsert: typeof _redis_json_dist_commands_ARRINSERT;
        ARRLEN: typeof _redis_json_dist_commands_ARRLEN;
        arrLen: typeof _redis_json_dist_commands_ARRLEN;
        ARRPOP: typeof _redis_json_dist_commands_ARRPOP;
        arrPop: typeof _redis_json_dist_commands_ARRPOP;
        ARRTRIM: typeof _redis_json_dist_commands_ARRTRIM;
        arrTrim: typeof _redis_json_dist_commands_ARRTRIM;
        DEBUG_MEMORY: typeof _redis_json_dist_commands_DEBUG_MEMORY;
        debugMemory: typeof _redis_json_dist_commands_DEBUG_MEMORY;
        DEL: typeof _redis_json_dist_commands_DEL;
        del: typeof _redis_json_dist_commands_DEL;
        FORGET: typeof _redis_json_dist_commands_FORGET;
        forget: typeof _redis_json_dist_commands_FORGET;
        GET: typeof _redis_json_dist_commands_GET;
        get: typeof _redis_json_dist_commands_GET;
        MERGE: typeof _redis_json_dist_commands_MERGE;
        merge: typeof _redis_json_dist_commands_MERGE;
        MGET: typeof _redis_json_dist_commands_MGET;
        mGet: typeof _redis_json_dist_commands_MGET;
        MSET: typeof _redis_json_dist_commands_MSET;
        mSet: typeof _redis_json_dist_commands_MSET;
        NUMINCRBY: typeof _redis_json_dist_commands_NUMINCRBY;
        numIncrBy: typeof _redis_json_dist_commands_NUMINCRBY;
        NUMMULTBY: typeof _redis_json_dist_commands_NUMMULTBY;
        numMultBy: typeof _redis_json_dist_commands_NUMMULTBY;
        OBJKEYS: typeof _redis_json_dist_commands_OBJKEYS;
        objKeys: typeof _redis_json_dist_commands_OBJKEYS;
        OBJLEN: typeof _redis_json_dist_commands_OBJLEN;
        objLen: typeof _redis_json_dist_commands_OBJLEN;
        RESP: typeof _redis_json_dist_commands_RESP;
        resp: typeof _redis_json_dist_commands_RESP;
        SET: typeof _redis_json_dist_commands_SET;
        set: typeof _redis_json_dist_commands_SET;
        STRAPPEND: typeof _redis_json_dist_commands_STRAPPEND;
        strAppend: typeof _redis_json_dist_commands_STRAPPEND;
        STRLEN: typeof _redis_json_dist_commands_STRLEN;
        strLen: typeof _redis_json_dist_commands_STRLEN;
        TYPE: typeof _redis_json_dist_commands_TYPE;
        type: typeof _redis_json_dist_commands_TYPE;
    };
    ft: {
        _LIST: typeof _redis_search_dist_commands__LIST;
        _list: typeof _redis_search_dist_commands__LIST;
        ALTER: typeof _redis_search_dist_commands_ALTER;
        alter: typeof _redis_search_dist_commands_ALTER;
        AGGREGATE_WITHCURSOR: typeof _redis_search_dist_commands_AGGREGATE_WITHCURSOR;
        aggregateWithCursor: typeof _redis_search_dist_commands_AGGREGATE_WITHCURSOR;
        AGGREGATE: typeof _redis_search_dist_commands_AGGREGATE;
        aggregate: typeof _redis_search_dist_commands_AGGREGATE;
        ALIASADD: typeof _redis_search_dist_commands_ALIASADD;
        aliasAdd: typeof _redis_search_dist_commands_ALIASADD;
        ALIASDEL: typeof _redis_search_dist_commands_ALIASDEL;
        aliasDel: typeof _redis_search_dist_commands_ALIASDEL;
        ALIASUPDATE: typeof _redis_search_dist_commands_ALIASUPDATE;
        aliasUpdate: typeof _redis_search_dist_commands_ALIASUPDATE;
        CONFIG_GET: typeof _redis_search_dist_commands_CONFIG_GET;
        configGet: typeof _redis_search_dist_commands_CONFIG_GET;
        CONFIG_SET: typeof _redis_search_dist_commands_CONFIG_SET;
        configSet: typeof _redis_search_dist_commands_CONFIG_SET;
        CREATE: typeof _redis_search_dist_commands_CREATE;
        create: typeof _redis_search_dist_commands_CREATE;
        CURSOR_DEL: typeof _redis_search_dist_commands_CURSOR_DEL;
        cursorDel: typeof _redis_search_dist_commands_CURSOR_DEL;
        CURSOR_READ: typeof _redis_search_dist_commands_CURSOR_READ;
        cursorRead: typeof _redis_search_dist_commands_CURSOR_READ;
        DICTADD: typeof _redis_search_dist_commands_DICTADD;
        dictAdd: typeof _redis_search_dist_commands_DICTADD;
        DICTDEL: typeof _redis_search_dist_commands_DICTDEL;
        dictDel: typeof _redis_search_dist_commands_DICTDEL;
        DICTDUMP: typeof _redis_search_dist_commands_DICTDUMP;
        dictDump: typeof _redis_search_dist_commands_DICTDUMP;
        DROPINDEX: typeof _redis_search_dist_commands_DROPINDEX;
        dropIndex: typeof _redis_search_dist_commands_DROPINDEX;
        EXPLAIN: typeof _redis_search_dist_commands_EXPLAIN;
        explain: typeof _redis_search_dist_commands_EXPLAIN;
        EXPLAINCLI: typeof _redis_search_dist_commands_EXPLAINCLI;
        explainCli: typeof _redis_search_dist_commands_EXPLAINCLI;
        INFO: typeof _redis_search_dist_commands_INFO;
        info: typeof _redis_search_dist_commands_INFO;
        PROFILESEARCH: typeof _redis_search_dist_commands_PROFILE_SEARCH;
        profileSearch: typeof _redis_search_dist_commands_PROFILE_SEARCH;
        PROFILEAGGREGATE: typeof _redis_search_dist_commands_PROFILE_AGGREGATE;
        profileAggregate: typeof _redis_search_dist_commands_PROFILE_AGGREGATE;
        SEARCH: typeof _redis_search_dist_commands_SEARCH;
        search: typeof _redis_search_dist_commands_SEARCH;
        SEARCH_NOCONTENT: typeof _redis_search_dist_commands_SEARCH_NOCONTENT;
        searchNoContent: typeof _redis_search_dist_commands_SEARCH_NOCONTENT;
        SPELLCHECK: typeof _redis_search_dist_commands_SPELLCHECK;
        spellCheck: typeof _redis_search_dist_commands_SPELLCHECK;
        SUGADD: typeof _redis_search_dist_commands_SUGADD;
        sugAdd: typeof _redis_search_dist_commands_SUGADD;
        SUGDEL: typeof _redis_search_dist_commands_SUGDEL;
        sugDel: typeof _redis_search_dist_commands_SUGDEL;
        SUGGET_WITHPAYLOADS: typeof _redis_search_dist_commands_SUGGET_WITHPAYLOADS;
        sugGetWithPayloads: typeof _redis_search_dist_commands_SUGGET_WITHPAYLOADS;
        SUGGET_WITHSCORES_WITHPAYLOADS: typeof _redis_search_dist_commands_SUGGET_WITHSCORES_WITHPAYLOADS;
        sugGetWithScoresWithPayloads: typeof _redis_search_dist_commands_SUGGET_WITHSCORES_WITHPAYLOADS;
        SUGGET_WITHSCORES: typeof _redis_search_dist_commands_SUGGET_WITHSCORES;
        sugGetWithScores: typeof _redis_search_dist_commands_SUGGET_WITHSCORES;
        SUGGET: typeof _redis_search_dist_commands_SUGGET;
        sugGet: typeof _redis_search_dist_commands_SUGGET;
        SUGLEN: typeof _redis_search_dist_commands_SUGLEN;
        sugLen: typeof _redis_search_dist_commands_SUGLEN;
        SYNDUMP: typeof _redis_search_dist_commands_SYNDUMP;
        synDump: typeof _redis_search_dist_commands_SYNDUMP;
        SYNUPDATE: typeof _redis_search_dist_commands_SYNUPDATE;
        synUpdate: typeof _redis_search_dist_commands_SYNUPDATE;
        TAGVALS: typeof _redis_search_dist_commands_TAGVALS;
        tagVals: typeof _redis_search_dist_commands_TAGVALS;
    };
    ts: {
        ADD: typeof _redis_time_series_dist_commands_ADD;
        add: typeof _redis_time_series_dist_commands_ADD;
        ALTER: typeof _redis_time_series_dist_commands_ALTER;
        alter: typeof _redis_time_series_dist_commands_ALTER;
        CREATE: typeof _redis_time_series_dist_commands_CREATE;
        create: typeof _redis_time_series_dist_commands_CREATE;
        CREATERULE: typeof _redis_time_series_dist_commands_CREATERULE;
        createRule: typeof _redis_time_series_dist_commands_CREATERULE;
        DECRBY: typeof _redis_time_series_dist_commands_DECRBY;
        decrBy: typeof _redis_time_series_dist_commands_DECRBY;
        DEL: typeof _redis_time_series_dist_commands_DEL;
        del: typeof _redis_time_series_dist_commands_DEL;
        DELETERULE: typeof _redis_time_series_dist_commands_DELETERULE;
        deleteRule: typeof _redis_time_series_dist_commands_DELETERULE;
        GET: typeof _redis_time_series_dist_commands_GET;
        get: typeof _redis_time_series_dist_commands_GET;
        INCRBY: typeof _redis_time_series_dist_commands_INCRBY;
        incrBy: typeof _redis_time_series_dist_commands_INCRBY;
        INFO_DEBUG: typeof _redis_time_series_dist_commands_INFO_DEBUG;
        infoDebug: typeof _redis_time_series_dist_commands_INFO_DEBUG;
        INFO: typeof _redis_time_series_dist_commands_INFO;
        info: typeof _redis_time_series_dist_commands_INFO;
        MADD: typeof _redis_time_series_dist_commands_MADD;
        mAdd: typeof _redis_time_series_dist_commands_MADD;
        MGET: typeof _redis_time_series_dist_commands_MGET;
        mGet: typeof _redis_time_series_dist_commands_MGET;
        MGET_WITHLABELS: typeof _redis_time_series_dist_commands_MGET_WITHLABELS;
        mGetWithLabels: typeof _redis_time_series_dist_commands_MGET_WITHLABELS;
        QUERYINDEX: typeof _redis_time_series_dist_commands_QUERYINDEX;
        queryIndex: typeof _redis_time_series_dist_commands_QUERYINDEX;
        RANGE: typeof _redis_time_series_dist_commands_RANGE;
        range: typeof _redis_time_series_dist_commands_RANGE;
        REVRANGE: typeof _redis_time_series_dist_commands_REVRANGE;
        revRange: typeof _redis_time_series_dist_commands_REVRANGE;
        MRANGE: typeof _redis_time_series_dist_commands_MRANGE;
        mRange: typeof _redis_time_series_dist_commands_MRANGE;
        MRANGE_WITHLABELS: typeof _redis_time_series_dist_commands_MRANGE_WITHLABELS;
        mRangeWithLabels: typeof _redis_time_series_dist_commands_MRANGE_WITHLABELS;
        MREVRANGE: typeof _redis_time_series_dist_commands_MREVRANGE;
        mRevRange: typeof _redis_time_series_dist_commands_MREVRANGE;
        MREVRANGE_WITHLABELS: typeof _redis_time_series_dist_commands_MREVRANGE_WITHLABELS;
        mRevRangeWithLabels: typeof _redis_time_series_dist_commands_MREVRANGE_WITHLABELS;
    };
    bf: {
        ADD: typeof _redis_bloom_dist_commands_bloom_ADD;
        add: typeof _redis_bloom_dist_commands_bloom_ADD;
        CARD: typeof _redis_bloom_dist_commands_bloom_CARD;
        card: typeof _redis_bloom_dist_commands_bloom_CARD;
        EXISTS: typeof _redis_bloom_dist_commands_bloom_EXISTS;
        exists: typeof _redis_bloom_dist_commands_bloom_EXISTS;
        INFO: typeof _redis_bloom_dist_commands_bloom_INFO;
        info: typeof _redis_bloom_dist_commands_bloom_INFO;
        INSERT: typeof _redis_bloom_dist_commands_bloom_INSERT;
        insert: typeof _redis_bloom_dist_commands_bloom_INSERT;
        LOADCHUNK: typeof _redis_bloom_dist_commands_bloom_LOADCHUNK;
        loadChunk: typeof _redis_bloom_dist_commands_bloom_LOADCHUNK;
        MADD: typeof _redis_bloom_dist_commands_bloom_MADD;
        mAdd: typeof _redis_bloom_dist_commands_bloom_MADD;
        MEXISTS: typeof _redis_bloom_dist_commands_bloom_MEXISTS;
        mExists: typeof _redis_bloom_dist_commands_bloom_MEXISTS;
        RESERVE: typeof _redis_bloom_dist_commands_bloom_RESERVE;
        reserve: typeof _redis_bloom_dist_commands_bloom_RESERVE;
        SCANDUMP: typeof _redis_bloom_dist_commands_bloom_SCANDUMP;
        scanDump: typeof _redis_bloom_dist_commands_bloom_SCANDUMP;
    };
    cms: {
        INCRBY: typeof _redis_bloom_dist_commands_count_min_sketch_INCRBY;
        incrBy: typeof _redis_bloom_dist_commands_count_min_sketch_INCRBY;
        INFO: typeof _redis_bloom_dist_commands_count_min_sketch_INFO;
        info: typeof _redis_bloom_dist_commands_count_min_sketch_INFO;
        INITBYDIM: typeof _redis_bloom_dist_commands_count_min_sketch_INITBYDIM;
        initByDim: typeof _redis_bloom_dist_commands_count_min_sketch_INITBYDIM;
        INITBYPROB: typeof _redis_bloom_dist_commands_count_min_sketch_INITBYPROB;
        initByProb: typeof _redis_bloom_dist_commands_count_min_sketch_INITBYPROB;
        MERGE: typeof _redis_bloom_dist_commands_count_min_sketch_MERGE;
        merge: typeof _redis_bloom_dist_commands_count_min_sketch_MERGE;
        QUERY: typeof _redis_bloom_dist_commands_count_min_sketch_QUERY;
        query: typeof _redis_bloom_dist_commands_count_min_sketch_QUERY;
    };
    cf: {
        ADD: typeof _redis_bloom_dist_commands_cuckoo_ADD;
        add: typeof _redis_bloom_dist_commands_cuckoo_ADD;
        ADDNX: typeof _redis_bloom_dist_commands_cuckoo_ADDNX;
        addNX: typeof _redis_bloom_dist_commands_cuckoo_ADDNX;
        COUNT: typeof _redis_bloom_dist_commands_cuckoo_COUNT;
        count: typeof _redis_bloom_dist_commands_cuckoo_COUNT;
        DEL: typeof _redis_bloom_dist_commands_cuckoo_DEL;
        del: typeof _redis_bloom_dist_commands_cuckoo_DEL;
        EXISTS: typeof _redis_bloom_dist_commands_cuckoo_EXISTS;
        exists: typeof _redis_bloom_dist_commands_cuckoo_EXISTS;
        INFO: typeof _redis_bloom_dist_commands_cuckoo_INFO;
        info: typeof _redis_bloom_dist_commands_cuckoo_INFO;
        INSERT: typeof _redis_bloom_dist_commands_cuckoo_INSERT;
        insert: typeof _redis_bloom_dist_commands_cuckoo_INSERT;
        INSERTNX: typeof _redis_bloom_dist_commands_cuckoo_INSERTNX;
        insertNX: typeof _redis_bloom_dist_commands_cuckoo_INSERTNX;
        LOADCHUNK: typeof _redis_bloom_dist_commands_cuckoo_LOADCHUNK;
        loadChunk: typeof _redis_bloom_dist_commands_cuckoo_LOADCHUNK;
        RESERVE: typeof _redis_bloom_dist_commands_cuckoo_RESERVE;
        reserve: typeof _redis_bloom_dist_commands_cuckoo_RESERVE;
        SCANDUMP: typeof _redis_bloom_dist_commands_cuckoo_SCANDUMP;
        scanDump: typeof _redis_bloom_dist_commands_cuckoo_SCANDUMP;
    };
    tDigest: {
        ADD: typeof _redis_bloom_dist_commands_t_digest_ADD;
        add: typeof _redis_bloom_dist_commands_t_digest_ADD;
        BYRANK: typeof _redis_bloom_dist_commands_t_digest_BYRANK;
        byRank: typeof _redis_bloom_dist_commands_t_digest_BYRANK;
        BYREVRANK: typeof _redis_bloom_dist_commands_t_digest_BYREVRANK;
        byRevRank: typeof _redis_bloom_dist_commands_t_digest_BYREVRANK;
        CDF: typeof _redis_bloom_dist_commands_t_digest_CDF;
        cdf: typeof _redis_bloom_dist_commands_t_digest_CDF;
        CREATE: typeof _redis_bloom_dist_commands_t_digest_CREATE;
        create: typeof _redis_bloom_dist_commands_t_digest_CREATE;
        INFO: typeof _redis_bloom_dist_commands_t_digest_INFO;
        info: typeof _redis_bloom_dist_commands_t_digest_INFO;
        MAX: typeof _redis_bloom_dist_commands_t_digest_MAX;
        max: typeof _redis_bloom_dist_commands_t_digest_MAX;
        MERGE: typeof _redis_bloom_dist_commands_t_digest_MERGE;
        merge: typeof _redis_bloom_dist_commands_t_digest_MERGE;
        MIN: typeof _redis_bloom_dist_commands_t_digest_MIN;
        min: typeof _redis_bloom_dist_commands_t_digest_MIN;
        QUANTILE: typeof _redis_bloom_dist_commands_t_digest_QUANTILE;
        quantile: typeof _redis_bloom_dist_commands_t_digest_QUANTILE;
        RANK: typeof _redis_bloom_dist_commands_t_digest_RANK;
        rank: typeof _redis_bloom_dist_commands_t_digest_RANK;
        RESET: typeof _redis_bloom_dist_commands_t_digest_RESET;
        reset: typeof _redis_bloom_dist_commands_t_digest_RESET;
        REVRANK: typeof _redis_bloom_dist_commands_t_digest_REVRANK;
        revRank: typeof _redis_bloom_dist_commands_t_digest_REVRANK;
        TRIMMED_MEAN: typeof _redis_bloom_dist_commands_t_digest_TRIMMED_MEAN;
        trimmedMean: typeof _redis_bloom_dist_commands_t_digest_TRIMMED_MEAN;
    };
    topK: {
        ADD: typeof _redis_bloom_dist_commands_top_k_ADD;
        add: typeof _redis_bloom_dist_commands_top_k_ADD;
        COUNT: typeof _redis_bloom_dist_commands_top_k_COUNT;
        count: typeof _redis_bloom_dist_commands_top_k_COUNT;
        INCRBY: typeof _redis_bloom_dist_commands_top_k_INCRBY;
        incrBy: typeof _redis_bloom_dist_commands_top_k_INCRBY;
        INFO: typeof _redis_bloom_dist_commands_top_k_INFO;
        info: typeof _redis_bloom_dist_commands_top_k_INFO;
        LIST_WITHCOUNT: typeof _redis_bloom_dist_commands_top_k_LIST_WITHCOUNT;
        listWithCount: typeof _redis_bloom_dist_commands_top_k_LIST_WITHCOUNT;
        LIST: typeof _redis_bloom_dist_commands_top_k_LIST;
        list: typeof _redis_bloom_dist_commands_top_k_LIST;
        QUERY: typeof _redis_bloom_dist_commands_top_k_QUERY;
        query: typeof _redis_bloom_dist_commands_top_k_QUERY;
        RESERVE: typeof _redis_bloom_dist_commands_top_k_RESERVE;
        reserve: typeof _redis_bloom_dist_commands_top_k_RESERVE;
    };
};
type RedisDefaultModules = typeof modules;
type RedisClientType<M extends RedisModules = RedisDefaultModules, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisClientType$2<M, F, S>;
declare function createClient$1<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(options?: RedisClientOptions$1<M, F, S>): RedisClientType$2<RedisDefaultModules & M, F, S>;
type RedisClusterType<M extends RedisModules = RedisDefaultModules, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisClusterType$1<M, F, S>;
declare function createCluster$1<M extends RedisModules, F extends RedisFunctions$1, S extends RedisScripts$1>(options: RedisClusterOptions<M, F, S>): RedisClusterType<RedisDefaultModules & M, F, S>;

type index_d_RediSearchSchema = RediSearchSchema;
type index_d_RedisClientType<M extends RedisModules = RedisDefaultModules, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisClientType<M, F, S>;
type index_d_RedisClusterOptions<M extends RedisModules = Record<string, never>, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisClusterOptions<M, F, S>;
type index_d_RedisClusterType<M extends RedisModules = RedisDefaultModules, F extends RedisFunctions$1 = Record<string, never>, S extends RedisScripts$1 = Record<string, never>> = RedisClusterType<M, F, S>;
type index_d_RedisDefaultModules = RedisDefaultModules;
type index_d_RedisModules = RedisModules;
type index_d_SearchReply = SearchReply;
type index_d_SetOptions = SetOptions;
declare namespace index_d {
  export { AbortError$1 as AbortError, AggregateGroupByReducers$2 as AggregateGroupByReducers, AggregateSteps$2 as AggregateSteps, ClientClosedError$1 as ClientClosedError, ClientOfflineError$1 as ClientOfflineError, ConnectionTimeoutError$1 as ConnectionTimeoutError, DisconnectsClientError$1 as DisconnectsClientError, ErrorReply$1 as ErrorReply, GeoReplyWith$1 as GeoReplyWith, Graph$1 as Graph, MultiErrorReply$1 as MultiErrorReply, ReconnectStrategyError$1 as ReconnectStrategyError, type index_d_RediSearchSchema as RediSearchSchema, type RedisClientOptions$1 as RedisClientOptions, type index_d_RedisClientType as RedisClientType, type index_d_RedisClusterOptions as RedisClusterOptions, type index_d_RedisClusterType as RedisClusterType, type index_d_RedisDefaultModules as RedisDefaultModules, RedisFlushModes$1 as RedisFlushModes, type RedisFunctions$1 as RedisFunctions, type index_d_RedisModules as RedisModules, type RedisScripts$1 as RedisScripts, RedisSearchLanguages$1 as RedisSearchLanguages, RootNodesUnavailableError$1 as RootNodesUnavailableError, SchemaFieldTypes$1 as SchemaFieldTypes, SchemaTextFieldPhonetics$1 as SchemaTextFieldPhonetics, type SearchOptions$1 as SearchOptions, type index_d_SearchReply as SearchReply, type index_d_SetOptions as SetOptions, SocketClosedUnexpectedlyError$1 as SocketClosedUnexpectedlyError, TimeSeriesAggregationType$1 as TimeSeriesAggregationType, TimeSeriesBucketTimestamp$1 as TimeSeriesBucketTimestamp, TimeSeriesDuplicatePolicies$1 as TimeSeriesDuplicatePolicies, TimeSeriesEncoding$1 as TimeSeriesEncoding, TimeSeriesReducers$1 as TimeSeriesReducers, VectorAlgorithms$1 as VectorAlgorithms, WatchError$1 as WatchError, commandOptions$1 as commandOptions, createClient$1 as createClient, createCluster$1 as createCluster, defineScript$1 as defineScript };
}

declare const createClient: typeof RedisClient$1.create;
declare const commandOptions: typeof RedisClient$1.commandOptions;

declare const createCluster: typeof RedisCluster.create;

declare const AbortError: typeof AbortError$1;
declare const AggregateGroupByReducers: typeof AggregateGroupByReducers$2;
declare const AggregateSteps: typeof AggregateSteps$2;
declare const ClientClosedError: typeof ClientClosedError$1;
declare const ClientOfflineError: typeof ClientOfflineError$1;
declare const ConnectionTimeoutError: typeof ConnectionTimeoutError$1;
declare const DisconnectsClientError: typeof DisconnectsClientError$1;
declare const ErrorReply: typeof ErrorReply$1;
declare const GeoReplyWith: typeof GeoReplyWith$1;
declare const Graph: typeof Graph$1;
declare const MultiErrorReply: typeof MultiErrorReply$1;
declare const ReconnectStrategyError: typeof ReconnectStrategyError$1;
declare const RedisFlushModes: typeof RedisFlushModes$1;
declare const RedisSearchLanguages: typeof RedisSearchLanguages$1;
declare const RootNodesUnavailableError: typeof RootNodesUnavailableError$1;
declare const SchemaFieldTypes: typeof SchemaFieldTypes$1;
declare const SchemaTextFieldPhonetics: typeof SchemaTextFieldPhonetics$1;
declare const SocketClosedUnexpectedlyError: typeof SocketClosedUnexpectedlyError$1;
declare const TimeSeriesAggregationType: typeof TimeSeriesAggregationType$1;
declare const TimeSeriesBucketTimestamp: typeof TimeSeriesBucketTimestamp$1;
declare const TimeSeriesDuplicatePolicies: typeof TimeSeriesDuplicatePolicies$1;
declare const TimeSeriesEncoding: typeof TimeSeriesEncoding$1;
declare const TimeSeriesReducers: typeof TimeSeriesReducers$1;
declare const VectorAlgorithms: typeof VectorAlgorithms$1;
declare const WatchError: typeof WatchError$1;
declare const defineScript: typeof defineScript$1;

export { AbortError, AggregateGroupByReducers, AggregateSteps, ClientClosedError, ClientOfflineError, ConnectionTimeoutError, DisconnectsClientError, ErrorReply, GeoReplyWith, Graph, MultiErrorReply, ReconnectStrategyError, type RediSearchSchema, type RedisClientOptions$1 as RedisClientOptions, type RedisClientType, type RedisClusterOptions, type RedisClusterType, type RedisDefaultModules, RedisFlushModes, type RedisFunctions$1 as RedisFunctions, type RedisModules, type RedisScripts$1 as RedisScripts, RedisSearchLanguages, RootNodesUnavailableError, SchemaFieldTypes, SchemaTextFieldPhonetics, type SearchOptions$1 as SearchOptions, type SearchReply, type SetOptions, SocketClosedUnexpectedlyError, TimeSeriesAggregationType, TimeSeriesBucketTimestamp, TimeSeriesDuplicatePolicies, TimeSeriesEncoding, TimeSeriesReducers, VectorAlgorithms, WatchError, commandOptions, createClient, createCluster, index_d as default, defineScript };
